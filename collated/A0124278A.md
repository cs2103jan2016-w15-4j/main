# A0124278A
###### bin\dooyit\ui\resrc\css\common.css
``` css
/**
 * CSS for common styles
 * @author 	Wu Wenqi
 * @version	0.5
 * @since 	2016-04-10
 */

.header-view {
	-fx-padding: 10; 
}

.main-view {
	-fx-background-color: transparent;
}

.scroll-pane {
    -fx-background-insets: 0;
    -fx-padding: 0;
}

.scroll-pane:focused {
    -fx-background-insets: 0;
}

.scroll-pane .corner {
    -fx-background-insets: 0;
}

.scroll-bar:horizontal .track,
.scroll-bar:vertical .track {
	-fx-border-color: transparent;
	-fx-background-radius: 0em;
	-fx-border-radius: 2em;
}

.scroll-bar:horizontal .increment-button,
.scroll-bar:horizontal .decrement-button {
	-fx-background-color: transparent;
	-fx-background-radius: 0em;
	-fx-padding: 0 0 10 0;
}

.scroll-bar:vertical .increment-button,
.scroll-bar:vertical .decrement-button {
	-fx-background-color: transparent;
	-fx-background-radius: 0em;
	-fx-padding: 0 10 0 0;
}

.scroll-bar .increment-arrow,
.scroll-bar .decrement-arrow {
	-fx-shape: " ";
	-fx-padding: 0;
}

.scroll-bar:horizontal .thumb,
.scroll-bar:vertical .thumb {
	-fx-background-color: derive(black, 90%);
	-fx-background-insets: 2, 0, 0;
	-fx-background-radius: 2em;
}

.menu-view {
	-fx-padding: 20 0 20 0;
}

.btn-select-view{
	-fx-background-color: none;
	-fx-background-radius: 0;
	-fx-alignment: center-left;
	-fx-padding: 7 20 7 20;
}

.btn-select-label{
	-fx-font-family: "Segoe UI";
	-fx-font-size: 14px;
}

.category-title {
	-fx-padding: 50 20 7 20;
	-fx-font-family: "Segoe UI";
	-fx-font-size: 13px;
}

.category-name {
	-fx-font-family: "Segoe UI";
	-fx-font-size: 14px;
}

.category-box-wrapper {
	-fx-alignment: center-left;
	-fx-padding: 0;
}

.command-box {
	-fx-padding: 15;
}

.command-textfield {
	-fx-pref-height: 34px;
	-fx-font-family: "Consolas";
	-fx-font-size: 14px;
}

.day-box {
	-fx-padding: 20;
}

.day-title {
	-fx-padding: 0 0 10 0;
	-fx-font-family: "Segoe UI";
	-fx-font-size: 18px;
}

.day-title-faded {
	-fx-opacity: 0.4;
}

.day-task-box {
	-fx-padding: 10 0 10 0;
	-fx-border-color: transparent transparent #f0f0f0 transparent;
}

.task-id {
	-fx-font-family: "Tahoma";
	-fx-font-size: 12px;
}

.task-name {
	-fx-padding: 0 0 0 0;
	-fx-font-family: "Segoe UI";
	-fx-font-size: 14px;
}

.task-period {
	-fx-font-family: "Verdana";
	-fx-font-size: 13;
	-fx-padding: 0 0 0 0;
}

.task-period-overdue {
	-fx-text-fill: red;
	-fx-font-size: 13;
	-fx-padding: 0 0 0 0;
}

.task-checkbox .box {
	-fx-background-radius: 50%;
	-fx-border-radius: 50%;
}

.task-checkbox .box:hover {
	-fx-border-color: #ff6c57;
}

.task-category-label {
	-fx-padding: 3 5 3 5;
	-fx-font-family: "Segoe UI";
	-fx-font-size: 12px;
}

.task-pane-icon {
	-glyph-size: 120px;
}

.task-message {
	-fx-background-radius: 7;
	-fx-padding: 0;
	-fx-border-color: transparent;
	-fx-border-radius: 7;
	-fx-font-family: "Segoe UI";
	-fx-font-size: 14px;
}

.message-box-label {
	-fx-background-color: rgba(10, 10, 10, 1);
	-fx-background-radius: 0;
	-fx-text-fill: #f0f0f0;
	-fx-padding: 0 15 0 15;
	-fx-border-color: transparent;
	-fx-border-radius: 0;
	-fx-font-family: "Euphemia";
	-fx-font-size: 14px;
}

.message-box-label-error {
	-fx-background-color: #E41B17;
}

.help-box-wrapper {
	-fx-background-color: rgba(10, 10, 10, 0.95);
	-fx-background-radius: 10;
	-fx-text-fill: #f0f0f0;
	-fx-padding: 30 30 30 30;
	-fx-border-color: transparent;
	-fx-border-radius: 10;
}

.help-box-title {
	-fx-text-fill: #f0f0f0;
	-fx-font-family: "Euphemia";
	-fx-font-size: 18px;
}

.help-box-content-label {
	-fx-text-fill: #f0f0f0;	
	-fx-font-family: "Segoe UI";
	-fx-font-size: 14px;
}

.help-box-close-label {
	-fx-text-fill: #5AC8FB;
	-fx-font-family: "Euphemia";
	-fx-font-size: 18px;
}




```
###### bin\dooyit\ui\resrc\css\theme_aqua.css
``` css
/**
 * CSS for aqua skin
 * @author 	Wu Wenqi
 * @version	0.5
 * @since 	2016-04-10
 */
 
.main-view > .viewport {
	-fx-background-color: white;
}

.scroll-bar:horizontal .track,
.scroll-bar:vertical .track{
	-fx-background-color: white;
}

.header-view {
	-fx-background-color: #5AC8FB;
}

.header-title {
	-fx-text-fill: white;
}

.btn-select-view{
	-fx-text-fill: #deebf7;
}

.btn-select-label{
	-fx-text-fill: #303030;
}

.btn-select-view:selected {
	-fx-background-color: #D1EEFC;
}

.category-title {
	-fx-text-fill: #5AC8FB;
}

.category-name {
	-fx-text-fill: #303030;
}

.menu-view {
	-fx-background-color: #f7f7f7;
}

.menu-pane > .viewport {
	-fx-background-color: #f7f7f7;
}

.command-box {
	-fx-background-color: #f7f7f7;
}

.command-textfield {
	-fx-background-color: white;
	-fx-text-fill: #303030;
}

.day-box {
	-fx-background-color: white;
}

.day-title {
	-fx-text-fill: #5AC8FB;
}

.day-task-box {
	-fx-border-color: transparent transparent #f0f0f0 transparent;
}

.task-checkbox .box {
	-fx-background-color: white;
	-fx-border-color: #d0d0d0;
}

.task-pane-icon {
	-fx-fill: #5AC8FB;
}

.task-id {
	-fx-text-fill: #c0c0c0;
}

.task-name {
	-fx-text-fill: #262626;
}

.task-period {
	-fx-font-size: 13px;
	-fx-text-fill: #262626;
}

.task-period-overdue {
	-fx-text-fill: red;
}
```
###### bin\dooyit\ui\resrc\css\theme_custom.css
``` css
/**
 * CSS for custom skin
 * @author 	Wu Wenqi
 * @version	0.5
 * @since 	2016-04-10
 */

.main-view > .viewport {
	-fx-background-color: white;
}

.scroll-bar:horizontal .track,
.scroll-bar:vertical .track{
	-fx-background-color: white;
}

.header-view {
	-fx-background-color: #ff3a2d;
}

.header-title {
	-fx-text-fill: white;
}

.btn-select-view{
	-fx-text-fill: #deebf7;
}

.btn-select-label{
	-fx-text-fill: #f7f7f7;
}

.btn-select-view:selected {
	-fx-background-color: black;
}

.category-title {
	-fx-text-fill: #f7f7f7;
}

.category-name {
	-fx-text-fill: #f7f7f7;
}

.menu-view {
	-fx-background-color: #393939;
}

.menu-pane > .viewport {
	-fx-background-color: #393939;
}

.command-box {
	-fx-background-color: #393939;
}

.command-textfield {
	-fx-background-color: black;
	-fx-text-fill: red;
}

.day-box {
	-fx-background-color: white;
}

.day-title {
	-fx-text-fill: #0b99bc;
}

.day-task-box {
	-fx-border-color: transparent transparent #f0f0f0 transparent;
}

.task-checkbox .box {
	-fx-background-color: white;
	-fx-border-color: #d0d0d0;
}

.task-pane-icon {
	-fx-fill: #5AC8FB;
}

.task-id {
	-fx-text-fill: #ee4b3e;
}

.task-name {
	-fx-text-fill: #262626;
}

.task-period {
	-fx-font-size: 13px;
	-fx-text-fill: #262626;
}

.task-period-overdue {
	-fx-text-fill: red;
}
```
###### bin\dooyit\ui\resrc\css\theme_dark.css
``` css
/**
 * CSS for dark skin
 * @author 	Wu Wenqi
 * @version	0.5
 * @since 	2016-04-10
 */
 
.main-view > .viewport {
	-fx-background-color: #262626;
}

.scroll-bar:horizontal .track,
.scroll-bar:vertical .track{
	-fx-background-color: #262626;
}

.header-view {
	-fx-background-color: #353535;
}

.header-title {
	-fx-text-fill: white;
}

.btn-select-view{
	-fx-text-fill: #deebf7;
}

.btn-select-label{
	-fx-text-fill: #f7f7f7;
}

.btn-select-view:selected {
	/*-fx-background-color: linear-gradient(from 15% 15% to 75% 75%, #2e75b6, #314e79);*/
	-fx-background-color: #2e75b6;
}

.category-title {
	-fx-text-fill: #52e8e5;
}

.category-name {
	-fx-text-fill: #deebf7;
}

.menu-view {
	/*-fx-background-color: linear-gradient(from 25% 25% to 75% 75%, #222a35, #1f4e79);*/
	-fx-background-color: #3b3b3b;
}

.menu-pane > .viewport {
	-fx-background-color: #3b3b3b;
}

.command-box {
	-fx-background-color: #3b3b3b;
}

.command-textfield {
	-fx-background-color: #262626;
	-fx-text-fill: #f7f7f7;
}

.day-box {
	-fx-background-color: #262626;
}

.day-title {
	-fx-text-fill: #52e8e5;
}

.day-task-box {
	-fx-padding: 13 0 13 0;
	-fx-border-color: transparent transparent #353535 transparent;
}

.task-checkbox .box {
	-fx-background-color: #404040;
	-fx-background-radius: 50%;
	-fx-border-radius: 50%;
	-fx-border-color: #606060;
}

.task-pane-icon {
	-fx-fill: #333F50;
}

.task-message {
	-fx-text-fill: #ebebeb;
}

.task-id {
	/*-fx-text-fill: #585858;*/
	-fx-text-fill: #ff6c57;
}

.task-name {
	-fx-text-fill: #ebebeb;
}

.task-period {
	-fx-font-size: 13px;
	-fx-text-fill: #C7C7CC;
}

.task-period-overdue {
	-fx-text-fill: red;
}

.task-category-label {
	-fx-text-fill: #ebebeb;
}
```
###### bin\dooyit\ui\resrc\css\theme_light.css
``` css
/**
 * CSS for light skin
 * @author 	Wu Wenqi
 * @version	0.5
 * @since 	2016-04-10
 */

.main-view > .viewport {
	-fx-background-color: white;
}

.scroll-bar:horizontal .track,
.scroll-bar:vertical .track{
	-fx-background-color: white;
}

.header-view {
	-fx-background-color: #ff6c57;
}

.header-title {
	-fx-text-fill: white;
}

.btn-select-view{
	-fx-text-fill: #deebf7;
}

.btn-select-view:selected {
	-fx-background-color: #FFDDE6;
}

.category-title {
	-fx-text-fill: #ff6c57;
}

.menu-view {
	-fx-background-color: #f6f6f6;
}

.menu-pane > .viewport {
	-fx-background-color: #f6f6f6;
}

.command-box {
	-fx-background-color: #f7f7f7;
}

.command-textfield {
	-fx-background-color: white;
	-fx-text-fill: #303030;
}

.day-box {
	-fx-background-color: white;
}

.day-title {
	-fx-text-fill: #FF5E3A;
}

.task-id {
	-fx-text-fill: #c0c0c0;
}

.task-name {
	-fx-text-fill: #393939;
}

.task-period {
	-fx-font-size: 13px;
	-fx-text-fill: black;
}

.task-period-overdue {
	-fx-text-fill: red;
}

.task-checkbox .box {
	-fx-background-color: white;
	-fx-border-color: #d0d0d0;
}

.task-pane-icon {
	-fx-fill: #f0f0f0;
}

.task-message {
	-fx-text-fill: #909090;
}

.command-helper-list-view:focused, .command-helper-list-view:selected {
	-fx-background-color: #ff6c57;
	-fx-text-fill: white;
}

.command-helper-list-view {
	-fx-text-fill: #262626;
}

.command-helper-list-view:odd, .command-helper-list-view:even {
	-fx-background-color: white;
}

.command-helper-list-view:selected:focused, .command-helper-list-view:filled:selected {
	-fx-background-color: #ff6c57;
	-fx-text-fill: white;
}





```
###### src\dooyit\ui\Main.java
``` java
package dooyit.ui;

import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javafx.application.Application;
import javafx.stage.Stage;
import javafx.scene.image.Image;

/**
 * The <tt>Main</tt> class is the entry point for the application. 
 * @author 	Wu Wenqi
 * @version	0.5
 * @since 	2016-04-10
 */

public class Main extends Application {
	private static final String APP_ICON = "/dooyit/ui/resrc/images/icon.png";
	private static final String APP_TITLE = "Dooyit";
	private static final int MINWIDTH_STAGE = 720;
	private static final int MINHEIGHT_STAGE = 620;
	private static final String LOG_MSG_START_SUCCESS = "Stage is successfully initialized and shown.";
	
	private Logger logger;
	private UIController ui;
	
	// Need to keep this for Java Virtual Machine to know where is Main class
	public static void main(String[] args) {
		launch(args);
	}

	/**
	 * This method is used to start the application.
	 * @param primaryStage This is the primary stage of the application.
	 */
	@Override
	public void start(Stage primaryStage) throws IOException {
		initLogger();
		try {
			initStage(primaryStage);
			this.ui = UIController.getInstance(primaryStage);
			primaryStage.setScene(this.ui.getScene());
			primaryStage.show();
			this.logger.log(Level.INFO, LOG_MSG_START_SUCCESS);
		} catch (Exception e) {
			this.logger.log(Level.SEVERE, e.getMessage());
		}
	}
	
	/**
	 * This method is used to initialize the logger.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initLogger() {
		this.logger = Logger.getLogger(getClass().getName());
	}
	
	/**
	 * This method is used to initialize the primary stage.
	 * @param primaryStage This is the primary stage of the application.
	 */
	private void initStage(Stage primaryStage) {
		primaryStage.getIcons().add(new Image(APP_ICON));
		primaryStage.setTitle(APP_TITLE);
		primaryStage.setMinWidth(MINWIDTH_STAGE);
		primaryStage.setWidth(MINWIDTH_STAGE);
		primaryStage.setMinHeight(MINHEIGHT_STAGE);
		primaryStage.setHeight(MINHEIGHT_STAGE);
	}
}
```
###### src\dooyit\ui\resrc\css\common.css
``` css
/**
 * CSS for common styles
 * @author 	Wu Wenqi
 * @version	0.5
 * @since 	2016-04-10
 */

.header-view {
	-fx-padding: 10; 
}

.main-view {
	-fx-background-color: transparent;
}

.scroll-pane {
    -fx-background-insets: 0;
    -fx-padding: 0;
}

.scroll-pane:focused {
    -fx-background-insets: 0;
}

.scroll-pane .corner {
    -fx-background-insets: 0;
}

.scroll-bar:horizontal .track,
.scroll-bar:vertical .track {
	-fx-border-color: transparent;
	-fx-background-radius: 0em;
	-fx-border-radius: 2em;
}

.scroll-bar:horizontal .increment-button,
.scroll-bar:horizontal .decrement-button {
	-fx-background-color: transparent;
	-fx-background-radius: 0em;
	-fx-padding: 0 0 10 0;
}

.scroll-bar:vertical .increment-button,
.scroll-bar:vertical .decrement-button {
	-fx-background-color: transparent;
	-fx-background-radius: 0em;
	-fx-padding: 0 10 0 0;
}

.scroll-bar .increment-arrow,
.scroll-bar .decrement-arrow {
	-fx-shape: " ";
	-fx-padding: 0;
}

.scroll-bar:horizontal .thumb,
.scroll-bar:vertical .thumb {
	-fx-background-color: derive(black, 90%);
	-fx-background-insets: 2, 0, 0;
	-fx-background-radius: 2em;
}

.menu-view {
	-fx-padding: 20 0 20 0;
}

.btn-select-view{
	-fx-background-color: none;
	-fx-background-radius: 0;
	-fx-alignment: center-left;
	-fx-padding: 7 20 7 20;
}

.btn-select-label{
	-fx-font-family: "Segoe UI";
	-fx-font-size: 14px;
}

.category-title {
	-fx-padding: 50 20 7 20;
	-fx-font-family: "Segoe UI";
	-fx-font-size: 13px;
}

.category-name {
	-fx-font-family: "Segoe UI";
	-fx-font-size: 14px;
}

.category-box-wrapper {
	-fx-alignment: center-left;
	-fx-padding: 0;
}

.command-box {
	-fx-padding: 15;
}

.command-textfield {
	-fx-pref-height: 34px;
	-fx-font-family: "Consolas";
	-fx-font-size: 14px;
}

.day-box {
	-fx-padding: 20;
}

.day-title {
	-fx-padding: 0 0 10 0;
	-fx-font-family: "Segoe UI";
	-fx-font-size: 18px;
}

.day-title-faded {
	-fx-opacity: 0.4;
}

.day-task-box {
	-fx-padding: 10 0 10 0;
	-fx-border-color: transparent transparent #f0f0f0 transparent;
}

.task-id {
	-fx-font-family: "Tahoma";
	-fx-font-size: 12px;
}

.task-name {
	-fx-padding: 0 0 0 0;
	-fx-font-family: "Segoe UI";
	-fx-font-size: 14px;
}

.task-period {
	-fx-font-family: "Verdana";
	-fx-font-size: 13;
	-fx-padding: 0 0 0 0;
}

.task-period-overdue {
	-fx-text-fill: red;
	-fx-font-size: 13;
	-fx-padding: 0 0 0 0;
}

.task-checkbox .box {
	-fx-background-radius: 50%;
	-fx-border-radius: 50%;
}

.task-checkbox .box:hover {
	-fx-border-color: #ff6c57;
}

.task-category-label {
	-fx-padding: 3 5 3 5;
	-fx-font-family: "Segoe UI";
	-fx-font-size: 12px;
}

.task-pane-icon {
	-glyph-size: 120px;
}

.task-message {
	-fx-background-radius: 7;
	-fx-padding: 0;
	-fx-border-color: transparent;
	-fx-border-radius: 7;
	-fx-font-family: "Segoe UI";
	-fx-font-size: 14px;
}

.message-box-label {
	-fx-background-color: rgba(10, 10, 10, 1);
	-fx-background-radius: 0;
	-fx-text-fill: #f0f0f0;
	-fx-padding: 0 15 0 15;
	-fx-border-color: transparent;
	-fx-border-radius: 0;
	-fx-font-family: "Euphemia";
	-fx-font-size: 14px;
}

.message-box-label-error {
	-fx-background-color: #E41B17;
}

.help-box-wrapper {
	-fx-background-color: rgba(10, 10, 10, 0.95);
	-fx-background-radius: 10;
	-fx-text-fill: #f0f0f0;
	-fx-padding: 30 30 30 30;
	-fx-border-color: transparent;
	-fx-border-radius: 10;
}

.help-box-title {
	-fx-text-fill: #f0f0f0;
	-fx-font-family: "Euphemia";
	-fx-font-size: 18px;
}

.help-box-content-label {
	-fx-text-fill: #f0f0f0;	
	-fx-font-family: "Segoe UI";
	-fx-font-size: 14px;
}

.help-box-close-label {
	-fx-text-fill: #5AC8FB;
	-fx-font-family: "Euphemia";
	-fx-font-size: 18px;
}




```
###### src\dooyit\ui\resrc\css\theme_aqua.css
``` css
/**
 * CSS for aqua skin
 * @author 	Wu Wenqi
 * @version	0.5
 * @since 	2016-04-10
 */
 
.main-view > .viewport {
	-fx-background-color: white;
}

.scroll-bar:horizontal .track,
.scroll-bar:vertical .track{
	-fx-background-color: white;
}

.header-view {
	-fx-background-color: #5AC8FB;
}

.header-title {
	-fx-text-fill: white;
}

.btn-select-view{
	-fx-text-fill: #deebf7;
}

.btn-select-label{
	-fx-text-fill: #303030;
}

.btn-select-view:selected {
	-fx-background-color: #D1EEFC;
}

.category-title {
	-fx-text-fill: #5AC8FB;
}

.category-name {
	-fx-text-fill: #303030;
}

.menu-view {
	-fx-background-color: #f7f7f7;
}

.menu-pane > .viewport {
	-fx-background-color: #f7f7f7;
}

.command-box {
	-fx-background-color: #f7f7f7;
}

.command-textfield {
	-fx-background-color: white;
	-fx-text-fill: #303030;
}

.day-box {
	-fx-background-color: white;
}

.day-title {
	-fx-text-fill: #5AC8FB;
}

.day-task-box {
	-fx-border-color: transparent transparent #f0f0f0 transparent;
}

.task-checkbox .box {
	-fx-background-color: white;
	-fx-border-color: #d0d0d0;
}

.task-pane-icon {
	-fx-fill: #5AC8FB;
}

.task-id {
	-fx-text-fill: #c0c0c0;
}

.task-name {
	-fx-text-fill: #262626;
}

.task-period {
	-fx-font-size: 13px;
	-fx-text-fill: #262626;
}

.task-period-overdue {
	-fx-text-fill: red;
}
```
###### src\dooyit\ui\resrc\css\theme_custom.css
``` css
/**
 * CSS for custom skin
 * @author 	Wu Wenqi
 * @version	0.5
 * @since 	2016-04-10
 */

.main-view > .viewport {
	-fx-background-color: white;
}

.scroll-bar:horizontal .track,
.scroll-bar:vertical .track{
	-fx-background-color: white;
}

.header-view {
	-fx-background-color: #ff3a2d;
}

.header-title {
	-fx-text-fill: white;
}

.btn-select-view{
	-fx-text-fill: #deebf7;
}

.btn-select-label{
	-fx-text-fill: #f7f7f7;
}

.btn-select-view:selected {
	-fx-background-color: black;
}

.category-title {
	-fx-text-fill: #f7f7f7;
}

.category-name {
	-fx-text-fill: #f7f7f7;
}

.menu-view {
	-fx-background-color: #393939;
}

.menu-pane > .viewport {
	-fx-background-color: #393939;
}

.command-box {
	-fx-background-color: #393939;
}

.command-textfield {
	-fx-background-color: black;
	-fx-text-fill: red;
}

.day-box {
	-fx-background-color: white;
}

.day-title {
	-fx-text-fill: #0b99bc;
}

.day-task-box {
	-fx-border-color: transparent transparent #f0f0f0 transparent;
}

.task-checkbox .box {
	-fx-background-color: white;
	-fx-border-color: #d0d0d0;
}

.task-pane-icon {
	-fx-fill: #5AC8FB;
}

.task-id {
	-fx-text-fill: #ee4b3e;
}

.task-name {
	-fx-text-fill: #262626;
}

.task-period {
	-fx-font-size: 13px;
	-fx-text-fill: #262626;
}

.task-period-overdue {
	-fx-text-fill: red;
}
```
###### src\dooyit\ui\resrc\css\theme_dark.css
``` css
/**
 * CSS for dark skin
 * @author 	Wu Wenqi
 * @version	0.5
 * @since 	2016-04-10
 */
 
.main-view > .viewport {
	-fx-background-color: #262626;
}

.scroll-bar:horizontal .track,
.scroll-bar:vertical .track{
	-fx-background-color: #262626;
}

.header-view {
	-fx-background-color: #353535;
}

.header-title {
	-fx-text-fill: white;
}

.btn-select-view{
	-fx-text-fill: #deebf7;
}

.btn-select-label{
	-fx-text-fill: #f7f7f7;
}

.btn-select-view:selected {
	/*-fx-background-color: linear-gradient(from 15% 15% to 75% 75%, #2e75b6, #314e79);*/
	-fx-background-color: #2e75b6;
}

.category-title {
	-fx-text-fill: #52e8e5;
}

.category-name {
	-fx-text-fill: #deebf7;
}

.menu-view {
	/*-fx-background-color: linear-gradient(from 25% 25% to 75% 75%, #222a35, #1f4e79);*/
	-fx-background-color: #3b3b3b;
}

.menu-pane > .viewport {
	-fx-background-color: #3b3b3b;
}

.command-box {
	-fx-background-color: #3b3b3b;
}

.command-textfield {
	-fx-background-color: #262626;
	-fx-text-fill: #f7f7f7;
}

.day-box {
	-fx-background-color: #262626;
}

.day-title {
	-fx-text-fill: #52e8e5;
}

.day-task-box {
	-fx-padding: 13 0 13 0;
	-fx-border-color: transparent transparent #353535 transparent;
}

.task-checkbox .box {
	-fx-background-color: #404040;
	-fx-background-radius: 50%;
	-fx-border-radius: 50%;
	-fx-border-color: #606060;
}

.task-pane-icon {
	-fx-fill: #333F50;
}

.task-message {
	-fx-text-fill: #ebebeb;
}

.task-id {
	/*-fx-text-fill: #585858;*/
	-fx-text-fill: #ff6c57;
}

.task-name {
	-fx-text-fill: #ebebeb;
}

.task-period {
	-fx-font-size: 13px;
	-fx-text-fill: #C7C7CC;
}

.task-period-overdue {
	-fx-text-fill: red;
}

.task-category-label {
	-fx-text-fill: #ebebeb;
}
```
###### src\dooyit\ui\resrc\css\theme_light.css
``` css
/**
 * CSS for light skin
 * @author 	Wu Wenqi
 * @version	0.5
 * @since 	2016-04-10
 */

.main-view > .viewport {
	-fx-background-color: white;
}

.scroll-bar:horizontal .track,
.scroll-bar:vertical .track{
	-fx-background-color: white;
}

.header-view {
	-fx-background-color: #ff6c57;
}

.header-title {
	-fx-text-fill: white;
}

.btn-select-view{
	-fx-text-fill: #deebf7;
}

.btn-select-view:selected {
	-fx-background-color: #FFDDE6;
}

.category-title {
	-fx-text-fill: #ff6c57;
}

.menu-view {
	-fx-background-color: #f6f6f6;
}

.menu-pane > .viewport {
	-fx-background-color: #f6f6f6;
}

.command-box {
	-fx-background-color: #f7f7f7;
}

.command-textfield {
	-fx-background-color: white;
	-fx-text-fill: #303030;
}

.day-box {
	-fx-background-color: white;
}

.day-title {
	-fx-text-fill: #FF5E3A;
}

.task-id {
	-fx-text-fill: #c0c0c0;
}

.task-name {
	-fx-text-fill: #393939;
}

.task-period {
	-fx-font-size: 13px;
	-fx-text-fill: black;
}

.task-period-overdue {
	-fx-text-fill: red;
}

.task-checkbox .box {
	-fx-background-color: white;
	-fx-border-color: #d0d0d0;
}

.task-pane-icon {
	-fx-fill: #f0f0f0;
}

.task-message {
	-fx-text-fill: #909090;
}

.command-helper-list-view:focused, .command-helper-list-view:selected {
	-fx-background-color: #ff6c57;
	-fx-text-fill: white;
}

.command-helper-list-view {
	-fx-text-fill: #262626;
}

.command-helper-list-view:odd, .command-helper-list-view:even {
	-fx-background-color: white;
}

.command-helper-list-view:selected:focused, .command-helper-list-view:filled:selected {
	-fx-background-color: #ff6c57;
	-fx-text-fill: white;
}





```
###### src\dooyit\ui\UICategoryBox.java
``` java
package dooyit.ui;

import dooyit.common.datatype.Category;
import javafx.event.EventHandler;
import javafx.scene.control.Label;
import javafx.scene.control.ToggleButton;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.HBox;
import javafx.scene.shape.Circle;

/**
 * The <tt>UICategoryBox</tt> class contains the methods to create and retrieve a category menu button. 
 * @author 	Wu Wenqi
 * @version	0.5
 * @since 	2016-04-10
 */

public class UICategoryBox {
	private static final String STYLECLASS_CAT_NAME = UIStyle.CATEGORY_NAME;
	private static final String STYLECLASS_CAT_CIRCLE = UIStyle.CATEGORY_CIRCLE;
	private static final String STYLECLASS_CAT_BOX = UIStyle.BTN_SELECT_VIEW;
	private static final String STYLECLASS_CAT_BOX_WRAPPER = UIStyle.CATEGORY_BOX_WRAPPER;
	private static final double CAT_CIRCLE_RADIUS = 4.0;
	private static final int SPACING_CAT_BOX_WRAPPER = 14;
	private static final int PREFWIDTH_CAT_BOX = 200;

	private UICategoryBoxContainer parent;
	private Category category;
	private HBox categoryBoxWrapper;
	private Label categoryName;
	private Circle categoryCircle;
	private ToggleButton categoryBox;

	/**
	 * This is the constructor method for <tt>UICategoryBox</tt> class.
	 * @param parent 	This is the parent <tt>UICategoryBoxContainer</tt> class.
	 * @param category 	This is the <tt>Category</tt> object to be displayed by the category menu button.
	 */
	protected UICategoryBox(UICategoryBoxContainer parent, Category category) {
		this.parent = parent;
		this.category = category;
		initialize();
	}
	
	/**
	 * This method is used to initialize the <tt>UICategoryBox</tt> class.
	 */
	private void initialize() {
		initCategoryName();
		initCategoryCircle();
		initCategoryBoxWrapper();
		initCategoryBox();
		initListeners();
	}
	
	/**
	 * This method is used to initialize the category name label.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initCategoryName() {
		this.categoryName = new Label(this.category.getName());
		this.categoryName.getStyleClass().add(STYLECLASS_CAT_NAME);
	}
	
	/**
	 * This method is used to initialize the colored circle for the category.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initCategoryCircle() {
		this.categoryCircle = new Circle(CAT_CIRCLE_RADIUS, this.category.getColour());
		this.categoryCircle.getStyleClass().add(STYLECLASS_CAT_CIRCLE);
	}
	
	/**
	 * This method is used to initialize the category box wrapper which contains the category circle and category name label.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initCategoryBoxWrapper() {
		this.categoryBoxWrapper = new HBox();
		this.categoryBoxWrapper.getChildren().addAll(this.categoryCircle, this.categoryName);
		this.categoryBoxWrapper.getStyleClass().add(STYLECLASS_CAT_BOX_WRAPPER);
		this.categoryBoxWrapper.setSpacing(SPACING_CAT_BOX_WRAPPER);
	}
	
	/**
	 * This method is used to initialize the category menu button which contains the category wrapper.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initCategoryBox() {
		this.categoryBox = new ToggleButton();
		this.categoryBox.setGraphic(this.categoryBoxWrapper);
		this.categoryBox.getStyleClass().add(STYLECLASS_CAT_BOX);
		this.categoryBox.setPrefWidth(PREFWIDTH_CAT_BOX);
		this.categoryBox.setToggleGroup(this.parent.getMainViewToggleGroup());
		this.categoryBox.setUserData(UIData.USERDATA_CATEGORY);
	}
	
	/**
	 * This method is used to initialize listeners for the category menu button.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initListeners() {
		this.categoryBox.addEventHandler(MouseEvent.MOUSE_CLICKED, new EventHandler<MouseEvent>() {
			@Override
			public void handle(MouseEvent event) {
				parent.processCommand(getShowCategoryCommand());
				event.consume();
			}
		});
	}
	
	/**
	 * This method is used to generate a command string for displaying the tasks belonging to this class's <tt>Category</tt> object.
	 * @return A command string.
	 */
	private String getShowCategoryCommand() {
		return UIData.CMD_SHOW_CAT + categoryName.getText();
	}
	
	/**
	 * This method is used to retrieve the <tt>Category</tt> object which is displayed by the category menu button.
	 * @return The <tt>Category</tt> object.
	 */
	protected Category getCategory() {
		return this.category;
	}
	
	/**
	 * This method is used to retrieve the category menu button.
	 * @return The category menu button.
	 */
	protected ToggleButton getView() {
		return this.categoryBox;
	}
}
```
###### src\dooyit\ui\UICategoryBoxContainer.java
``` java
package dooyit.ui;

import java.util.ArrayList;
import dooyit.common.datatype.Category;
import javafx.scene.control.ToggleGroup;
import javafx.scene.layout.VBox;

/**
 * The <tt>UICategoryBoxContainer</tt> class contains the methods to create and retrieve a list of <tt>UICategoryBox</tt> objects.
 * It also has a container view which contains the category menu buttons for the list.
 * @author 	Wu Wenqi
 * @version	0.5
 * @since 	2016-04-10
 */

public class UICategoryBoxContainer {
	private static final int SPACING_CAT_BOX_CONTAINER_VIEW = 8;

	private UISideMenu parent;
	private VBox categoryBoxContainerView;
	private ArrayList<UICategoryBox> categoryBoxList;
	private ArrayList<Category> categoryList;
	
	/**
	 * This is the constructor method for <tt>UICategoryBoxContainer</tt> class.
	 * @param parent This is the parent <tt>UISideMenu</tt> class.
	 * @param categoryList This is the list of <tt>Category</tt> objects to be displayed on the menu.
	 */
	protected UICategoryBoxContainer(UISideMenu parent, ArrayList<Category> categoryList) {
		this.parent = parent;
		this.categoryList = categoryList;
		initialize();
	}
	
	/**
	 * This method is used to initialize the <tt>UICategoryBoxContainer</tt> class.
	 */
	private void initialize() {
		initCategoryBoxContainerView();
		addAllCategories();
	}
	
	/**
	 * This method is used to initialize the view container which contains the category menu buttons.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initCategoryBoxContainerView() {
		this.categoryBoxContainerView = new VBox();
		this.categoryBoxContainerView.setSpacing(SPACING_CAT_BOX_CONTAINER_VIEW);
	}
	
	/**
	 * This method is used to create a <tt>UICategoryBox</tt> for each <tt>Category</tt> object.
	 * The category menu button for each <tt>UICategoryBox</tt> is added to the view container.
	 * This method is used by the <tt>initialize</tt> method.
	 */
	private void addAllCategories() {
		this.categoryBoxList = new ArrayList<UICategoryBox>();
		for (Category category : this.categoryList) {
			addCategory(category);
		}
	}
	
	/**
	 * This method is used to create a <tt>UICategoryBox</tt> for a <tt>Category</tt> object.
	 * The category menu button for <tt>UICategoryBox</tt> is subsequently added to the view container.
	 * This method is used by the <tt>addAllCategories</tt> method. 
	 * @param category This is the <tt>Category</tt> to be displayed by the category menu button.
	 */
	private void addCategory(Category category) {
		UICategoryBox categoryBox = new UICategoryBox(this, category);
		this.categoryBoxList.add(categoryBox);
		this.categoryBoxContainerView.getChildren().add(categoryBox.getView());
	}
	
	/**
	 * This method is used to get the <tt>ToggleGroup</tt> for the menu buttons.
	 * @return The <tt>ToggleGroup</tt> for the menu buttons.
	 */
	protected ToggleGroup getMainViewToggleGroup() {
		return this.parent.getMainViewToggleGroup();
	}
	
	/**
	 * This method is used to pass a command string to the parent <tt>UISideMenu</tt> class to be processed.
	 * @param cmd This is the command string to be processed.
	 */
	protected void processCommand(String cmd) {
		this.parent.processCommand(cmd);
	}
	
	/**
	 * This method is used to select the category menu button for a <tt>Category</tt>.
	 * @param category The <tt>Category</tt> whose menu button is to be selected.
	 */
	protected void setActiveCategoryButton(Category category) {
		for (UICategoryBox categoryBox : this.categoryBoxList) {
			if (categoryBox.getCategory().equals(category)) {
				categoryBox.getView().setSelected(true);
				break;
			}
		}
	}
	
	/**
	 * This method is used to retrieve the view container which contains the category menu buttons.
	 * @return The view container.
	 */
	protected VBox getView() {
		return this.categoryBoxContainerView;
	}

	/**
	 * This method is used to update the category menu buttons.
	 * @param categoryList The updated list of <tt>Category</tt> objects to create menu buttons for.
	 */
	protected void refresh(ArrayList<Category> categoryList) {
		this.categoryBoxContainerView.getChildren().clear();
		this.categoryBoxList.clear();
		for (Category category : categoryList) {
			addCategory(category);
		}
	}
	
	/**
	 * This method is used to get the name of the <tt>Category</tt> whose menu button is selected.
	 * @return The <tt>Category</tt> name.
	 */
	protected String getSelectedCategoryName() {
		for (UICategoryBox categoryBox : this.categoryBoxList) {
			if (categoryBox.getView().isSelected()) {
				return categoryBox.getCategory().getName();
			}
		}
		return UIData.EMP_STR;
	}
}
```
###### src\dooyit\ui\UICommandBox.java
``` java
package dooyit.ui;

import java.util.ArrayList;
import javafx.scene.control.TextField;
import javafx.scene.layout.HBox;

/**
 * The <tt>UICommandBox</tt> class contains the methods to modify the textfield 
 * in which the user types his commands, as well as to retrieve the user's command input history.
 * @author 	Wu Wenqi
 * @version	0.5
 * @since 	2016-04-10
 */

public class UICommandBox {
	private static final String CMD_TEXT_FIELD_PROMPT = "Enter command here. Type 'help' for manual.";
	private static final String STYLECLASS_CMD_TEXT_FIELD = UIStyle.COMMAND_TEXTFIELD;
	private static final int PREFWIDTH_CMD_TEXT_FIELD = 2000;
	private static final String STYLECLASS_CMD_BOX = UIStyle.COMMAND_BOX;
	private static final int INITIAL_HISTORY_INDEX = -1;
	
	private HBox commandBox;
	private TextField commandTextField;
	private int historyIndex;
	private ArrayList<String> commandHistory;
	
	/**
	 * This is the constructor method for <tt>UICommandBox</tt>.
	 */
	protected UICommandBox() {
		initialize();
	}
	
	/**
	 * This method is used to initialize the <tt>UICommandBox</tt>
	 * It is used by the constructor.
	 */
	private void initialize() {
		initCommandTextField();
		initCommandBox();
		initCommandHistory();
	}
	
	/**
	 * This method is used to initialize the textfield in which the user types his commands. 
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initCommandTextField() {
		this.commandTextField = new TextField();
		this.commandTextField.setPrefWidth(PREFWIDTH_CMD_TEXT_FIELD);
		this.commandTextField.setPromptText(CMD_TEXT_FIELD_PROMPT);
		this.commandTextField.getStyleClass().add(STYLECLASS_CMD_TEXT_FIELD);
	}
	
	/**
	 * This method is used to initialize the view box that contains the user input textfield.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initCommandBox() {
		this.commandBox = new HBox();
		this.commandBox.getStyleClass().add(STYLECLASS_CMD_BOX);
		this.commandBox.getChildren().addAll(commandTextField);
	}
	
	/**
	 * This method is used to initialize the <tt>ArrayList</tt> that will store the user's input history.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initCommandHistory() {
		this.historyIndex = INITIAL_HISTORY_INDEX;
		this.commandHistory = new ArrayList<String>();
	}
	
	/**
	 * This method is used to check if the index points to an earlier user input in history. 
	 * It is called by the <tt>showPrevHistory</tt> method.
	 * @return <tt>True</tt> if the index is valid, <tt>False</tt> otherwise.
	 */
	private boolean isValidPrevHistoryIndex() {
		return this.historyIndex >= 0 && this.historyIndex < this.commandHistory.size();
	}
	
	/**
	 * This method is used to check if the index points to a later user input in history. 
	 * It is called by the <tt>showNextHistory</tt> method.
	 * @return <tt>True</tt> if the index is valid, <tt>False</tt> otherwise.
	 */
	private boolean isValidNextHistoryIndex() {
		return this.historyIndex >= -1 && this.historyIndex < this.commandHistory.size() - 1;
	}
	
	/**
	 * This method is used to add an user input string to the history and update the index.
	 * @param s The user input to be added to history.
	 */
	protected void updateHistory(String s) {
		this.commandHistory.add(s);
		this.historyIndex = this.commandHistory.size() - 1;
	}
	
	/**
	 * This method is used to populate the textfield with an earlier user input from history.
	 */
	protected void showPrevHistory() {
		if (isValidPrevHistoryIndex()) {
			this.commandTextField.setText(this.commandHistory.get(this.historyIndex));
			this.historyIndex--;
		}
	}

	/**
	 * This method is used to populate the textfield with a later user input from history.
	 */
	protected void showNextHistory() {
		if (isValidNextHistoryIndex()) {
			this.historyIndex++;
			this.commandTextField.setText(this.commandHistory.get(this.historyIndex));
		} else {
			this.commandTextField.setText(UIData.EMP_STR);
		}
	}

	/**
	 * This method is used to retrieve the view box which contains the user input textfield.
	 * @return The view box which contains the user input textfield.
	 */
	protected HBox getView() {
		return this.commandBox;
	}

	/**
	 * This method is used to retrieve the user input textfield.
	 * @return The user input textfield.
	 */
	protected TextField getCommandTextField() {
		return this.commandTextField;
	}
	
	/**
	 * This method is used to check if the user input textfield is focused.
	 * @return <tt>True</tt> if the user textfield is focused, <tt>False</tt> otherwise.
	 */
	protected boolean isSelected() {
		return this.commandTextField.isFocused();
	}
	
	/**
	 * This method is used to focus the user input textfield.
	 */
	protected void select() {
		this.commandTextField.requestFocus();
	}
	
	/**
	 * This method is used to clear any text that is displayed in the user input textfield.
	 */
	protected void empty() {
		this.commandTextField.clear();
	}
}
```
###### src\dooyit\ui\UIController.java
``` java
package dooyit.ui;

import java.net.URL;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.event.EventHandler;
import javafx.scene.Scene;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.Toggle;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.web.WebView;
import javafx.stage.Stage;
import dooyit.common.datatype.Category;
import dooyit.common.datatype.TaskGroup;
import dooyit.logic.api.LogicController;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.Action;

/**
 * The <tt>UIController</tt> class contains methods to initialize all other classes belonging to the UI.
 * This is the only class from <tt>dooyit.ui</tt> that communicates directly with the Logic component. 
 * All communication between UI and Logic happens through it. 
 * The <tt>UIController</tt> class follows the Singleton design pattern, hence its constructor method is private.
 * It can be constructed using the <tt>getInstance</tt> method.
 * @author 	Wu Wenqi
 * @version	0.5
 * @since 	2016-04-10
 */

public class UIController {
	private static final int WIDTH_SCENE = 720;
	private static final int HEIGHT_SCENE = 580;
	private static final double SCROLL_SENSITIVITY = 0.1;
	private static final String STYLECLASS_MAIN_VIEW = UIStyle.MAIN_VIEW;
	private static final String SPACE = " ";
	private static final String ESCAPED_SPACE = "%20";
	private static final String PATH_PREPEND = "file://";
	private static final String PATH_WEB_GUIDE = "resrc/doc/guide.html";
	private static final String LOG_MSG_INIT_SUCCESS = "Initialization of UIController successful";
	private static final String LOG_MSG_SEC_STAGE_SHOWN = "Secondary stage is shown.";

	private String urlCssCommon;
	private String urlCssThemeLight;
	private String urlCssThemeDark;
	private String urlCssThemeAqua;
	private String urlWebGuide;
	private URL urlCssThemeCustom;
	private Scene scene;
	private BorderPane root;
	private UIHeader header;
	private UISideMenu sideMenu;
	private UIDayBoxContainer dayBoxContainer;
	private ScrollPane mainView;
	private UICommandBox commandBox;
	private UIMessageBox messageBox;
	private UIHelpBox helpBox;
	private ChangeListener<Number> resizeListener;
	private ChangeListener<Boolean> maximizeListener;
	private LogicController logic;
	private Stage primaryStage;
	private UIMainViewType activeMainView;
	private Stage secondaryStage;
	private WebView webView;
	private Logger logger;
	private static UIController instance = null;
	
	/**
	 * This is the private constructor method for <tt>UIController</tt>.
	 * It is used by the <tt>getInstance</tt> method.
	 * @param primaryStage This is the primary stage of the application.
	 */
	private UIController(Stage primaryStage) {
		this.logic = new LogicController();
		this.primaryStage = primaryStage;
		this.activeMainView = UIMainViewType.TODAY;
		initialize();
	}

	/**
	 * This method is used to create an instance of <tt>UIController</tt> and return it, 
	 * if it has not already been created. 
	 * If an instance of <tt>UIController</tt> already exists, 
	 * no new instance will be created and the existing <tt>UIController</tt> will be returned instead. 
	 * This method is used by the <tt>Main</tt> class.
	 * @param primaryStage This is the primary stage of the application.
	 * @return The <tt>UIController</tt> instance.
	 */
	public static synchronized UIController getInstance(Stage primaryStage) {
		if (instance == null) {
			instance = new UIController(primaryStage);
		}
		return instance;
	}

	/**
	 * This method is used to initialize the <tt>UIController</tt> class.
	 * It is used by the constructor.
	 */
	private void initialize() {
		initLogger();
		initUrls();
		initHeader();
		initSideMenu();
		initMainView();
		initCommandBox();
		initMessageBox();
		initHelpBox();
		initRoot();
		initScene();
		initListeners();
		updatePositions();
		initPopulate();
		this.logger.log(Level.INFO, LOG_MSG_INIT_SUCCESS);
	}
	
	/**
	 * This method is used to initialize the logger.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initLogger() {
		this.logger = Logger.getLogger(getClass().getName());
	}

	/**
	 * This method is used to initialize the file paths of the CSS files and the 
	 * web guide.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initUrls() {
		this.urlCssCommon = loadUrl(UIStyle.URL_CSS_COMMON);
		this.urlCssThemeLight = loadUrl(UIStyle.URL_CSS_THEME_LIGHT);
		this.urlCssThemeDark = loadUrl(UIStyle.URL_CSS_THEME_DARK);
		this.urlCssThemeAqua = loadUrl(UIStyle.URL_CSS_THEME_AQUA);
		this.urlCssThemeCustom = getClass().getResource(UIStyle.URL_CSS_THEME_CUSTOM);
		this.urlWebGuide = loadUrl(PATH_WEB_GUIDE);
		this.logic.setDefaultCustomCss(urlCssThemeCustom);
	}

	/**
	 * This method is used to retrieve the absolute pathname of a file given its relative pathname. 
	 * It is used by the <tt>initialize</tt> method.
	 * @param cssUrl The relative pathname to be resolved.
	 * @return The absolute pathname of <tt>cssUrl</tt>.
	 */
	private String loadUrl(String url) {
		return getClass().getResource(url).toExternalForm();
	}

	/**
	 * This method is used to initialize the UI header. 
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initHeader() {
		this.header = new UIHeader();
	}

	/**
	 * This method is used to initialize the side menu of the UI. 
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initSideMenu() {
		this.sideMenu = new UISideMenu(this);
		setActiveMenuButton(this.activeMainView);
		ChangeListener<Toggle> toggleListener = new ChangeListener<Toggle>() {
			public void changed(ObservableValue<? extends Toggle> ov, Toggle old_toggle, Toggle new_toggle) {
				Toggle toggle = new_toggle;
				if (toggle == null) {
					toggle = old_toggle;
				}
				toggle.setSelected(true);
				String userData = getSideMenuUserData();
				showSelectedSideMenu(userData);
			}
		};
		this.sideMenu.getMainViewToggleGroup().selectedToggleProperty().addListener(toggleListener);
	}

	/**
	 * This method is used to retrieve the user data of the selected menu button. 
	 * It is called by the <tt>initSideMenu</tt> method.
	 * @return The user data of selected menu button.
	 */
	private String getSideMenuUserData() {
		return this.sideMenu.getMainViewToggleGroup().getSelectedToggle().getUserData().toString();
	}

	/**
	 * This method is used to select the menu button which corresponds to <tt>userData</tt> 
	 * and display the relevant view for it.
	 * It is used by the <tt>initSideMenu</tt> method.
	 * @param userData The user data of the selected menu button.
	 */
	private void showSelectedSideMenu(String userData) {
		switch (userData) {
			case UIData.USERDATA_TODAY:
				activeMainView = UIMainViewType.TODAY;
				processInput(UIData.CMD_SHOW_TODAY);
				break;
			case UIData.USERDATA_EXTENDED:
				activeMainView = UIMainViewType.EXTENDED;
				processInput(UIData.CMD_SHOW_EXTENDED);
				break;
			case UIData.USERDATA_FLOAT:
				activeMainView = UIMainViewType.FLOAT;
				processInput(UIData.CMD_SHOW_FLOAT);
				break;
			case UIData.USERDATA_ALL:
				activeMainView = UIMainViewType.ALL;
				processInput(UIData.CMD_SHOW_ALL);
				break;
			case UIData.USERDATA_COMPLETED:
				activeMainView = UIMainViewType.COMPLETED;
				processInput(UIData.CMD_SHOW_COMPLETED);
				break;
			case UIData.USERDATA_CATEGORY:
				activeMainView = UIMainViewType.CATEGORY;
				processInput(UIData.CMD_SHOW_CAT + getSelectedCategoryName());
				break;
			default:
				break;
		}
		mainView.setContent(dayBoxContainer.getView());
	}

	/**
	 * This method is used to initialize the main view.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initMainView() {
		this.dayBoxContainer = new UIDayBoxContainer(this);
		this.mainView = new ScrollPane();
		this.mainView.getStyleClass().add(STYLECLASS_MAIN_VIEW);
		this.mainView.setContent(this.dayBoxContainer.getView());
		this.activeMainView = UIMainViewType.TODAY;
	}

	/**
	 * This method is used to initialize the command box view. 
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initCommandBox() {
		this.commandBox = new UICommandBox();
	}

	/**
	 * This method is used to initialize the message box, 
	 * which is used to pass messages from the application to the user.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initMessageBox() {
		this.messageBox = new UIMessageBox(this.primaryStage);
	}

	/**
	 * This method is used to initialize the help box, 
	 * which is displayed when the user passes a help command.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initHelpBox() {
		this.helpBox = new UIHelpBox();
		this.secondaryStage = new Stage();
		this.webView = new WebView();
		this.webView.getEngine().load(this.urlWebGuide);
		this.secondaryStage.setScene(new Scene(webView));
	}

	/**
	 * This method is used to initialize the root view. 
	 * The root view is the underlying view that contains all the other views. 
	 * Make sure this method is only called after all other views have been initialized.
	 * This method is used by the <tt>initialize</tt> method.
	 */
	private void initRoot() {
		this.root = new BorderPane();
		this.root.setTop(this.header.getView());
		this.root.setLeft(this.sideMenu.getView());
		this.root.setCenter(this.mainView);
		this.root.setBottom(this.commandBox.getView());
	}

	/**
	 * This method is used to initialize the scene of the application.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initScene() {
		this.scene = new Scene(root, WIDTH_SCENE, HEIGHT_SCENE);
		this.scene.getStylesheets().addAll(this.urlCssCommon, this.urlCssThemeLight);
	}

	/**
	 * This method is used to initialize event listeners for the UI.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initListeners() {
		initCommandBoxListeners();
		initSceneListeners();
		initStageListeners();
	}

	/**
	 * This method is used to initialize event listeners for the command box view. 
	 * It is used by the <tt>initListeners</tt> method.
	 */
	private void initCommandBoxListeners() {
		this.commandBox.getCommandTextField().setOnAction((event) -> {
			String commandString = commandBox.getCommandTextField().getText();
			this.commandBox.getCommandTextField().setText(UIData.EMP_STR);
			this.commandBox.updateHistory(commandString);
			processInput(commandString);
		});
		
		this.commandBox.getCommandTextField().setOnKeyPressed(new EventHandler<KeyEvent>() {
	        @Override
	        public void handle(KeyEvent keyEvent) {
	        	processCommandBoxKeyEvent(keyEvent);
	        }
	    });
	}
	
	/**
	 * This method is used to process a <tt>KeyEvent</tt> for the command box view.
	 * It is used by the <tt>initCommandBoxListeners</tt> method.
	 * @param keyEvent The <tt>KeyEvent</tt> that has occurred.
	 */
	private void processCommandBoxKeyEvent(KeyEvent keyEvent) {
		KeyCode key = keyEvent.getCode();
		switch(key) {
			case UP:
				this.commandBox.showPrevHistory();
				break;
			case DOWN:
				this.commandBox.showNextHistory();
				break;
			default:
				break;
		}
	}

	/**
	 * This method is used to initialize the event listeners for the scene of the application.
	 * It is used by the <tt>initListeners</tt> method.
	 */
	private void initSceneListeners() {
		this.resizeListener = new ChangeListener<Number>() {
			@Override
			public void changed(ObservableValue<? extends Number> observableValue, Number oldValue, Number newValue) {
				updateOnResize();
			}
		};

		this.maximizeListener = new ChangeListener<Boolean>() {
			@Override
			public void changed(ObservableValue<? extends Boolean> observableValue, Boolean oldValue, Boolean newValue) {
				updateOnResize();
			}
		};

		this.scene.heightProperty().addListener(this.resizeListener);
		this.scene.widthProperty().addListener(this.resizeListener);
		this.primaryStage.maximizedProperty().addListener(this.maximizeListener);

		this.scene.setOnKeyPressed(new EventHandler<KeyEvent>() {
			public void handle(final KeyEvent keyEvent) {
				processKeyEvent(keyEvent);
			}
		});
	}

	/**
	 * This method is used to dynamically adjust the message box and main view layouts 
	 * when the scene has been resized.
	 * It is used by the <tt>initSceneListeners</tt> method.
	 */
	private void updateOnResize() {
		this.messageBox.updatePosition();
		this.dayBoxContainer.updatePosition(primaryStage.getWidth());
		if (this.helpBox.isShowing()) {
			this.helpBox.updatePosition(primaryStage.getX(), primaryStage.getY(), primaryStage.getWidth(), primaryStage.getHeight());
		}
	}

	/**
	 * This method is used to process a <tt>KeyEvent</tt> for an event listener of the scene.
	 * @param keyEvent The <tt>KeyEvent</tt> which occurred.
	 */
	private void processKeyEvent(final KeyEvent keyEvent) {
		if (keyEvent.isControlDown()) {
			KeyCode key = keyEvent.getCode();
			switch(key){
				case DIGIT1:
					processInput(UIData.CMD_SHOW_TODAY);
					break;
				case DIGIT2:
					processInput(UIData.CMD_SHOW_EXTENDED);
					break;
				case DIGIT3:
					processInput(UIData.CMD_SHOW_FLOAT);
					break;
				case DIGIT4:
					processInput(UIData.CMD_SHOW_ALL);
					break;
				case DIGIT5:
					processInput(UIData.CMD_SHOW_COMPLETED);
					break;
				case U:
				case PAGE_UP:
					scrollUpMainView();
					break;
				case J:
				case PAGE_DOWN:
					scrollDownMainView();
					break;
				default:
					break;
			}
		} else {
			focusOnCommandBox();
		}
		keyEvent.consume();
	}
	
	/**
	 * This method is used to scroll up the main view.
	 * It is used by the <tt>processKeyEvent</tt> method.
	 */
	private void scrollUpMainView() {
		if (this.mainView.getVvalue() > this.mainView.getVmin() + SCROLL_SENSITIVITY){
			this.mainView.setVvalue(this.mainView.getVvalue() - SCROLL_SENSITIVITY);
		}
	}
	
	/**
	 * This method is used to scroll down the main view.
	 * It is used by the <tt>processKeyEvent</tt> method.
	 */
	private void scrollDownMainView() {
		if (this.mainView.getVvalue() < this.mainView.getVmax() + SCROLL_SENSITIVITY){
			this.mainView.setVvalue(this.mainView.getVvalue() + SCROLL_SENSITIVITY);
		}
	}
	
	/**
	 * This method is used to focus on the textfield in the command box.
	 * It is used by the <tt>processKeyEvent</tt> method.
	 */
	private void focusOnCommandBox() {
		if (!this.commandBox.isSelected()) {
			this.commandBox.select();
		}
	}

	/**
	 * This method is used to initialize the event listeners for the stage of the application.
	 * It is used by the <tt>initListeners</tt> method.
	 */
	private void initStageListeners() {
		this.primaryStage.focusedProperty().addListener(new ChangeListener<Boolean>() {
			@Override
			public void changed(ObservableValue<? extends Boolean> observableValue, Boolean oldValue, Boolean newValue) {
				updateMessageBoxOnFocusChange(newValue);
				updateHelpBoxOnFocusChange(newValue);
			}
		});
	}
	
	/**
	 * This method is used to update the visibility of the message box when 
	 * the stage of the application changes focus.
	 * @param obs The <tt>boolean</tt> for the stage's focus attribute.
	 * It is used by the <tt>initStageListeners</tt> method.
	 */
	private void updateMessageBoxOnFocusChange(Boolean obs) {
		if (!obs && this.messageBox.isOn()) {
			this.messageBox.tempHide();
		} else if (obs && this.messageBox.isOn()) {
			this.messageBox.display();
		}
	}
	
	/**
	 * This method is used to update the visibility of the help box when 
	 * the stage of the application changes focus.
	 * @param obs The <tt>boolean</tt> for the stage's focus attribute.
	 * It is used by the <tt>initStageListeners</tt> method.
	 */
	private void updateHelpBoxOnFocusChange(Boolean obs) {
		if (!obs && this.helpBox.isOn()) {
			this.helpBox.tempHide();
		} else if (obs && helpBox.isOn()) {
			this.helpBox.show(primaryStage);
		}
	}

	/**
	 * This method is used to populate the UI at application startup.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initPopulate() {
		refreshCategoryMenuView();
		processInput(UIData.CMD_SHOW_TODAY);
	}

	/**
	 * This method is used to process a user's input string by passing it to the Logic component. 
	 * @param s The user's input string.
	 */
	private void processInput(String s) {
		processLogicAction(logic.processInput(s));
	}
	
	/**
	 * This method is used to get the name of the <tt>Category</tt> whose menu button is selected.
	 * @return The name of the <tt>Category</tt> whose menu button is selected.
	 */
	private String getSelectedCategoryName() {
		return this.sideMenu.getSelectedCategoryName();
	}

	/**
	 * This method is used to process the <tt>LogicAction</tt> that is 
	 * returned by the Logic component's <tt>processInput</tt> method. 
	 * It is used by the <tt>processInput</tt> method.
	 * @param logicAction The <tt>LogicAction</tt> that is returned by Logic component's <tt>processInput</tt> method.
	 */
	private void processLogicAction(LogicAction logicAction) {
		Action action = logicAction.getAction();
		switch (action) {
			case ADD_TODAY_TASK:
			case ADD_ALL_TASK:
				refreshMainViewForTodayOrExtended();
				break;
			case EDIT_TO_TODAY_TASK:
			case SHOW_TODAY_TASK:
				refreshMainViewForToday();
				break;
			case ADD_NEXT7DAY_TASK:
			case EDIT_TO_NEXT7DAY_TASK:
			case SHOW_NEXT7DAY_TASK:
				refreshMainViewForExtended();
				break;
			case ADD_FLOATING_TASK:
			case EDIT_TO_FLOATING_TASK:
			case SHOW_FLOATING_TASK:
				refreshMainViewForFloat();
				break;
			case EDIT_TO_ALL_TASK:
			case SHOW_ALL_TASK:
				refreshMainViewForAll();
				break;
			case SHOW_COMPLETED:
				refreshMainViewForCompleted();
				break;
			case SHOW_CATEGORY:
				refreshMainViewForCategory();
				break;
			case DELETE_CATEGORY:
			case CLEAR_CATEGORY:
			case EDIT_CATEGORY:
			case ADD_N_SET_CATEGORY:
			case UNDO:
			case REDO:
				refreshCategoryMenuView();
			case SET_STORAGE_PATH:
			case DELETE_TASK:
			case SET_CATEGORY:
			case CLEAR_TASK:
			case MARK_TASK:
			case UNMARK_TASK:
			case REMOVE_CAT_FROM_TASK:
			case EDIT_NAME:
				refreshMainViewForActiveViewType();
				break;
			case ADD_CATEGORY:
				refreshCategoryMenuView();
				break;
			case SEARCH:
				refreshMainViewForSearch();
				break;
			case HELP:
				showHelp();
				break;
			case CHANGE_THEME_DEFAULT:
				changeTheme(UITheme.LIGHT);
				break;
			case CHANGE_THEME_DARK:
				changeTheme(UITheme.DARK);
				break;
			case CHANGE_THEME_AQUA:
				changeTheme(UITheme.AQUA);
				break;
			case CHANGE_THEME_CUSTOM:
				changeTheme(UITheme.CUSTOM);
				break;
			case ERROR:
				displayMessage(logicAction.getMessage(), UIMessageType.ERROR);
				break;
			default:
				break;
		}

		if (hasNonErrorMessage(logicAction)) {
			displayMessage(logicAction.getMessage(), UIMessageType.DEFAULT);
		}
	}
	
	/**
	 * This method is used to refresh the main view for today.
	 * It is used by the <tt>processLogicAction</tt> method.
	 */
	private void refreshMainViewForToday() {
		refreshMainView(this.logic.getTaskGroupsToday(), UIMainViewType.TODAY);
	}
	
	/**
	 * This method is used to refresh the main view for next 7 days.
	 * It is used by the <tt>processLogicAction</tt> method.
	 */
	private void refreshMainViewForExtended() {
		refreshMainView(this.logic.getTaskGroupsNext7Days(), UIMainViewType.EXTENDED);
	}
	
	/**
	 * This method is used to refresh the main view for float.
	 * It is used by the <tt>processLogicAction</tt> method.
	 */
	private void refreshMainViewForFloat() {
		refreshMainView(this.logic.getTaskGroupsFloating(), UIMainViewType.FLOAT);
	}
	
	/**
	 * This method is used to refresh the main view for all.
	 * It is used by the <tt>processLogicAction</tt> method.
	 */
	private void refreshMainViewForAll() {
		refreshMainView(this.logic.getTaskGroupsAll(), UIMainViewType.ALL);
	}
	
	/**
	 * This method is used to refresh the main view for completed.
	 * It is used by the <tt>processLogicAction</tt> method.
	 */
	private void refreshMainViewForCompleted() {
		refreshMainView(this.logic.getTaskGroupsCompleted(), UIMainViewType.COMPLETED);
	}
	
	/**
	 * This method is used to refresh the main view for the selected category.
	 * It is used by the <tt>processLogicAction</tt> method.
	 */
	private void refreshMainViewForCategory() {
		refreshMainView(this.logic.getTaskGroupCategory(), this.logic.getSelectedCategory());
		setActiveCategoryButton(this.logic.getSelectedCategory());
	}
	
	/**
	 * This method is used to refresh the main view for search.
	 * It is used by the <tt>processLogicAction</tt> method.
	 */
	private void refreshMainViewForSearch() {
		refreshMainView(this.logic.getSearchTaskGroup(), UIMainViewType.SEARCH);
	}
	
	/**
	 * This method is used to refresh the main view for either today or next 7 days, 
	 * depending on the currently active <tt>UIMainViewType</tt> of the UI.
	 * It is used by the <tt>processLogicAction</tt> method.
	 */
	private void refreshMainViewForTodayOrExtended() {
		if (this.activeMainView == UIMainViewType.TODAY) {
			refreshMainViewForToday();
		} else if (this.activeMainView == UIMainViewType.EXTENDED) {
			refreshMainViewForExtended();
		}
	}
	
	/**
	 * This method is used to refresh the main view for the currently active <tt>UIMainViewType</tt> 
	 * of the UI.
	 * It is used by the <tt>processLogicAction</tt> method.
	 */
	private void refreshMainViewForActiveViewType() {
		switch(this.activeMainView) {
			case TODAY:
				refreshMainViewForToday();
				break;
			case EXTENDED:
				refreshMainViewForExtended();
				break;
			case FLOAT:
				refreshMainViewForFloat();
				break;
			case ALL:
				refreshMainViewForAll();
				break;
			case COMPLETED:
				refreshMainViewForCompleted();
				break;
			case CATEGORY:
				refreshMainViewForCategory();
				break;
			default:
				break;
		}
	}
	
	/**
	 * This method is used to check that an <tt>LogicAction</tt> has an non-error message.
	 * It is used by the <tt>processLogicAction</tt> method.
	 * @param logicAction The <tt>LogicAction</tt> to be checked.
	 * @return <tt>True</tt> if <tt>logicAction</tt> has an non-error message, <tt>False</tt> otherwise.
	 */
	private boolean hasNonErrorMessage(LogicAction logicAction) {
		return logicAction.hasMessage() && logicAction.getAction() != Action.ERROR;
	}

	/**
	 * This method is used to update the layout of the main view.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void updatePositions() {
		this.dayBoxContainer.updatePosition(this.primaryStage.getWidth());
	}

	/**
	 * This method is used to populate the message box with a message and display it to the user.
	 * It is used by the <tt>processLogicAction</tt> method.
	 * @param msg The message to be displayed.
	 * @param msgType The <tt>UIMessageType</tt> of the message to be displayed.
	 */
	private void displayMessage(String msg, UIMessageType msgType) {
		this.messageBox.show(msg, msgType);
		this.messageBox.hide();
	}

	/**
	 * This method is used to change the application skin.
	 * It is used by the <tt>processLogicAction</tt> method.
	 * @param theme The <tt>UITheme</tt> to change the application skin into.
	 */
	private void changeTheme(UITheme theme) {
		this.scene.getStylesheets().clear();
		this.scene.getStylesheets().add(urlCssCommon);
		switch (theme) {
			case DARK:
				this.scene.getStylesheets().addAll(urlCssThemeDark);
				break;
			case AQUA:
				this.scene.getStylesheets().addAll(urlCssThemeAqua);
				break;
			case CUSTOM:
				this.scene.getStylesheets().addAll(getCustomCssPath());
				break;
			default:
				this.scene.getStylesheets().addAll(urlCssThemeLight);
				break;
		}
	}
	
	/**
	 * This method is used to get the absolute pathname for the custom CSS file.
	 * It is used by the <tt>changeTheme</tt> method.
	 * @return The absolute pathname for the custom CSS file.
	 */
	private String getCustomCssPath() {
		return PATH_PREPEND + this.logic.getCssPath().replace(SPACE, ESCAPED_SPACE);
	}

	/**
	 * This method is used to select a menu button.
	 * It is used by the <tt>refreshMainView</tt> methods.
	 * @param mainViewType The <tt>UIMainViewType</tt> of the menu button to be selected.
	 */
	private void setActiveMenuButton(UIMainViewType mainViewType) {
		switch (mainViewType) {
			case TODAY:
				this.sideMenu.getTodayBtn().setSelected(true);
				break;
			case EXTENDED:
				this.sideMenu.getExtendedBtn().setSelected(true);
				break;
			case FLOAT:
				this.sideMenu.getFloatBtn().setSelected(true);
				break;
			case ALL:
				this.sideMenu.getAllBtn().setSelected(true);
				break;
			case COMPLETED:
				this.sideMenu.getCompletedBtn().setSelected(true);
				break;
			case SEARCH:
				break;
			default:
				break;
		}
	}
	
	/**
	 * This method is used to select a category menu button.
	 * It is used by the <tt>processLogicAction</tt> method.
	 * @param category The <tt>Category</tt> whose menu button is to be selected.
	 */
	private void setActiveCategoryButton(Category category) {
		this.sideMenu.setActiveCategoryButton(category);
	}

	/**
	 * This method is used to update the main view of the UI.
	 * It is used by the <tt>processLogicAction</tt> method.
	 * @param taskGroupList The <tt>ArrayList</tt> of <tt>TaskGroup</tt> objects 
	 * to populate the main view with.
	 */
	private void refreshMainView(ArrayList<TaskGroup> taskGroupList) {
		this.dayBoxContainer.refresh(taskGroupList);
		this.mainView.setContent(this.dayBoxContainer.getView());
	}

	/**
	 * This method is used to update the main view and selected menu button of the UI.
	 * It is used by the <tt>processLogicAction</tt> method. 
	 * @param taskGroupList The <tt>ArrayList</tt> of <tt>TaskGroup</tt> objects 
	 * to populate the main view with.
	 * @param mainViewType The <tt>UIMainViewType</tt> of the menu button to be selected.
	 */
	private void refreshMainView(ArrayList<TaskGroup> taskGroupList, UIMainViewType mainViewType) {
		this.activeMainView = mainViewType;
		setActiveMenuButton(mainViewType);
		refreshMainView(taskGroupList);
	}

	/**
	 * This method is used to update the main view and selected category menu button of the UI.
	 * It is used by the <tt>processLogicAction</tt> method. 
	 * @param taskGroupList The <tt>ArrayList</tt> of <tt>TaskGroup</tt> objects 
	 * to populate the main view with.
	 * @param category The <tt>Category</tt> whose menu button is to be selected.
	 */
	private void refreshMainView(ArrayList<TaskGroup> taskGroupList, Category category) {
		this.activeMainView = UIMainViewType.CATEGORY;
		refreshMainView(taskGroupList);
	}

	/**
	 * This method is used to update the category menu buttons.
	 * It is used by <tt>initPopulate</tt> and <tt>processLogicAction</tt> methods.
	 */
	private void refreshCategoryMenuView() {
		this.sideMenu.refreshCategoryMenuView(this.logic.getAllCategories());
	}

	/**
	 * This method is used to display the help box.
	 * It is used by the <tt>processLogicAction</tt> method.
	 */
	private void showHelp() {
		this.secondaryStage.show();
		this.logger.log(Level.INFO, LOG_MSG_SEC_STAGE_SHOWN);
	}

	/**
	 * This method is used to retrieve the primary stage of the application scene.
	 * @return The primary stage of the application scene.
	 */
	protected Stage getStage() {
		return this.primaryStage;
	}

	/**
	 * This method is used to retrieve the width of the primary stage of the application scene.
	 * @return The width of the primary stage of the application scene.
	 */
	protected double getStageWidth() {
		return this.primaryStage.getWidth();
	}

	/**
	 * This method is used to mark a <tt>Task</tt> as completed.
	 * @param taskId The displayed id of the <tt>Task</tt> to be marked.
	 */
	protected void markTask(int taskId) {
		processInput(UIData.CMD_MARK + Integer.toString(taskId));
	}
	
	/**
	 * This method is used to unmark a previously marked <tt>Task</tt>.
	 * @param taskId The displayed id of the <tt>Task</tt> to be unmarked.
	 */
	protected void unmarkTask(int taskId) {
		processInput(UIData.CMD_UNMARK + Integer.toString(taskId));
	}

	/**
	 * This method is used to process a command string.
	 * @param cmd The command string to be processed.
	 */
	protected void processCommand(String cmd) {
		processInput(cmd);
	}
	
	/**
	 * This method is used to retrieve the currently active <tt>UIMainViewType</tt> of the UI.
	 * @return The currently active <tt>UIMainViewType</tt> of the UI.
	 */
	public UIMainViewType getActiveViewType() {
		return this.activeMainView;
	}
	
	/**
	 * This method is used to retrieve the scene of the application.
	 * @return The scene of the application.
	 */
	protected Scene getScene() {
		return this.scene;
	}
}
```
###### src\dooyit\ui\UIData.java
``` java
package dooyit.ui;

/**
 * The <tt>UIData</tt> class defines several constants which 
 * are commonly used by classes in <tt>dooyit.ui</tt>.
 * @author 	Wu Wenqi
 * @version	0.5
 * @since 	2016-04-10
 */

public class UIData {
	protected static final String USERDATA_TODAY = "day";
	protected static final String USERDATA_EXTENDED = "extended";
	protected static final String USERDATA_FLOAT = "float";
	protected static final String USERDATA_ALL = "all";
	protected static final String USERDATA_COMPLETED = "completed";
	protected static final String USERDATA_CATEGORY = "category";
	protected static final String CMD_SHOW_TODAY = "show today";
	protected static final String CMD_SHOW_EXTENDED = "show next7";
	protected static final String CMD_SHOW_FLOAT = "show float";
	protected static final String CMD_SHOW_ALL = "show all";
	protected static final String CMD_SHOW_COMPLETED = "show completed";
	protected static final String CMD_SHOW_CAT = "showcat ";
	protected static final String CMD_SHOW = "show ";
	protected static final String CMD_MARK = "mark ";
	protected static final String CMD_UNMARK = "unmark ";
	protected static final String EMP_STR = "";
	protected static final String COMMA_SPLIT = ", ";
	protected static final String TODAY = "Today";
}
```
###### src\dooyit\ui\UIDayBox.java
``` java
package dooyit.ui;

import java.util.ArrayList;
import dooyit.common.datatype.Task;
import dooyit.common.datatype.TaskGroup;
import javafx.scene.control.Label;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.VBox;

/**
 * The <tt>UIDayBox</tt> class contains all the <tt>UITaskBox</tt> objects whose <tt>Task</tt> 
 * belongs to a single day or <tt>Task</tt> type.
 * @author 	Wu Wenqi
 * @version	0.5
 * @since 	2016-04-10
 */

public class UIDayBox {
	private static final String STYLECLASS_DAY_BOX = UIStyle.DAY_BOX;
	private static final String STYLECLASS_DAY_TITLE = UIStyle.DAY_TITLE;
	private static final String STYLECLASS_DAY_TITLE_FADED = UIStyle.DAY_TITLE_FADED;
	private static final String MSG_TODAY_NO_TASKS = "No tasks for today. Enjoy your day!";

	private UIDayBoxContainer parent;
	private VBox dayBox;
	private Label dayTitle;
	private ArrayList<Task> taskList;
	private ArrayList<UITaskBox> taskBoxList;
	private TaskGroup taskGroup;
	
	/**
	 * This is the constructor method for <tt>UIDayBox</tt> class.
	 * @param parent The parent <tt>UIDayBoxContainer</tt> class.
	 * @param taskGroup The <tt>TaskGroup</tt> to be associated with.
	 */
	protected UIDayBox(UIDayBoxContainer parent, TaskGroup taskGroup) {
		this.parent = parent;
		this.taskGroup = taskGroup;
		initialize();
	}
	
	/**
	 * This method is used to initialize <tt>UIDayBox</tt>.
	 * It is used by the constructor.
	 */
	private void initialize() {
		this.taskList = this.taskGroup.getTasks();
		this.taskBoxList = new ArrayList<UITaskBox>();
		initDayBox();
		initAllTasks();
	}
	
	/**
	 * This method is used to initialize the view box.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initDayBox() {
		initDayTitle();
		this.dayBox = new VBox();
		this.dayBox.getStyleClass().add(STYLECLASS_DAY_BOX);
		this.dayBox.getChildren().add(this.dayTitle);
	}
	
	/**
	 * This method is used to initialize the title of the view box.
	 * It is used by the <tt>initDayTitle</tt> method.
	 */
	private void initDayTitle() {
		this.dayTitle = new Label(this.taskGroup.getTitle());
		this.dayTitle.getStyleClass().add(STYLECLASS_DAY_TITLE);
		if (isEmptyAndNotToday()) {
			this.dayTitle.getStyleClass().add(STYLECLASS_DAY_TITLE_FADED);
		}
	}
	
	/**
	 * This method is used to check if the <tt>TaskGroup</tt> is not today's and is empty.
	 * It is used by the <tt>initDayTitle</tt> method.
	 * @return <tt>True</tt> if the <tt>TaskGroup</tt> is not today's and is empty, <tt>False</tt> otherwise.
	 */
	private boolean isEmptyAndNotToday() {
		return taskList.size() == 0 && !isTodayTaskGroup();
	}
	
	/**
	 * This method is used to check that the <tt>TaskGroup</tt> is today's.
	 * It is used by the <tt>isEmptyAndNotToday</tt> method.
	 * @return <tt>True</tt> if the <tt>TaskGroup</tt> is today's.
	 */
	private boolean isTodayTaskGroup() {
		return this.taskGroup.getTitle().contains(UIData.TODAY);
	}
	
	/**
	 * This method is used to initialize all <tt>Task</tt> objects in the <tt>TaskGroup</tt>.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initAllTasks() {
		if (taskList.size() > 0) {
			addAllTasks();
		} else {
			displayNoTasks();
		}
	}
	
	/**
	 * This method is used to add all <tt>Task</tt> objects from the <tt>TaskGroup</tt>.
	 * It is used by the <tt>initAllTasks</tt> method.
	 */
	private void addAllTasks() {
		for (Task task : this.taskList) {
			addTask(task);
		}
	}
	
	/**
	 * This method is used to display in the view box a message 
	 * which says that the user does not have any tasks for today.
	 * It is used by the <tt>initAllTasks</tt> method.
	 */
	private void displayNoTasks() {
		if (isTodayTaskGroup()) {
			setNoTaskMessage();
		}
	}
	
	/**
	 * This method is used to create a <tt>UITaskBox</tt> for a <tt>Task</tt> and add its 
	 * view to the view box.
	 * @param task The <tt>Task</tt> to create a <tt>UITaskBox</tt> for.
	 */
	private void addTask(Task task) {
		UITaskBox taskBox = new UITaskBox(this, task);
		this.taskBoxList.add(taskBox);
		AnchorPane taskBoxView = taskBox.getView();
		this.dayBox.getChildren().add(taskBoxView);
	}
	
	/**
	 * This method is used to create a label informing the user that he has not tasks for today, 
	 * and add it to the view box.
	 * It is used by the <tt>initAllTasks</tt> method.
	 */
	private void setNoTaskMessage() {
		Label taskMessageView = new UITaskMessage(MSG_TODAY_NO_TASKS).getView();
		this.dayBox.getChildren().add(taskMessageView);
	}
	
	/**
	 * This method is used to get the currently active <tt>UIMainViewType</tt> of the UI.
	 * @return The currently active <tt>UIMainViewType</tt> of the UI.
	 */
	protected UIMainViewType getActiveMainView() {
		return this.parent.getActiveMainView();
	}

	/**
	 * This method is used to get the stage width of the application scene.
	 * @return The stage width of the application scene.
	 */
	protected double getStageWidth() {
		return this.parent.getStageWidth();
	}

	/**
	 * This method is used to mark a <tt>Task</tt> as completed.
	 * @param taskId The displayed id of the <tt>Task</tt> to be marked as completed.
	 */
	protected void markTask(int taskId) {
		this.parent.markTask(taskId);
	}
	
	/**
	 * This method is used to unmark a previously marked <tt>Task</tt>.
	 * @param taskId The displayed id of the <tt>Task</tt> to be unmarked.
	 */
	protected void unmarkTask(int taskId) {
		this.parent.unmarkTask(taskId);
	}
	
	/**
	 * This method is used to retrieve the view box.
	 * @return The view box.
	 */
	protected VBox getView() {
		return this.dayBox;
	}

	/**
	 * This method is used to adjust the layouts of views contained within the view box.
	 * @param stageWidth The stage width of the application scene.
	 */
	protected void updatePosition(double stageWidth) {
		this.taskBoxList.forEach((taskBox) -> {
			taskBox.updatePosition(stageWidth);
		});
	}
}
```
###### src\dooyit\ui\UIDayBoxContainer.java
``` java
package dooyit.ui;

import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import dooyit.common.datatype.TaskGroup;
import javafx.scene.layout.VBox;

/**
 * The <tt>UIDayBoxContainer</tt> class contains the methods to initialize <tt>UIDayBox</tt> 
 * and update their views.
 * @author 	Wu Wenqi
 * @version	0.5
 * @since 	2016-04-10
 */

public class UIDayBoxContainer {
	private static final String LOG_MSG_REFRESH_SUCCESS = "Refresh of UIDayBoxContainer successful.";
	
	private UIController parent;
	private ArrayList<UIDayBox> dayBoxList;
	private VBox dayBoxContainer;
	private Logger logger;
	
	/**
	 * This is the constructor method for <tt>UIDayBoxContainer</tt> class.
	 * @param parent The parent <tt>UIController</tt> class.
	 */
	protected UIDayBoxContainer(UIController parent) {
		initLogger();
		this.parent = parent;
		this.dayBoxContainer = new VBox();
		this.dayBoxList = new ArrayList<UIDayBox>();
	}
	
	/**
	 * This method is used to initialize the logger.
	 * It is used by the constructor.
	 */
	private void initLogger() {
		this.logger = Logger.getLogger(getClass().getName());
	}
	
	/**
	 * This method is used to create a <tt>UIDayBox</tt> and add its view to the view box.
	 * @param taskGroup The <tt>TaskGroup</tt> to be associated with <tt>UIDayBox</tt>.
	 */
	private void addDayBox(TaskGroup taskGroup) {
		UIDayBox dayBox = new UIDayBox(this, taskGroup);
		this.dayBoxList.add(dayBox);
		this.dayBoxContainer.getChildren().add(dayBox.getView());
	}
	
	/**
	 * This method is used to update the view box content.
	 * @param taskGroupList The list of <tt>TaskGroup</tt> objects to create <tt>UIDayBox</tt> for.
	 */
	protected void refresh(ArrayList<TaskGroup> taskGroupList) {
		this.dayBoxContainer.getChildren().clear();
		taskGroupList.forEach((taskGroup) -> {
			addDayBox(taskGroup);
		});
		this.logger.log(Level.INFO, LOG_MSG_REFRESH_SUCCESS);
	}

	/**
	 * This method is used to get the stage width of the application scene.
	 * @return The stage width of the application scene.
	 */
	protected double getStageWidth() {
		return this.parent.getStageWidth();
	}

	/**
	 * This method is used to mark a <tt>Task</tt> as completed.
	 * @param taskId The displayed id of the <tt>Task</tt> to be marked as completed.
	 */
	protected void markTask(int taskId) {
		this.parent.markTask(taskId);
	}
	
	/**
	 * This method is used to unmarked a previously marked <tt>Task</tt>
	 * @param taskId The displayed id of the <tt>Task</tt> to be unmarked.
	 */
	protected void unmarkTask(int taskId) {
		this.parent.unmarkTask(taskId);
	}
	
	/**
	 * This method is used to retrieve the currently active <tt>UIMainViewType</tt> of the UI.
	 * @return The currently active <tt>UIMainViewType</tt> of the UI.
	 */
	protected UIMainViewType getActiveMainView() {
		return this.parent.getActiveViewType();
	}
	
	/**
	 * This method is used to retrieve the view box.
	 * @return The view box.
	 */
	protected VBox getView() {
		return this.dayBoxContainer;
	}

	/** 
	 * This method is used to update the views of all <tt>UIDayBox</tt> objects.
	 * @param stageWidth The stage width of the application scene.
	 */
	protected void updatePosition(double stageWidth) {
		this.dayBoxList.forEach((dayBox) -> {
			dayBox.updatePosition(stageWidth);
		});
	}
}
```
###### src\dooyit\ui\UIHeader.java
``` java
package dooyit.ui;

import java.util.logging.Level;
import java.util.logging.Logger;
import javafx.geometry.Pos;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import javafx.scene.text.Font;

/**
 * The <tt>UIHeader</tt> class contains methods to initialize the header view of the UI.
 * @author 	Wu Wenqi
 * @version	0.5
 * @since 	2016-04-10
 */

public class UIHeader {
	private static final String LOG_MSG_CUSTOM_FONT_SUCCESS = "Loading of custom font for UIHeader successful";
	private static final String LOG_MSG_CUSTOM_FONT_FAIL = "Loading of custom font for UIHeader failed. Fallback to Helvetica.";
	private static final String STYLECLASS_HEADER = UIStyle.HEADER_VIEW;
	private static final String LABEL_TITLE = "DOOYIT";
	private static final String STYLECLASS_TITLE = UIStyle.HEADER_TITLE;
	private static final String PATH_FONT_AVENIR_MEDIUM = "fonts/Avenir-Medium.ttf";
	private static final Font HELVETICA_L = Font.font("Helvetica", 19);
	private static final int FONTSIZE_TITLE = 19;

	private Font customFont;
	private HBox header;
	private Label title;
	private Logger logger;
	
	/**
	 * This is the constructor method.
	 */
	public UIHeader() {
		initialize();
	}
	
	/**
	 * This method is used to initialize <tt>UIHeader</tt> class.
	 * It is used by the constructor.
	 */
	private void initialize() {
		initLogger();
		initTitle();
		initHeader();
	}
	
	/**
	 * This method is used to initialize the logger.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initLogger() {
		this.logger = Logger.getLogger(getClass().getName());
	}
	
	/**
	 * This method is used to initialize the header title.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initTitle() {
		this.title = new Label(LABEL_TITLE);
		try {
			initTitleFont();
			this.logger.log(Level.INFO, LOG_MSG_CUSTOM_FONT_SUCCESS);
		} catch (Exception e) {
			this.title.setFont(HELVETICA_L);
			this.logger.log(Level.INFO, LOG_MSG_CUSTOM_FONT_FAIL);
		}
		this.title.getStyleClass().add(STYLECLASS_TITLE);
	}
	
	/**
	 * This method is used to initialize the custom header font.
	 * It is used by the <tt>initTitle</tt> method.
	 * @throws Exception if custom font could not be initialized.
	 */
	private void initTitleFont() throws Exception {
		this.customFont = Font.loadFont(getClass().getResourceAsStream(PATH_FONT_AVENIR_MEDIUM), FONTSIZE_TITLE);
		this.title.setFont(this.customFont);
	}
	
	/**
	 * This method is used to initialize the header view box. 
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initHeader() {
		this.header = new HBox();
		this.header.getStyleClass().add(STYLECLASS_HEADER);
		this.header.getChildren().addAll(this.title);
		this.header.setAlignment(Pos.CENTER);
	}

	/**
	 * This method is used to retrieve the header view box.
	 * @return The header view box.
	 */
	protected HBox getView() {
		return this.header;
	}
}
```
###### src\dooyit\ui\UIHelpBox.java
``` java
package dooyit.ui;

import java.util.ArrayList;
import javafx.event.EventHandler;
import javafx.geometry.Pos;
import javafx.scene.control.Label;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.stage.Popup;
import javafx.stage.Stage;

/**
 * The <tt>UIHelpBox</tt> class contains the methods to initialize the help box, 
 * control its visibility and set the message to be displayed.
 * @author 	Wu Wenqi
 * @version	0.5
 * @since 	2016-04-10
 */

public class UIHelpBox {
	private static final int WIDTH = 640;
	private static final int HEIGHT = 480;
	private static final String STYLECLASS_TITLE = UIStyle.HELP_BOX_TITLE;
	private static final String LABEL_TITLE = "Hola! Here are some tips to get you started.";
	private static final int LABEL_HEIGHT = 20;
	private static final String STYLECLASS_CONTENT_LABEL = UIStyle.HELP_BOX_CONTENT_LABEL;
	private static final int SPACING_CONTENT_WRAPPER = 80;
	private static final int SPACING_CONTENT = 10;
	private static final String STYLECLASS_HELP_BOX_WRAPPER = UIStyle.HELP_BOX_WRAPPER;
	private static final int SPACING_HELP_BOX_WRAPPER = 40;
	private static final String STYLECLASS_CLOSE_LABEL = "help-box-close-label";
	private static final String CLOSE_LABEL_TITLE = "CLOSE";
	private static final String DESC_ADD = "add: create a task or event";
	private static final String DESC_ADDCAT = "addcat: create a category";
	private static final String DESC_CLEAR = "clear: delete ALL tasks";
	private static final String DESC_DELETE = "delete: delete a task";
	private static final String DESC_DELETECAT = "deletecat: delete a category";
	private static final String DESC_EDIT = "edit: edit details of a task";
	private static final String DESC_EDITCAT = "editcat: edit details of a category";
	private static final String DESC_EXIT = "exit: quit the application";
	private static final String DESC_FLOAT = "float: make a task floating";
	private static final String DESC_MARK = "mark: mark a task as done";
	private static final String DESC_MOVE = "move: move a task to a category";
	private static final String DESC_REDO = "redo: redo an undone command";
	private static final String DESC_REMOVE = "remove: take a task out of a category";
	private static final String DESC_SHOW = "show: switch between views";
	private static final String DESC_SHOWCAT = "showcat: switch to a category view";
	private static final String DESC_SEARCH = "search: search for tasks and events";
	private static final String DESC_SKIN = "skin: change application skin";
	private static final String DESC_STORAGE = "storage: specify storage directory";
	private static final String DESC_UNMARK = "unmark: unmark a completed task";
	private static final String DESC_UNDO = "undo: undo the previous command";

	private Popup helpBox;
	private VBox helpBoxWrapper;
	private Label title;
	private boolean isOn;
	private HBox contentWrapper;
	private VBox leftContent;
	private VBox rightContent;
	private Label closeLabel;
	
	private static final ArrayList<String> cmdListLeft = new ArrayList<String>() {
		private static final long serialVersionUID = 1L;
		{
			add(DESC_ADD);
			add(DESC_ADDCAT);
			add(DESC_CLEAR);
			add(DESC_DELETE);
			add(DESC_DELETECAT);
			add(DESC_EDIT);
			add(DESC_EDITCAT);
			add(DESC_EXIT);
			add(DESC_FLOAT);
			add(DESC_MARK);
		}
	};
	
	private static final ArrayList<String> cmdListRight = new ArrayList<String>() {
		private static final long serialVersionUID = 1L;
		{
			add(DESC_MOVE);
			add(DESC_REDO);
			add(DESC_REMOVE);
			add(DESC_SHOW);
			add(DESC_SHOWCAT);
			add(DESC_SEARCH);
			add(DESC_SKIN);
			add(DESC_STORAGE);
			add(DESC_UNMARK);
			add(DESC_UNDO);
		}
	};

	/**
	 * This is the constructor method.
	 */
	protected UIHelpBox() {
		initialize();
	}
	
	/**
	 * This method is used to initialize <tt>UIHelpBox</tt> class.
	 * It is used by the constructor.
	 */
	private void initialize() {
		this.isOn = false;
		initTitle();
		initLeftContent();
		initRightContent();
		initContentWrapper();
		initCloseLabel();
		initHelpBox();
	}
	
	/**
	 * This method is used to initialize the help box's title.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initTitle() {
		this.title = new Label(LABEL_TITLE);
		this.title.setAlignment(Pos.CENTER);
		this.title.getStyleClass().add(STYLECLASS_TITLE);
	}
	
	/**
	 * This method is used to initialize the left-sided content of the help box.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initLeftContent() {
		this.leftContent = new VBox();
		this.leftContent.setSpacing(SPACING_CONTENT);
		cmdListLeft.forEach((cmdName) -> {
			Label cmdNameLabel = makeLabel(cmdName);
			this.leftContent.getChildren().add(cmdNameLabel);
		});
	}
	
	/**
	 * This method is used to initialize the right-sided content of the help box.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initRightContent() {
		this.rightContent = new VBox();
		this.rightContent.setSpacing(SPACING_CONTENT);
		cmdListRight.forEach((cmdDesc) -> {
			Label cmdDescLabel = makeLabel(cmdDesc);
			this.rightContent.getChildren().add(cmdDescLabel);
		});
	}
	
	/**
	 * This method is used to initialize the content wrapper. 
	 * It can only be called after the left- and right-sided content views have been initialized.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initContentWrapper() {
		this.contentWrapper = new HBox();
		this.contentWrapper.setSpacing(SPACING_CONTENT_WRAPPER);
		this.contentWrapper.getChildren().addAll(this.leftContent, this.rightContent);
	}
	
	/**
	 * This method is used to initialize the close button.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initCloseLabel() {
		this.closeLabel = new Label(CLOSE_LABEL_TITLE);
		this.closeLabel.getStyleClass().add(STYLECLASS_CLOSE_LABEL);
		this.closeLabel.addEventHandler(MouseEvent.MOUSE_CLICKED, new EventHandler<MouseEvent>() {
			@Override
			public void handle(MouseEvent event) {
				hide();
				event.consume();
			}
		});
	}
	
	/**
	 * This method is used to initialize the help box view.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initHelpBox() {
		this.helpBoxWrapper = new VBox();
		this.helpBoxWrapper.setSpacing(SPACING_HELP_BOX_WRAPPER);
		this.helpBoxWrapper.setAlignment(Pos.CENTER);
		this.helpBoxWrapper.getChildren().addAll(this.title, this.contentWrapper, this.closeLabel);
		this.helpBoxWrapper.getStyleClass().add(STYLECLASS_HELP_BOX_WRAPPER);
		this.helpBox = new Popup();
		this.helpBox.getContent().addAll(this.helpBoxWrapper);
	}
	
	/**
	 * This method is used to create and return a label that is to be displayed on 
	 * the left- and right-sided content views.
	 * @param s The text to set for the label.
	 * @return A label with <tt>s</tt> as its text.
	 */
	private Label makeLabel(String s) {
		Label label = new Label(s);
		label.getStyleClass().add(STYLECLASS_CONTENT_LABEL);
		label.setMaxHeight(LABEL_HEIGHT);
		label.setPrefHeight(LABEL_HEIGHT);
		label.setMinHeight(LABEL_HEIGHT);
		return label;
	}

	/**
	 * This method is used to check if the help box is visible.
	 * @return <tt>True</tt> if help box is visible, <tt>False</tt> otherwise.
	 */
	protected boolean isShowing() {
		return this.helpBox.isShowing();
	}

	/**
	 * This method is used to update the position of the help box.
	 * @param stageX The x-coordinate of the stage of the application scene.
	 * @param stageY The y-coordinate of the stage of the application scene.
	 * @param stageWidth The stage width of the application scene.
	 * @param stageHeight The stage height of the application scene.
	 */
	protected void updatePosition(double stageX, double stageY, double stageWidth, double stageHeight) {
		this.helpBox.setX(stageX + stageWidth / 2 - WIDTH / 2);
		this.helpBox.setY(stageY + stageHeight / 2 - HEIGHT / 2);
		this.helpBoxWrapper.setPrefSize(WIDTH, HEIGHT);
	}

	/**
	 * This method is used to show the help box.
	 * @param primaryStage The stage to show the help box in.
	 */
	protected void show(Stage primaryStage) {
		this.isOn = true;
		this.helpBoxWrapper.setPrefSize(WIDTH, HEIGHT);
		this.helpBox.setX(primaryStage.getX() + primaryStage.getWidth() / 2 - WIDTH / 2);
		this.helpBox.setY(primaryStage.getY() + primaryStage.getHeight() / 2 - HEIGHT / 2);
		this.helpBox.show(primaryStage);
	}
	
	/**
	 * This method is used to temporarily hide the help box.
	 */
	protected void tempHide() {
		this.helpBox.hide();
	}

	/**
	 * This method is used to hide the help box.
	 */
	protected void hide() {
		this.isOn = false;
		this.helpBox.hide();
	}
	
	/**
	 * This method is used to retrieve the visibility attribute of the help box.
	 * @return <tt>True</tt> if help box should be visible to user, <tt>False</tt> otherwise.
	 */
	protected boolean isOn() {
		return this.isOn;
	}
}
```
###### src\dooyit\ui\UIMainViewType.java
``` java
package dooyit.ui;

/**
 * The <tt>UIMainViewtype</tt> class contains the enumerated types of the UI's main view.
 * @author 	Wu Wenqi
 * @version	0.5
 * @since 	2016-04-10
 */

public enum UIMainViewType {
	TODAY, EXTENDED, FLOAT, ALL, COMPLETED, CATEGORY, SEARCH
}
```
###### src\dooyit\ui\UIMessageBox.java
``` java
package dooyit.ui;

import dooyit.common.utils.OsUtils;
import javafx.animation.FadeTransition;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.control.Label;
import javafx.stage.Popup;
import javafx.stage.Stage;
import javafx.util.Duration;

/**
 * The <tt>UIMessageBox</tt> class contains the methods to initialize the message box, 
 * control its visibility and set its displayed message.
 * @author 	Wu Wenqi
 * @version	0.5
 * @since 	2016-04-10
 */

public class UIMessageBox {
	private static final String STYLECLASS_MESSAGE_BOX_LABEL = UIStyle.MESSAGE_BOX_LABEL;
	private static final String STYLECLASS_MESSAGE_BOX_LABEL_ERROR = UIStyle.MESSAGE_BOX_LABEL_ERROR;
	private static final int FADE_TIME = 6000;
	private static final int FADE_TIME_LONG = 11000;
	private static final int CHAR_LEN_LONG = 40;
	private static final int PREFHEIGHT = 41;
	private static final int PAD_X = 8;
	private static final int PAD_Y = 105;
	private static final double FT_INITIAL_VAL = 1.0;
	private static final double FT_FINAL_VAL = 0.0;
	private static final int FT_CYCLE_COUNT = 1;

	private Stage primaryStage;
	private Popup messageBox;
	private Label messageLabel;
	private boolean isOn;
	private FadeTransition ft;

	/**
	 * This is the constructor method.
	 * @param primaryStage The stage of the application scene.
	 */
	protected UIMessageBox(Stage primaryStage) {
		this.primaryStage = primaryStage;
		initialize();
	}
	
	/**
	 * This method is used to initialize <tt>UIMessageBox</tt> class.
	 * It is used by the constructor.
	 */
	private void initialize() {
		initMessageLabel();
		initMessageBox();
		initTransitions();
	}
	
	/**
	 * This method is used to initialize the message label.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initMessageLabel() {
		this.messageLabel = new Label();
		this.messageLabel.getStyleClass().add(STYLECLASS_MESSAGE_BOX_LABEL);
	}
	
	/**
	 * This method is used to initialize the message box view.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initMessageBox() {
		this.messageBox = new Popup();
		this.messageBox.getContent().addAll(this.messageLabel);
	}
	
	/**
	 * This method is used to initialize visual transitions for the message box.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initTransitions() {
		this.ft = new FadeTransition(Duration.millis(FADE_TIME), this.messageLabel);
		this.ft.setFromValue(FT_INITIAL_VAL);
		this.ft.setToValue(FT_FINAL_VAL);
		this.ft.setCycleCount(FT_CYCLE_COUNT);
		this.ft.setAutoReverse(false);
		this.ft.setOnFinished(new EventHandler<ActionEvent>() {
			public void handle(ActionEvent t) {
				messageBox.hide();
				isOn = false;
			}
		});
	}
	
	/**
	 * This method is used to change the position and dimension of the message box.
	 * @param x The value to set the x-coordinate of the message box to.
	 * @param y The value to set the y-coordinate of the message box to.
	 * @param width The value to set the width of the message box to.
	 * @param height The value to set the height of the message box to.
	 */
	private void update(double x, double y, double width, double height) {
		this.messageBox.setX(x);
		this.messageBox.setY(y);
		this.messageLabel.setPrefSize(width, height);
	}
	
	/**
	 * This method is used to update the style of the message label.
	 * @param msgType The <tt>UIMessageType</tt> to set the style of the message label to.
	 */
	private void updateMessageLabelStyleClass(UIMessageType msgType) {
		if (msgType == UIMessageType.DEFAULT) {
			this.messageLabel.getStyleClass().clear();
			this.messageLabel.getStyleClass().add(STYLECLASS_MESSAGE_BOX_LABEL);
		} else if (msgType == UIMessageType.ERROR) {
			this.messageLabel.getStyleClass().add(STYLECLASS_MESSAGE_BOX_LABEL_ERROR);
		}
	}
	
	/**
	 * This method is used to adjust the duration of the message box's transition, 
	 * depending on length of the message it is displaying.
	 * @param msg The message displayed by the message box.
	 */
	private void updateMessageLabelSettings(String msg) {
		if (msg.length() > CHAR_LEN_LONG) {
			this.ft.setDuration(Duration.millis(FADE_TIME_LONG));
		} else {
			this.ft.setDuration(Duration.millis(FADE_TIME));
		}
		this.isOn = true;
		this.messageLabel.setText(msg);
	}
	
	/**
	 * This method is used to check if the message box is visible.
	 * @return <tt>True</tt> if message box is visible, <tt>False</tt> otherwise.
	 */
	protected boolean isShowing() {
		return this.messageBox.isShowing();
	}
	
	/**
	 * This method is used to update the position of the message box.
	 */
	protected void updatePosition() {
		double x = this.primaryStage.getX();
		double y = this.primaryStage.getY() + this.primaryStage.getHeight() - PAD_Y;
		double width = this.primaryStage.getWidth();
		if(OsUtils.isWindows()) {
			x += PAD_X;
			width -= 2 * PAD_X;
		}
		update(x, y, width, PREFHEIGHT);
	}
	
	/**
	 * This method is used to show the message box in the stage of the application scene.
	 * It is used by the <tt>show</tt> method.
	 */
	protected void display() {
		updatePosition();
		this.messageBox.show(this.primaryStage);
	}
	
	/**
	 * This method is used to show the message box to the user.
	 * @param msg The message to display to the user.
	 * @param msgType The <tt>UIMessageType</tt> of the message.
	 */
	protected void show(String msg, UIMessageType msgType) {
		updateMessageLabelStyleClass(msgType);
		updateMessageLabelSettings(msg);
		display();
		this.ft.playFromStart();
	}

	/**
	 * This method is used to temporarily hide the message box.
	 */
	protected void tempHide() {
		this.messageBox.hide();
	}

	/**
	 * This method is used to hide the message box.
	 */
	protected void hide() {
		this.ft.play();
	}

	/**
	 * This method is used to retrieve the visibility attribute of the message box.
	 * @return <tt>True</tt> if message box should be visible to user, <tt>False</tt> otherwise.
	 */
	protected boolean isOn() {
		return this.isOn;
	}
}
```
###### src\dooyit\ui\UIMessageType.java
``` java
package dooyit.ui;

/**
 * The <tt>UIMessageType</tt> class contains the enumerated types of messages that 
 * are displayed in the message box.
 * @author 	Wu Wenqi
 * @version	0.5
 * @since 	2016-04-10
 */

public enum UIMessageType {
	DEFAULT, ERROR
}
```
###### src\dooyit\ui\UISideMenu.java
``` java
package dooyit.ui;

import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import com.pepperonas.fxiconics.FxIconicsLabel;
import com.pepperonas.fxiconics.MaterialColor;
import com.pepperonas.fxiconics.cmd.FxFontCommunity;
import dooyit.common.datatype.Category;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.ToggleButton;
import javafx.scene.control.ToggleGroup;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;

/**
 * The <tt>UISideMenu</tt> class contains the methods to initialize the side menu 
 * and update its menu buttons.
 * @author 	Wu Wenqi
 * @version	0.5
 * @since 	2016-04-10
 */

public class UISideMenu {
	private static final String LOG_MSG_INIT_SUCCESS = "Initialization of UISideMenu successful";
	private static final String LABEL_TODAY = "Today";
	private static final String LABEL_EXTENDED = "Next 7 days";
	private static final String LABEL_FLOAT = "Float";
	private static final String LABEL_ALL = "All";
	private static final String LABEL_COMPLETED = "Completed";
	private static final String STYLECLASS_MENU = UIStyle.MENU_VIEW;
	private static final int SPACING_MENU = 8;
	private static final String LABEL_CATEGORY_TITLE = "CATEGORIES";
	private static final String STYLECLASS_CATEGORY_TITLE = UIStyle.CATEGORY_TITLE;
	private static final String STYLECLASS_BTN_LABEL = UIStyle.BTN_SELECT_LABEL;
	private static final int SIZE_BTN_ICON = 18;
	private static final String COLOR_BTN_ICON = MaterialColor.GREY_400;
	private static final int SPACING_BTN_CONTENT = 8;
	private static final String STYLECLASS_MENU_BTN = UIStyle.BTN_SELECT_VIEW;
	private static final int PREFWIDTH_MENU_BTN = 200;
	private static final String STYLECLASS_MENU_PANE = UIStyle.MENU_PANE;

	private ScrollPane menuPane;
	private VBox menu;
	private ToggleGroup mainViewToggleGroup;
	private ToggleButton todayBtn;
	private ToggleButton extendedBtn;
	private ToggleButton floatBtn;
	private ToggleButton allBtn;
	private ToggleButton completedBtn;
	private Label categoryTitle;
	private UICategoryBoxContainer categoryBoxContainer;
	private UIController parent;
	private Logger logger;

	/**
	 * This is the constructor method.
	 * @param parent The parent <tt>UIController</tt> class.
	 */
	protected UISideMenu(UIController parent) {
		this.parent = parent;
		initialize();
	}
	
	/**
	 * This method is used to initialize the <tt>UISideMenu</tt> class.
	 * It is used by the constructor.
	 */
	private void initialize() {
		initLogger();
		this.mainViewToggleGroup = new ToggleGroup();
		initMenuButtons();
		initCategoryButtons();
		initMenu();
		initMenuPane();
		this.logger.log(Level.INFO, LOG_MSG_INIT_SUCCESS);
	}
	
	/**
	 * This method is used to initialize the logger.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initLogger() {
		this.logger = Logger.getLogger(getClass().getName());
	}
	
	/**
	 * This method is used to initialize the main menu buttons.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initMenuButtons() {
		this.todayBtn = getMenuButton(LABEL_TODAY, UIData.USERDATA_TODAY, FxFontCommunity.Icons.cmd_calendar);
		this.extendedBtn = getMenuButton(LABEL_EXTENDED, UIData.USERDATA_EXTENDED, FxFontCommunity.Icons.cmd_numeric_7_box_multiple_outline);
		this.floatBtn = getMenuButton(LABEL_FLOAT, UIData.USERDATA_FLOAT, FxFontCommunity.Icons.cmd_image_filter_drama);
		this.allBtn = getMenuButton(LABEL_ALL, UIData.USERDATA_ALL, FxFontCommunity.Icons.cmd_calendar_multiple);
		this.completedBtn = getMenuButton(LABEL_COMPLETED, UIData.USERDATA_COMPLETED, FxFontCommunity.Icons.cmd_comment_check);
	}
	
	/**
	 * This method is used to initialize the category menu buttons.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initCategoryButtons() {
		 this.categoryTitle = new Label(LABEL_CATEGORY_TITLE);
		 this.categoryTitle.getStyleClass().add(STYLECLASS_CATEGORY_TITLE);	
		 this.categoryBoxContainer = new UICategoryBoxContainer(this, new ArrayList<Category>());
	}
	
	/**
	 * This method is used to initialize the menu view. 
	 * It should only be called after all menu buttons and the category title have been initialized.
	 * This method is used by the <tt>initialize</tt> method.
	 */
	private void initMenu() {
		this.menu = new VBox();
		this.menu.setSpacing(SPACING_MENU);
		this.menu.getStyleClass().add(STYLECLASS_MENU);
		this.menu.getChildren().addAll(this.todayBtn, this.extendedBtn, this.floatBtn, this.allBtn, this.completedBtn, this.categoryTitle, this.categoryBoxContainer.getView());
	}
	
	/**
	 * This method is used to initialize the scroll pane that will contain the menu view.
	 * It should only be called after the menu view has been initialized.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initMenuPane() {
		this.menuPane = new ScrollPane();
		this.menuPane.getStyleClass().add(STYLECLASS_MENU_PANE);
		this.menuPane.setHbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);
		this.menuPane.setFitToWidth(true);
		this.menuPane.setContent(this.menu);
	}
	
	/**
	 * This method is used to create and return a menu button.
	 * @param title The name of the menu button.
	 * @param userData The user data that is associated with the menu button.
	 * @param icon The icon of the menu button.
	 * @return A menu button.
	 */
	private ToggleButton getMenuButton(String title, String userData, FxFontCommunity.Icons icon) {
		FxIconicsLabel btnIcon = getMenuBtnIcon(icon);
		Label btnLabel = getMenuBtnLabel(title); 
		return makeMenuButton(btnIcon, btnLabel, userData);
	}
	
	/**
	 * This method is used to create and return an icon for a menu button.
	 * @param icon The icon to be used for a menu button.
	 * @return
	 */
	private FxIconicsLabel getMenuBtnIcon(FxFontCommunity.Icons icon) {
		return (FxIconicsLabel) new FxIconicsLabel.Builder(icon).size(SIZE_BTN_ICON).color(COLOR_BTN_ICON).build();
	}
	
	/**
	 * This method is used to create and return a label for a menu button.
	 * @param title The label to be used for a menu button.
	 * @return
	 */
	private Label getMenuBtnLabel(String title) {
		Label btnLabel = new Label(title);
		btnLabel.getStyleClass().add(STYLECLASS_BTN_LABEL);
		return btnLabel;
	}
	
	/**
	 * This method is used to create and return a menu button.
	 * It is used by the <tt>getMenuButton</tt> method.
	 * @param icon The icon of the menu button.
	 * @param btnLabel The label to add to the menu button.
	 * @param userData The user data to be associated with the menu button.
	 * @return A menu button.
	 */
	private ToggleButton makeMenuButton(FxIconicsLabel icon, Label btnLabel, String userData) {
		HBox btnContent = new HBox();
		btnContent.setSpacing(SPACING_BTN_CONTENT);
		btnContent.getChildren().addAll(icon, btnLabel);
		ToggleButton menuBtn = new ToggleButton();
		menuBtn.setGraphic(btnContent);
		menuBtn.setPrefWidth(PREFWIDTH_MENU_BTN);
		menuBtn.getStyleClass().add(STYLECLASS_MENU_BTN);
		menuBtn.setToggleGroup(this.mainViewToggleGroup);
		menuBtn.setUserData(userData);
		return menuBtn;
	}
	
	/**
	 * This method is used to select the category menu button of <tt>category</tt>.
	 * @param category The <tt>Category</tt> whose menu button is to be selected.
	 */
	protected void setActiveCategoryButton(Category category) {
		this.categoryBoxContainer.setActiveCategoryButton(category);
	}
	
	/**
	 * This method is used to get the scroll pane that contains the menu view.
	 * @return The scroll pane that contains the menu view.
	 */
	protected ScrollPane getView() {
		return this.menuPane;
	}

	/**
	 * This method is used to get the menu button for today's view.
	 * @return Menu button for today's view
	 */
	protected ToggleButton getTodayBtn() {
		return this.todayBtn;
	}

	/**
	 * This method is used to get the menu button for next 7 days' view.
	 * @return Menu button for next 7 days' view.
	 */
	protected ToggleButton getExtendedBtn() {
		return this.extendedBtn;
	}
	
	/**
	 * This method is used to get the menu button for float view.
	 * @return Menu button for float view.
	 */
	protected ToggleButton getFloatBtn() {
		return this.floatBtn;
	}

	/**
	 * This method is used to get the menu button for all view.
	 * @return Menu button for all view.
	 */
	protected ToggleButton getAllBtn() {
		return this.allBtn;
	}

	/**
	 * This method is used to get the menu button for completed view.
	 * @return Menu button for completed view.
	 */
	protected ToggleButton getCompletedBtn() {
		return this.completedBtn;
	}

	/**
	 * This method is used to get the <tt>ToggleGroup</tt> of the menu buttons.
	 * @return <tt>ToggleGroup</tt> of the menu buttons.
	 */
	protected ToggleGroup getMainViewToggleGroup() {
		return this.mainViewToggleGroup;
	}

	/**
	 * This method is used to update the category menu buttons.
	 * @param categoryList The list of <tt>Category</tt> objects to create menu buttons for.
	 */
	protected void refreshCategoryMenuView(ArrayList<Category> categoryList) {
		this.categoryBoxContainer.refresh(categoryList);
	}
	
	/**
	 * This method is used to process a command string.
	 * @param cmd The command string to be processed.
	 */
	protected void processCommand(String cmd) {
		this.parent.processCommand(cmd);
	}
	
	/**
	 * This method is used to get the name of the <tt>Category</tt> whose menu button is selected.
	 * @return The name of the <tt>Category</tt> whose menu button is selected.
	 */
	protected String getSelectedCategoryName() {
		return this.categoryBoxContainer.getSelectedCategoryName();
	}
}
```
###### src\dooyit\ui\UIStyle.java
``` java
package dooyit.ui;

/**
 * The <tt>UIStyle</tt> class contains the relative pathnames and class names for CSS files.
 * @author 	Wu Wenqi
 * @version	0.5
 * @since 	2016-04-10
 */

public class UIStyle {
	protected static final String URL_CSS_COMMON = "resrc/css/common.css";
	protected static final String URL_CSS_THEME_LIGHT = "resrc/css/theme_light.css";
	protected static final String URL_CSS_THEME_DARK = "resrc/css/theme_dark.css";
	protected static final String URL_CSS_THEME_AQUA = "resrc/css/theme_aqua.css";
	protected static final String URL_CSS_THEME_CUSTOM = "resrc/css/theme_custom.css";
	protected static final String MAIN_VIEW = "main-view";
	protected static final String HEADER_VIEW = "header-view";
	protected static final String HEADER_TITLE = "header-title";
	protected static final String CATEGORY_TITLE = "category-title";
	protected static final String CATEGORY_NAME = "category-name";
	protected static final String CATEGORY_CIRCLE = "category-circle";
	protected static final String CATEGORY_BOX_WRAPPER = "category-box-wrapper";
	protected static final String BTN_SELECT_VIEW = "btn-select-view";
	protected static final String BTN_SELECT_LABEL = "btn-select-label";
	protected static final String MENU_VIEW = "menu-view";
	protected static final String MENU_PANE = "menu-pane";
	protected static final String DAY_BOX = "day-box";
	protected static final String DAY_TITLE = "day-title";
	protected static final String DAY_TITLE_FADED = "day-title-faded";
	protected static final String TASK_ID = "task-id";
	protected static final String TASK_CHECKBOX = "task-checkbox";
	protected static final String TASK_NAME = "task-name";
	protected static final String TASK_PERIOD = "task-period";
	protected static final String TASK_PERIOD_OVERDUE = "task-period-overdue";
	protected static final String TASK_CATEGORY_LABEL = "task-category-label";
	protected static final String DAY_TASK_BOX = "day-task-box";
	protected static final String TASK_MESSAGE = "task-message";
	protected static final String COMMAND_TEXTFIELD = "command-textfield";
	protected static final String COMMAND_BOX = "command-box";
	protected static final String MESSAGE_BOX_LABEL = "message-box-label";
	protected static final String MESSAGE_BOX_LABEL_ERROR = "message-box-label-error";
	protected static final String HELP_BOX_TITLE = "help-box-title";
	protected static final String HELP_BOX_CONTENT_LABEL = "help-box-content-label";
	protected static final String HELP_BOX_WRAPPER = "help-box-wrapper";
}
```
###### src\dooyit\ui\UITaskBox.java
``` java
package dooyit.ui;

import dooyit.common.datatype.Category;
import dooyit.common.datatype.DateTime;
import dooyit.common.datatype.Task;
import javafx.geometry.Pos;
import javafx.scene.control.CheckBox;
import javafx.scene.control.Label;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.HBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;

/**
 * The <tt>UITaskBox</tt> class contains the methods to initialize a task view and 
 * change its layout and dimensions.
 * @author 	Wu Wenqi
 * @version	0.5
 * @since 	2016-04-10
 */

public class UITaskBox {
	private static final String STYLECLASS_TASK_CHECKBOX = UIStyle.TASK_CHECKBOX;
	private static final String STYLECLASS_TASK_ID = UIStyle.TASK_ID;
	private static final int PREFWIDTH_TASK_ID = 24;
	private static final String STYLECLASS_TASK_NAME = UIStyle.TASK_NAME;
	private static final String STYLECLASS_TASK_PERIOD = UIStyle.TASK_PERIOD;
	private static final String STYLECLASS_TASK_PERIOD_OVERDUE = UIStyle.TASK_PERIOD_OVERDUE;
	private static final String STYLECLASS_TASK_CATEGORY_LABEL = UIStyle.TASK_CATEGORY_LABEL;
	private static final int PREFWIDTH_TASK_CATEGORY_LABEL = 120;
	private static final String STYLECLASS_TASK_BOX = UIStyle.DAY_TASK_BOX;
	private static final int RADIUS_CAT_CIRCLE = 4;
	private static final int WIDTH_MENU = 180;
	private static final int PAD_X = 20;
	private static final int WIDTH_TO_SUBTRACT = 55 + WIDTH_MENU + 2 * PAD_X;
	private static final String DOUBLE_SPACE = "  ";
	private static final double ANCHOR_TOP = 5.0;
	private static final double ANCHOR_LEFT = 0.0;
	private static final double ANCHOR_RIGHT = 0.0;
	private static final int STR_LEN_TASK_PERIOD = 7;
	private static final double LEN_EVENT_PERIOD = 112;
	private static final double LEN_TASK_PERIOD = 56;

	private UIDayBox parent;
	private Task task;
	private CheckBox taskCheckBox;
	private Label taskId;
	private Label taskName;
	private Label taskPeriod;
	private HBox taskDetailBox;
	private Label taskCategoryLabel;
	private Circle taskCategoryCircle;
	private HBox taskCategoryBox;
	private AnchorPane taskBox;

	/**
	 * This is the constructor method.
	 * @param parent The parent <tt>UIDayBox</tt> class.
	 * @param task The <tt>Task</tt> to populate the task view with.
	 */
	public UITaskBox(UIDayBox parent, Task task) {
		this.task = task;
		this.parent = parent;
		initialize();
	}
	
	/**
	 * This method is used to initialize the <tt>UITaskBox</tt> class.
	 * It is used by the constructor.
	 */
	private void initialize() {
		initTaskCheckBox();
		initTaskId();
		initTaskCategoryLabel();
		initTaskPeriod();
		initTaskName();
		initTaskDetailBox();
		initTaskCategoryBox();
		initTaskBox();
		initListeners();
		updateTaskBoxWidth();
	}
	
	/**
	 * This method is used to initialize the check box for the task view.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initTaskCheckBox() {
		this.taskCheckBox = new CheckBox();
		this.taskCheckBox.getStyleClass().add(STYLECLASS_TASK_CHECKBOX);
		if (this.task.isCompleted()) {
			this.taskCheckBox.setSelected(true);
		}
	}
	
	/**
	 * This method is used to initialize the task id for the task view.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initTaskId() {
		this.taskId = new Label(Integer.toString(this.task.getDisplayId()));
		this.taskId.getStyleClass().add(STYLECLASS_TASK_ID);
		this.taskId.setPrefWidth(PREFWIDTH_TASK_ID);
	}
	
	/**
	 * This method is used to initialize the task period for the task view.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initTaskPeriod() {
		this.taskPeriod = new Label(getTaskPeriodString());
		this.taskPeriod.getStyleClass().add(STYLECLASS_TASK_PERIOD);
		if (isOverdueTask()) {
			this.taskPeriod.getStyleClass().add(STYLECLASS_TASK_PERIOD_OVERDUE);
		}
		if (!isEmptyTaskPeriod()) {
			setTaskPeriodWidth();
		}
	}
	
	/**
	 * This method is used to set the width of the task period. It should only be called after 
	 * the task period has been initialized. It is used by the <tt>initTaskPeriod</tt> method.
	 */
	private void setTaskPeriodWidth() {
		if (isLongTaskPeriod()) {
			this.taskPeriod.setPrefWidth(LEN_EVENT_PERIOD);
		} else {
			this.taskPeriod.setPrefWidth(LEN_TASK_PERIOD);
		}
	}
	
	/**
	 * This method is used to check if the <tt>Task</tt> is overdue.
	 * @return <tt>True</tt> if the <tt>Task</tt> is overdue, <tt>False</tt> otherwise.
	 */
	private boolean isOverdueTask() {
		return this.task.isOverDue(new DateTime());
	}
	
	/**
	 * This method is used to check if the task period is empty.
	 * @return <tt>True</tt> if the task period is empty, <tt>False</tt> otherwise.
	 */
	private boolean isEmptyTaskPeriod() {
		return this.taskPeriod.getText().isEmpty();
	}
	
	/**
	 * This method is used to check if the task period string is long.
	 * @return <tt>True</tt> if task period string is long, <tt>False</tt> otherwise.
	 */
	private boolean isLongTaskPeriod() {
		return this.taskPeriod.getText().length() > STR_LEN_TASK_PERIOD;
	}
	
	/**
	 * This method is used to get the task period string.
	 * @return The task period string.
	 */
	private String getTaskPeriodString() {
		String s = this.task.getDateString();
		if (!s.isEmpty()) {
			s += DOUBLE_SPACE;
		} 
		return s;
	}
	
	/**
	 * This method is used to initialize the category name displayed in the task view.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initTaskCategoryLabel() {
		this.taskCategoryLabel = new Label();
		setCategoryCircle();
		this.taskCategoryLabel.setAlignment(Pos.CENTER_RIGHT);
		this.taskCategoryLabel.getStyleClass().add(STYLECLASS_TASK_CATEGORY_LABEL);
		this.taskCategoryLabel.setPrefWidth(PREFWIDTH_TASK_CATEGORY_LABEL);
	}
	
	/**
	 * This method is used to initialize the colored circle of the category in the task view.
	 * It is used by the <tt>setCategoryCircle</tt> method.
	 */
	private void setCategoryCircle() {
		if (this.task.hasCategory()){
			Category category = this.task.getCategory();
			this.taskCategoryLabel.setText(category.getName());
			this.taskCategoryCircle = new Circle(RADIUS_CAT_CIRCLE, category.getColour());
		} else {
			this.taskCategoryCircle = new Circle(RADIUS_CAT_CIRCLE, Color.TRANSPARENT);
		}
	}
	
	/**
	 * This method is used to initialize the task name.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initTaskName() {
		this.taskName = new Label(this.task.getName());
		this.taskName.getStyleClass().add(STYLECLASS_TASK_NAME);
	}
	
	/**
	 * This method is used to initialize the view box for the task details.
	 * This method can only be called after the check box, task id, task period and task name have been 
	 * initialized.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initTaskDetailBox() {
		this.taskDetailBox = new HBox();
		this.taskDetailBox.getChildren().addAll(this.taskCheckBox, this.taskId, this.taskPeriod, this.taskName);
		this.taskDetailBox.setAlignment(Pos.CENTER_LEFT);
	}
	
	/**
	 * This method is used to initialized the view box for the task's category details.
	 * This method can only been called after the category label and category colored circle have 
	 * been initialized.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initTaskCategoryBox() {
		this.taskCategoryBox = new HBox();
		this.taskCategoryBox.getChildren().addAll(this.taskCategoryLabel, this.taskCategoryCircle);
		this.taskCategoryBox.setAlignment(Pos.CENTER_RIGHT);
	}
	
	/**
	 * This method is used to initialize the task view.
	 * It can only be called after the view boxes for both task details and category details have been 
	 * initialized.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initTaskBox() {
		 this.taskBox = new AnchorPane();
		 AnchorPane.setTopAnchor(this.taskDetailBox, ANCHOR_TOP);
		 AnchorPane.setTopAnchor(this.taskCategoryBox, ANCHOR_TOP);
		 AnchorPane.setLeftAnchor(this.taskDetailBox, ANCHOR_LEFT);
		 AnchorPane.setRightAnchor(this.taskCategoryBox, ANCHOR_RIGHT);
		 this.taskBox.getStyleClass().add(STYLECLASS_TASK_BOX);
		 this.taskBox.getChildren().addAll(this.taskDetailBox, this.taskCategoryBox);
	}
	
	/**
	 * This method is used to initialize event listeners for the task view.
	 * It is used by the <tt>initialize</tt> method.
	 */
	private void initListeners() {
	    this.taskCheckBox.setOnAction((event) -> {
	    	if (!this.task.isCompleted()){
	    		this.parent.markTask(this.task.getDisplayId());
	    	} else {
	    		this.parent.unmarkTask(this.task.getDisplayId());
	    	}
	    });
	}

	/**
	 * This method is used to adjust the task view width depending on the stage width of the 
	 * application scene.
	 * @param stageWidth The stage width of the application scene.
	 */
	private void updateTaskBoxWidth(double stageWidth) {
		double width = stageWidth - WIDTH_TO_SUBTRACT;
		this.taskBox.setMinWidth(width);
		this.taskBox.setPrefWidth(width);
		this.taskBox.setMaxWidth(width);
		double taskNameMaxWidth = getTaskNameMaxWidth(width);
		this.taskName.setMaxWidth(taskNameMaxWidth);
	}
	
	/**
	 * This method is used to retrieve the max width of the task name label given the width of the 
	 * task view.
	 * It is used by the <tt>updateTaskBoxWidth</tt> method.
	 * @param width The width of the task view.
	 * @return The maximum width of the task name label.
	 */
	private double getTaskNameMaxWidth(double width) {
		return width - PREFWIDTH_TASK_CATEGORY_LABEL - RADIUS_CAT_CIRCLE - 2 * PAD_X - this.taskPeriod.getPrefWidth();
	}
	
	/**
	 * This is an overloading method for the <tt>updateTaskBoxWidth</tt> method.
	 */
	private void updateTaskBoxWidth() {
		double width = this.parent.getStageWidth();
		updateTaskBoxWidth(width);
	}
	
	/**
	 * This method is used to retrieve the task view.
	 * @return A task view.
	 */
	protected AnchorPane getView() {
		return this.taskBox;
	}

	/**
	 * This method is used to update the dimensions of the task view.
	 * @param stageWidth The stage width of the application scene.
	 */
	protected void updatePosition(double stageWidth) {
		updateTaskBoxWidth(stageWidth);
	}
}
```
###### src\dooyit\ui\UITaskMessage.java
``` java
package dooyit.ui;

import javafx.scene.control.Label;

/**
 * The <tt>UITaskMessage</tt> class contains the methods to initialize the label that is added to 
 * the message box.
 * @author 	Wu Wenqi
 * @version	0.5
 * @since 	2016-04-10
 */

public class UITaskMessage {
	private static final String STYLESHEET_TASK_MESSAGE = UIStyle.TASK_MESSAGE;
	
	private Label taskMessage;
	
	/**
	 * This is the constructor method.
	 * @param message The message to display in the label.
	 */
	protected UITaskMessage(String message) {
		this.taskMessage = new Label(message);
		this.taskMessage.getStyleClass().add(STYLESHEET_TASK_MESSAGE);
	}
	
	/**
	 * This method is used to retrieve the message box label.
	 * @return The message box label.
	 */
	protected Label getView() {
		return this.taskMessage;
	}	
}
```
###### src\dooyit\ui\UITheme.java
``` java
package dooyit.ui;

/**
 * The <tt>UITheme</tt> class contains the enumerated types for the applicaton's skins.
 * @author 	Wu Wenqi
 * @version	0.5
 * @since 	2016-04-10
 */

public enum UITheme {
	LIGHT, DARK, AQUA, CUSTOM
}
```
###### test\dooyit\common\datatype\CategoryTest.java
``` java
package dooyit.common.datatype;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Before;
import org.junit.Test;

/**
 * 
 * @author Wu Wenqi
 *
 */

public class CategoryTest {
	Category cat1;
	Category cat2;
	Category cat3;

	@Before
	public void setUp() {
		cat1 = new Category("School", CustomColour.BLUE);
		cat2 = new Category("Chores");
		cat3 = new Category("CHORES");
	}

	@Test
	public void testGetName() {
		assertEquals(cat1.getName(), "School");
		assertEquals(cat2.getName(), "Chores");
	}

	@Test
	public void testGetColor() {
		assertTrue(cat1.getColour().equals(CustomColour.BLUE.getColor()));
	}

	@Test
	public void testGetCustomColor() {
		assertTrue(cat1.getCustomColour().equals(CustomColour.BLUE));
	}

	@Test
	public void testGetCustomColorName() {
		assertEquals(cat1.getCustomColourName(), "blue");
	}

	@Test
	public void testEquals() {
		assertFalse(cat1.equals(cat2));
		assertTrue(cat2.equals(cat3));
		assertTrue(cat2.equals("chores"));
	}

	@Test
	public void testToString() {
		String s = "School " + CustomColour.BLUE.toString();
		assertEquals(cat1.toString(), s);
	}

}
```
###### test\dooyit\common\datatype\DataTypeTestSuite.java
``` java
package dooyit.common.datatype;

import org.junit.runner.RunWith;
import org.junit.runners.Suite;

@RunWith(Suite.class)
@Suite.SuiteClasses({ CategoryTest.class, DateTimeTest.class, EventTaskTest.class,
					FloatingTaskTest.class, TaskGroupTest.class, TaskTest.class,
					DeadlineTaskTest.class })
public class DataTypeTestSuite {

}
```
###### test\dooyit\common\datatype\DateTimeTest.java
``` java
package dooyit.common.datatype;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.util.ArrayList;
import java.util.Arrays;

import org.junit.Before;
import org.junit.Test;

import dooyit.common.datatype.DateTime.Day;

/**
 * 
 * @author Wu Wenqi
 *
 */

public class DateTimeTest {
	DateTime dt1, dt2, dt3, dt4, currDT;

	@Before
	public void setUp() {
		dt1 = new DateTime();
		int[] date = { 28, 3, 2016 };
		dt2 = new DateTime(date);
		dt3 = new DateTime(date, 1200);
		dt4 = new DateTime(date, 0);
		currDT = new DateTime();
	}

	@Test
	public void getMultiDayString() {
		int[] startDate = new int[] { 3, 4, 2016 };
		int startTime = 900;
		DateTime start = new DateTime(startDate, startTime);

		int[] endDate = new int[] { 4, 4, 2016 };
		int endTime = 1600;
		DateTime end = new DateTime(endDate, endTime);

		ArrayList<String> listOfString = DateTime.getMultiDayString(start, end);
		ArrayList<String> expected = new ArrayList<String>(Arrays.asList("09:00 - 23:59", "00:00 - 16:00"));
		assertEquals(expected, listOfString);
	}
	
	@Test
	public void isWithinDayTrue() {
		int[] startDate = new int[] { 7, 4, 2016 };
		int startTime = 900;
		DateTime start = new DateTime(startDate, startTime);

		int[] endDate = new int[] { 10, 4, 2016 };
		int endTime = 1600;
		DateTime end = new DateTime(endDate, endTime);
		
		Day day = Day.FRI;
		
		assertTrue(DateTime.isWithinDay(day, start, end));
	}
	
	@Test
	public void isWithinDayFalse() {
		int[] startDate = new int[] { 7, 4, 2016 };
		int startTime = 900;
		DateTime start = new DateTime(startDate, startTime);

		int[] endDate = new int[] { 10, 4, 2016 };
		int endTime = 1600;
		DateTime end = new DateTime(endDate, endTime);
		
		Day day = Day.MON;
		
		assertTrue(!DateTime.isWithinDay(day, start, end));
	}

	@Test
	public void compareTo() {
		assertEquals(dt1.compareTo(dt2), 1);
		assertEquals(dt2.compareTo(dt3), 1);
		assertEquals(dt2.compareTo(dt4), 1);
	}

	@Test
	public void getDayStr() {
		assertEquals(dt1.getDayStr(), currDT.getDayStr());
		assertEquals(dt2.getDayStr(), "Monday");
		assertEquals(dt3.getDayStr(), "Monday");
	}

	@Test
	public void getDayInt() {
		assertEquals(dt1.getDayInt(), currDT.getDayInt());
		assertEquals(dt2.getDayInt(), 1);
	}

	@Test
	public void getDate() {
		assertEquals(dt1.getDate(), currDT.getDate());
	}

	@Test
	public void getTime24hStr() {
		assertEquals(dt2.getTime24hStr(), "-1");
		assertEquals(dt3.getTime24hStr(), "12:00");
		assertEquals(dt4.getTime24hStr(), "00:00");
	}

	@Test
	public void getTime12hStr() {
		assertEquals(dt2.getTime12hStr(), "-1");
		assertEquals(dt3.getTime12hStr(), "12.00 pm");
		assertEquals(dt4.getTime12hStr(), "12.00 am");
	}

	@Test
	public void getTimeInt() {
		assertEquals(dt2.getTimeInt(), -1);
		assertEquals(dt3.getTimeInt(), 1200);
		assertEquals(dt4.getTimeInt(), 0);
	}

	@Test
	public void getDD() {
		assertEquals(dt2.getDD(), 28);
		assertEquals(dt3.getDD(), 28);
	}

	@Test
	public void getMM() {
		assertEquals(dt2.getMM(), 3);
		assertEquals(dt3.getMM(), 3);
	}

	@Test
	public void getYY() {
		assertEquals(dt2.getYY(), 2016);
		assertEquals(dt3.getYY(), 2016);
	}

	@Test
	public void testToString() {
		assertEquals(dt2.toString(), "28 Mar 2016 Monday -1 -1");
		assertEquals(dt3.toString(), "28 Mar 2016 Monday 12:00 12.00 pm");
		assertEquals(dt4.toString(), "28 Mar 2016 Monday 00:00 12.00 am");
	}

	@Test
	public void hasTime() {
		assertFalse(dt2.hasTime());
		assertTrue(dt3.hasTime());
		assertTrue(dt4.hasTime());
	}

	@Test
	public void isTheSameDateAs() {
		assertTrue(dt2.isTheSameDateAs(dt3));
		assertTrue(dt3.isTheSameDateAs(dt4));
	}

	@Test
	public void increaseByOneDay() {
		dt1.increaseByOneDay();
		currDT.increaseByOneDay();
		assertEquals(dt1.getDD(), currDT.getDD());
	}
	
	@Test
	public void overlapOfTwoDates_FirstInterval_IsWithin_SecondInterval() {
		int[] dt1Arr = new int[]{3, 4, 2016};
		int dt1Start = 1900;
		int dt1End = 2000;
		int[] dt2Arr = new int[]{3, 4, 2016};
		int dt2Start = 1800;
		int dt2End = 2100;
		DateTime startOne = new DateTime(dt1Arr, dt1Start);
		DateTime endOne = new DateTime(dt1Arr, dt1End);
		DateTime startTwo = new DateTime(dt2Arr, dt2Start);
		DateTime endTwo = new DateTime(dt2Arr, dt2End);
		
		assertEquals(true, DateTime.isOverlap(startOne, endOne, startTwo, endTwo));
	}
	
	
	@Test
	public void overlapOfTwoDates_SecondInterval_IsWithin_FirstInterval() {
		int[] dt1Arr = new int[]{3, 4, 2016};
		int dt1Start = 1900;
		int dt1End = 2000;
		int[] dt2Arr = new int[]{3, 4, 2016};
		int dt2Start = 1930;
		int dt2End = 1945;
		DateTime startOne = new DateTime(dt1Arr, dt1Start);
		DateTime endOne = new DateTime(dt1Arr, dt1End);
		DateTime startTwo = new DateTime(dt2Arr, dt2Start);
		DateTime endTwo = new DateTime(dt2Arr, dt2End);
		
		assertEquals(true, DateTime.isOverlap(startOne, endOne, startTwo, endTwo));
	}
	
	@Test
	public void overlapOfTwoDates_StartOfFirstInterval_Equals_EndOfSecondInterval() {
		int[] dt1Arr = new int[]{3, 4, 2016};
		int dt1Start = 1900;
		int dt1End = 2000;
		int[] dt2Arr = new int[]{3, 4, 2016};
		int dt2Start = 1800;
		int dt2End = 1900;
		DateTime startOne = new DateTime(dt1Arr, dt1Start);
		DateTime endOne = new DateTime(dt1Arr, dt1End);
		DateTime startTwo = new DateTime(dt2Arr, dt2Start);
		DateTime endTwo = new DateTime(dt2Arr, dt2End);
		
		assertEquals(false, DateTime.isOverlap(startOne, endOne, startTwo, endTwo));
	}
	
	@Test
	public void overlapOfTwoDates_EndOfFirstInterval_Equals_StartOfSecondInterval() {
		int[] dt1Arr = new int[]{3, 4, 2016};
		int dt1Start = 1900;
		int dt1End = 2000;
		int[] dt2Arr = new int[]{3, 4, 2016};
		int dt2Start = 2000;
		int dt2End = 2100;
		DateTime startOne = new DateTime(dt1Arr, dt1Start);
		DateTime endOne = new DateTime(dt1Arr, dt1End);
		DateTime startTwo = new DateTime(dt2Arr, dt2Start);
		DateTime endTwo = new DateTime(dt2Arr, dt2End);
		
		assertEquals(false, DateTime.isOverlap(startOne, endOne, startTwo, endTwo));
	}
	
	@Test
	public void overlapOfTwoDates_StartOfFirstInterval_IsWithin_SecondInterval() {
		int[] dt1Arr = new int[]{3, 4, 2016};
		int dt1Start = 1900;
		int dt1End = 2200;
		int[] dt2Arr = new int[]{3, 4, 2016};
		int dt2Start = 1800;
		int dt2End = 2100;
		DateTime startOne = new DateTime(dt1Arr, dt1Start);
		DateTime endOne = new DateTime(dt1Arr, dt1End);
		DateTime startTwo = new DateTime(dt2Arr, dt2Start);
		DateTime endTwo = new DateTime(dt2Arr, dt2End);
		
		assertEquals(true, DateTime.isOverlap(startOne, endOne, startTwo, endTwo));
	}
	
	@Test
	public void overlapOfTwoDates_EndOfFirstInterval_IsWithin_SecondInterval() {
		int[] dt1Arr = new int[]{3, 4, 2016};
		int dt1Start = 1900;
		int dt1End = 2200;
		int[] dt2Arr = new int[]{3, 4, 2016};
		int dt2Start = 1100;
		int dt2End = 2300;
		DateTime startOne = new DateTime(dt1Arr, dt1Start);
		DateTime endOne = new DateTime(dt1Arr, dt1End);
		DateTime startTwo = new DateTime(dt2Arr, dt2Start);
		DateTime endTwo = new DateTime(dt2Arr, dt2End);
		
		assertEquals(true, DateTime.isOverlap(startOne, endOne, startTwo, endTwo));
	}
	
	@Test
	public void overlapOfTwoDates_NoOverlap() {
		int[] dt1Arr = new int[]{4, 4, 2016};
		int dt1Start = 1900;
		int dt1End = 2000;
		int[] dt2Arr = new int[]{3, 4, 2016};
		int dt2Start = 1800;
		int dt2End = 2100;
		DateTime startOne = new DateTime(dt1Arr, dt1Start);
		DateTime endOne = new DateTime(dt1Arr, dt1End);
		DateTime startTwo = new DateTime(dt2Arr, dt2Start);
		DateTime endTwo = new DateTime(dt2Arr, dt2End);
		
		assertEquals(false, DateTime.isOverlap(startOne, endOne, startTwo, endTwo));
	}
	/*
	 * @Test public void convertToSavableString() {
	 * assertEquals(dt3.convertToSavableString(), "28 3 2016"); }
	 */
}
```
###### test\dooyit\common\datatype\DeadlineTaskTest.java
``` java
package dooyit.common.datatype;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Before;
import org.junit.Test;

/**
 * 
 * @author Wu Wenqi
 *
 */

public class DeadlineTaskTest {

	DeadlineTask task1, task2, task3;
	DateTime dt1, dt2;

	@Before
	public void setUp() {
		int[] date = { 22, 2, 2016 };
		dt1 = new DateTime(date, 800);
		task1 = new DeadlineTask("Go shopping", dt1);
		dt2 = new DateTime();
		task2 = new DeadlineTask("Find a job", dt2);
		task3 = new DeadlineTask("Find a job", dt2);
	}

	@Test
	public void getDateTimeDeadline() {
		assertTrue(task1.getDateTimeDeadline().equals(dt1));
	}

	@Test
	public void isToday() {
		assertTrue(task2.isSameDate(dt2));
	}

	@Test
	public void isOverDue() {
		assertTrue(task1.isOverDue(dt2));
		assertFalse(task2.isOverDue(dt2));
	}

	@Test
	public void getDateString() {
		assertEquals(task1.getDateString(), "08:00");
	}

	@Test
	public void testToString() {
		assertEquals("Go shopping, Deadline: 22 Feb 2016 Monday 08:00 8.00 am", task1.toString());
	}
}
```
###### test\dooyit\common\datatype\EventTaskTest.java
``` java
package dooyit.common.datatype;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Before;
import org.junit.Test;

/**
 * 
 * @author Wu Wenqi
 *
 */

public class EventTaskTest {

	EventTask task1;
	EventTask task2;
	EventTask task3;
	DateTime dt1_start, dt1_end;
	DateTime dt2_start, dt2_end;
	DateTime today;

	@Before
	public void setUp() {
		int[] date1 = { 22, 2, 2016 };
		today = new DateTime(date1, 0);
		dt1_start = new DateTime(date1, 800);
		dt1_end = new DateTime(date1, 1800);
		task1 = new EventTask("Beach day", dt1_start, dt1_end);
		int[] date2 = { 21, 2, 2016 };
		dt2_start = new DateTime(date2, 800);
		dt2_end = new DateTime(date2, 1800);
		task2 = new EventTask("Hiking", dt2_start, dt2_end);
		task3 = new EventTask("Hiking", dt2_start, dt2_end);
	}

	@Test
	public void getDateTimeStart() {
		assertTrue(task1.getDateTimeStart().equals(dt1_start));
	}

	@Test
	public void getDateTimeEnd() {
		assertTrue(task1.getDateTimeEnd().equals(dt1_end));
	}

	@Test
	public void isToday() {
		assertTrue(task1.isSameDate(today));
	}

	@Test
	public void isOverDue() {
		assertTrue(task2.isOverDue(today));
		assertFalse(task1.isOverDue(today));
	}

	@Test
	public void getDateString() {
		assertEquals(task1.getDateString(), "08:00 - 18:00");
	}

	@Test
	public void testToString() {
		assertEquals(task2.toString(),
				"Hiking, Event: 21 Feb 2016 Sunday 08:00 8.00 am to 21 Feb 2016 Sunday 18:00 6.00 pm");
	}
}
```
###### test\dooyit\common\datatype\FloatingTaskTest.java
``` java
package dooyit.common.datatype;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;

import org.junit.Before;
import org.junit.Test;

/**
 * 
 * @author Wu Wenqi
 *
 */

public class FloatingTaskTest {

	FloatingTask task1;
	FloatingTask task2;
	FloatingTask task3;
	DateTime today;

	@Before
	public void setUp() {
		today = new DateTime();
		task1 = new FloatingTask("Get a scooter");
		task2 = new FloatingTask("Get a scooter");
		task3 = new FloatingTask("Go skydiving");
	}

	@Test
	public void isToday() {
		assertFalse(task1.isSameDate(today));
	}

	@Test
	public void isOverDue() {
		assertFalse(task1.isOverDue(today));
	}

	@Test
	public void getDateString() {
		assertEquals(task1.getDateString(), "");
	}

	/*@Test
	public void testToString() {
		assertEquals(task1.toString(), "Get a scooter");
	}*/

}
```
###### test\dooyit\common\datatype\TaskGroupTest.java
``` java
package dooyit.common.datatype;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.util.ArrayList;

import org.junit.Before;
import org.junit.Test;

/**
 * 
 * @author Wu Wenqi
 *
 */

public class TaskGroupTest {

	TaskGroup taskGroup;
	TaskGroup taskGroup2;
	ArrayList<Task> taskGroupTasks;
	ArrayList<Task> tasks;
	DeadlineTask task1, task2, task3;
	DateTime dt;

	@Before
	public void setUp() {
		int[] date = { 22, 2, 2016 };
		dt = new DateTime(date, 1800);
		task1 = new DeadlineTask("Dinner at Tiffany's", dt);
		task2 = new DeadlineTask("Shopping at Ion", dt);
		task3 = new DeadlineTask("Movie date", dt);
		tasks = new ArrayList<Task>();
		tasks.add(task2);
		tasks.add(task3);
		taskGroup = new TaskGroup("Today", dt);
		taskGroup2 = new TaskGroup("Floating");
	}

	@Test
	public void addTask() {
		taskGroup.addTask(task1);
		taskGroupTasks = taskGroup.getTasks();
		assertEquals(taskGroupTasks.size(), 1);
		assertTrue(taskGroupTasks.get(0).equals(task1));
	}

	@Test
	public void addTasks() {
		taskGroup.addTasks(tasks);
		taskGroupTasks = taskGroup.getTasks();
		assertEquals(taskGroupTasks.size(), 2);
		assertTrue(taskGroupTasks.get(0).equals(task2));
		assertTrue(taskGroupTasks.get(1).equals(task3));
	}

	@Test
	public void getDateTime() {
		assertTrue(taskGroup.getDateTime().equals(dt));
	}

	@Test
	public void getTitle() {
		assertEquals(taskGroup.getTitle(), "Today, 22 Feb 2016");
	}

	@Test
	public void setTitle() {
		taskGroup.setTitle("This day");
		assertEquals(taskGroup.getTitle(), "This day, 22 Feb 2016");
	}

	@Test
	public void getTasks() {
		taskGroup.addTasks(tasks);
		taskGroupTasks = taskGroup.getTasks();
		assertEquals(taskGroupTasks.size(), 2);
		assertTrue(taskGroupTasks.get(0).equals(task2));
		assertTrue(taskGroupTasks.get(1).equals(task3));
	}

	@Test
	public void hasDateTime() {
		assertTrue(taskGroup.hasDateTime());
		assertFalse(taskGroup2.hasDateTime());
	}
}
```
###### test\dooyit\common\datatype\TaskTest.java
``` java
package dooyit.common.datatype;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Before;
import org.junit.Test;

/**
 * 
 * @author Wu Wenqi
 *
 */

public class TaskTest {

	Task taskF1;
	Task taskF2;
	Task taskF3;

	Task taskD1;
	Task taskD2;
	Task taskD3;

	@Before
	public void setUp() {
		taskF1 = new FloatingTask("hello");
		taskF2 = new FloatingTask("hello");
		taskF3 = new FloatingTask("home");

		DateTime date = new DateTime();

		taskD1 = new DeadlineTask("hello", date);
		taskD2 = new DeadlineTask("hello", date);
		taskD3 = new DeadlineTask("home", new DateTime());
	}

	@Test
	public void getName() {
		assertEquals(taskF1.getName(), "hello");
		assertEquals(taskD3.getName(), "home");
	}

	@Test
	public void changeName() {
		taskF1.changeName("goodbye");
		taskD1.changeName("goodbye");
		assertEquals(taskF1.getName(), "goodbye");
		assertEquals(taskD1.getName(), "goodbye");
	}

	@Test
	public void isCompleted() {
		assertFalse(taskF1.isCompleted());
		assertFalse(taskD1.isCompleted());
	}

	@Test
	public void mark() {
		taskF1.mark();
		taskD1.mark();
		assertTrue(taskF1.isCompleted());
		assertTrue(taskD1.isCompleted());
	}

	@Test
	public void unMark() {
		taskF1.mark();
		taskF1.unMark();
		assertFalse(taskF1.isCompleted());
	}

	@Test
	public void hasCategory() {
		assertFalse(taskF1.hasCategory());
		assertFalse(taskD1.hasCategory());
	}

	@Test
	public void setCategory() {
		Category cat = new Category("School");
		taskF1.setCategory(cat);
		taskD1.setCategory(cat);
		assertTrue(taskF1.hasCategory());
		assertTrue(taskD1.hasCategory());
	}

	@Test
	public void getCategory() {
		Category cat = new Category("School");
		taskF1.setCategory(cat);
		taskD1.setCategory(cat);
		assertTrue(taskF1.getCategory().equals(cat));
		assertTrue(taskF1.getCategory().equals(cat));
	}

	@Test
	public void resetId() {
		taskF1.resetDisplayId();
		taskD1.resetDisplayId();
		assertEquals(taskF1.getDisplayId(), -1);
		assertEquals(taskD1.getDisplayId(), -1);
	}

	@Test
	public void getId() {

	}

	@Test
	public void setId() {
		taskF1.setDisplayId(3);
		taskD1.setDisplayId(5);
		assertEquals(taskF1.getDisplayId(), 3);
		assertEquals(taskD1.getDisplayId(), 5);
	}

	@Test
	public void getUniqueId() {

	}

	@Test
	public void setUniqueId() {
		taskF1.setUniqueId(3);
		taskD1.setUniqueId(5);
		assertEquals(taskF1.getUniqueId(), 3);
		assertEquals(taskD1.getUniqueId(), 5);
	}

	@Test
	public void getTaskType() {
		assertTrue(taskF1.getTaskType() == Task.TaskType.FLOATING);
		assertTrue(taskD1.getTaskType() == Task.TaskType.DEADLINE);
	}
}
```
