# A0124586Y
###### src\dooyit\storage\StorageController.java
``` java
package dooyit.storage;

import java.util.ArrayList;
import java.util.logging.Logger;
import java.util.logging.Level;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

import dooyit.storage.TaskController;
import dooyit.storage.CategoryController;
import dooyit.storage.Constants;
import dooyit.common.datatype.CategoryData;
import dooyit.common.datatype.TaskData;
import dooyit.common.exception.IncorrectInputException;

public class StorageController {

	private String configFilePath;
	private String[] preferences;
	private CategoryController categoryControl;
	private TaskController taskControl;
	private static Logger logger = Logger.getLogger("Storage");

	private static final String NAME_FILE_CONFIG = "config.txt";
	
	private static final String CSS = ".css";
	private static final String TXT = ".txt";
	
	private static final String ERROR_MESSAGE_FILEPATH = "Invalid Path: %1$s - Path needs to end with .txt";
	
	private static final int TASK_DESTINATION = 0;
	private static final int THEME_DESTINATION = 1;
	private static final int PREFERENCES_SIZE = 2;

	public StorageController() throws IOException {
		preferences = new String[PREFERENCES_SIZE];
		configFilePath = getConfigPath(Constants.CURRENT_DIRECTORY);
		preferences = loadPreferences(configFilePath);
		categoryControl = new CategoryController(Constants.DEFAULT_CATEGORIES_DESTINATION);
		taskControl = new TaskController(preferences[TASK_DESTINATION]);
	}

	private String getConfigPath(String currentPath) {
		logger.log(Level.INFO, "Getting save destination");
		return currentPath + Constants.SEPARATOR_CHAR + NAME_FILE_CONFIG;
	}

	public boolean setFileDestination(String newFilePath) throws IOException {
		logger.log(Level.INFO, "Changing save destination");

		if (isValidPath(newFilePath)) {
			preferences[TASK_DESTINATION] = newFilePath;
			modifyConfig(preferences);
			taskControl.setFileDestination(newFilePath);
			File file = new File(newFilePath);
			if (file.exists()) {
				return true;
			}
		}

		return false;
	}

	public boolean saveTasks(ArrayList<TaskData> tasks) throws IOException {
		logger.log(Level.INFO, "Attempting to save tasks");
		assert tasks != null;

		return taskControl.save(tasks);
	}

	public ArrayList<TaskData> loadTasks() throws IOException {
		logger.log(Level.INFO, "Attempting to load tasks");
		ArrayList<TaskData> taskList = taskControl.load();
		assert taskList != null;

		return taskList;

	}

	public boolean saveCategory(ArrayList<CategoryData> categories) throws IOException {
		assert categories != null;
		return categoryControl.save(categories);
	}

	public ArrayList<CategoryData> loadCategory() throws IOException {
		ArrayList<CategoryData> categories = categoryControl.load();
		assert categories != null;

		return categories;
	}

	private String[] loadPreferences(String configFilePath) throws IOException {
		File configFile = new File(configFilePath);
		String[] preferences = new String[PREFERENCES_SIZE];
		if (configFile.exists()) {
			BufferedReader bReader = new BufferedReader(new FileReader(configFile));
			for (int i = 0; i < PREFERENCES_SIZE; i++) {
				preferences[i] = bReader.readLine();
			}
			bReader.close();
		}

		if (isInvalidPath(preferences[TASK_DESTINATION], TXT)) {
			preferences[TASK_DESTINATION] = Constants.DEFAULT_TASKS_DESTINATION;
		}
		if (isInvalidPath(preferences[THEME_DESTINATION], CSS)) {
			preferences[THEME_DESTINATION] = Constants.DEFAULT_THEME_DESTINATION;
		}

		modifyConfig(preferences);

		return preferences;
	}

	private boolean isValidPath(String filePath) throws IncorrectInputException {
		if (!filePath.endsWith(TXT)) {
			String errorMessage = String.format(ERROR_MESSAGE_FILEPATH, filePath);
			throw new IncorrectInputException(errorMessage);
		}

		return true;
	}

	private boolean isInvalidPath(String filePath, String fileType) {
		if (filePath == null || !filePath.endsWith(fileType)) {
			return true;
		}
		return false;
	}

	public String getFilePath() {
		return preferences[TASK_DESTINATION];
	}

	public String[] getPreferences() {
		return this.preferences;
	}

	private void modifyConfig(String[] preferences) throws IOException {
		File configFile = new File(configFilePath);
		FileWriter fileWriter = null;
		try {
			fileWriter = new FileWriter(configFile);
		} catch (IOException e) {
			throw new IOException("Error: Cannot open config");
		}

		assert fileWriter != null;
		BufferedWriter bWriter = new BufferedWriter(fileWriter);
		for (String path : preferences) {
			bWriter.append(path);
			bWriter.newLine();
		}
		bWriter.close();
	}
}
```
###### test\dooyit\logic\commands\DeleteCategoryCommandTest.java
``` java
package dooyit.logic.commands;

import static org.junit.Assert.*;

import org.junit.Before;
import org.junit.Test;

import dooyit.common.datatype.Category;
import dooyit.common.datatype.CustomColor;
import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.api.LogicController;

public class DeleteCategoryCommandTest {
	LogicController logic;
	DeleteCategoryCommand deleteCatCommand;
	
	@Before
	public void setUp() {
		logic = new LogicController();
		logic.disableSave();
		logic.clearTask();
	}
	
	@Test
	public void execute_ContainsCategory_ExpectedPass() {
		logic.clearCategory();
		Category personal = new Category("Personal", CustomColor.RED);
		Category assignments = new Category("Assignments", CustomColor.GREEN);
		logic.addCategory(personal);
		logic.addCategory(assignments);
		deleteCatCommand = new DeleteCategoryCommand("Personal");
		deleteCatCommand.execute(logic);
		assertFalse(logic.containsCategory("Personal"));
	}
	
	@Test (expected = IncorrectInputException.class)
	public void execute_MissingCategory_IncorrectInputException() {
		logic.clearCategory();
		deleteCatCommand = new DeleteCategoryCommand("Personal");
		deleteCatCommand.execute(logic);
	}
	
	
}
```
###### test\dooyit\logic\TaskManagerTest.java
``` java
	@Test
	public void GetSize() {
		taskManager.clear();
		assertEquals(0, taskManager.size());
	}
	
	@Test
	public void GetTaskWithCat() {
		taskManager.clear();
		ArrayList<Task> tasks = new ArrayList<Task> ();	
		Category category = new Category("Personal", CustomColor.BLUE);
		
		Task task1 = (Task) new FloatingTask("Buy milk");
		task1.setCategory(category);
		tasks.add(task1);
			
		Task task2 = (Task) new FloatingTask("Go gym");
		task2.setCategory(category);
		tasks.add(task2);
		
		taskManager.add(task1);
		taskManager.add(task2);
		
		ArrayList<Task> expectedTasks = taskManager.getTasksWithCategory(category);
		
		assertTrue(expectedTasks.equals(tasks));	
	}
	
	@Test
	public void GetIncompletedTask() {
		setupTasks();
		
		ArrayList<Task> tasks = new ArrayList<Task> ();
		tasks.add(task1);
		tasks.add(task2);
		tasks.add(task6);
		
		assertTrue(tasks.equals(taskManager.getIncompletedTasks()));
	}
	
	@Test
	public void GetCompletedTasks() {
		setupTasks();
		
		ArrayList<Task> tasks = new ArrayList<Task> ();
		tasks.add(task3);
		tasks.add(task4);
		tasks.add(task5);
		
		assertTrue(tasks.equals(taskManager.getCompletedTasks()));
	}
	
	@Test
	public void GetEventTasks() {
		setupTasks();
		
		ArrayList<Task> tasks = new ArrayList<Task> ();
		tasks.add(task1);
		tasks.add(task4);
		
		assertTrue(tasks.equals(taskManager.getEventTasks()));
	}
	
	@Test
	public void GetIncompletedEventTask() {
		setupTasks();
		
		ArrayList<Task> tasks = new ArrayList<Task> ();
		tasks.add(task1);
		
		assertTrue(tasks.equals(taskManager.getIncompleteEventTasks()));
	}
	
	@Test
	public void GetIncompleteEventTasksToday() {
		setupTasks();
		
		ArrayList<Task> tasks = new ArrayList<Task> ();
		
		DateTime dateTime = new DateTime();
		tasks.add(task1);
		
		assertTrue(tasks.equals(taskManager.getIncompleteEventTasks(dateTime)));
	}
	
	@Test
	public void GetEventTasksToday() {
		setupTasks();
		
		ArrayList<Task> tasks = new ArrayList<Task> ();
		
		DateTime dateTime = new DateTime();
		tasks.add(task1);
		tasks.add(task4);
		
		assertTrue(tasks.equals(taskManager.getEventTasks(dateTime)));
	}
	
	@Test
	public void GetDeadlineTasks() {
		setupTasks();
		
		ArrayList<Task> tasks = new ArrayList<Task> ();
		tasks.add(task3);
		tasks.add(task6);
		
		assertTrue(tasks.equals(taskManager.getDeadlineTasks()));
	}
	
	
	@Test
	public void GetIncompleteDeadlineTask() {
		setupTasks();
		
		ArrayList<Task> tasks = new ArrayList<Task> ();
		tasks.add(task6);
		ArrayList<Task> expectedTasks = taskManager.getIncompleteDeadlineTasks();
		assertTrue(tasks.equals(expectedTasks));
		
		tasks.add(task3);
		assertFalse(tasks.equals(expectedTasks));
	}
	
	@Test
	public void GetIncompleteDeadlineTaskToday() {
		setupTasks();
		
		ArrayList<Task> tasks = new ArrayList<Task> ();
		tasks.add(task6);
		DateTime dateTime = new DateTime();
		ArrayList<Task> expectedTasks = taskManager.getIncompleteDeadlineTasks(dateTime);
		assertTrue(tasks.equals(expectedTasks));
		
		tasks.add(task3);
		assertFalse(tasks.equals(expectedTasks));
	}
	
	@Test
	public void GetFloatingTasks() {
		setupTasks();
		
		ArrayList<Task> tasks = new ArrayList<Task> ();
		tasks.add(task2);
		tasks.add(task5);
		
		assertTrue(tasks.equals(taskManager.getFloatingTasks()));
	}
	
	@Test
	public void GetIncompleteFloatingTasks() {
		setupTasks();
		
		ArrayList<Task> tasks = new ArrayList<Task> ();
		tasks.add(task2);
		
		assertTrue(tasks.equals(taskManager.getIncompleteFloatingTasks()));
	}
	
	@Test
	public void SortTasks() {
		setupTasks();

		taskManager.sortTask(taskManager.getAllTasks());
		ArrayList<Task> tasks = new ArrayList<Task> ();
		tasks.add(task1);
		tasks.add(task3);
		tasks.add(task4);
		tasks.add(task6);
		tasks.add(task2);
		tasks.add(task5);
		
		assertTrue(tasks.equals(taskManager.getAllTasks()));
	}
	
	@Test
	public void MarkTask_MarkWithIncompleteTaskObject() {
		setupTasks();
		
		ArrayList<Task> tasks = taskManager.getIncompleteDeadlineTasks();
		assertEquals(1, tasks.size());
		taskManager.markTask(tasks.get(0));
		tasks = taskManager.getIncompleteDeadlineTasks();
		assertEquals(0, tasks.size());
	}
	
	@Test
	public void UnmarkTask_UnmarkWithCompletedTaskObject() {
		setupTasks();
		
		ArrayList<Task> tasks = taskManager.getCompletedTasks();
		assertEquals(3, tasks.size());
		taskManager.unmarkTask(tasks.get(0));
		tasks = taskManager.getCompletedTasks();
		assertEquals(2, tasks.size());
	}
	
	@Test
	public void RemoveTasksWithCategory() {
		setupTasks();
		
		ArrayList<Task> allTasks = taskManager.getAllTasks();
		Category personal = new Category("Personal", CustomColor.BLUE);
		Task task1 = allTasks.get(0);
		task1.setCategory(personal);
		
		ArrayList<Task> removedTasks = taskManager.removeTasksWithCategory(personal);
		assertEquals(1, removedTasks.size());
	}
	
	@Test
	public void GetOverDueTasks() {
		setupTasks();
		int[] date = {20, 10, 2016};
		DateTime overdue = new DateTime(date, 800);
		
		ArrayList<Task> expectedOverdue = new ArrayList<Task> ();
		expectedOverdue.add(task1);
		expectedOverdue.add(task6);
		ArrayList<Task> overdueTasks = taskManager.getOverdueTasks(overdue);
		assertTrue(expectedOverdue.equals(overdueTasks));
		assertEquals(expectedOverdue.size(), taskManager.getOverdueTasksSize(overdue));
	}
}
```
