# A0124586Y
###### src\dooyit\common\datatype\DeadlineTaskData.java
``` java
package dooyit.common.datatype;

public class DeadlineTaskData extends TaskData {
	private DateTime dateTimeDeadline;

	public DeadlineTaskData(String name, DateTime deadline, boolean isCompleted) {
		this.taskName = name;
		this.dateTimeDeadline = deadline;
		this.isCompleted = isCompleted;
	}
	
	public DeadlineTaskData(String name, DateTime deadline,
							String category, boolean isCompleted) {
		this(name, deadline, isCompleted);
		this.category = category;
}
	
	public DateTime getDeadline() {
		return this.dateTimeDeadline;
	}
	
	@Override
	public boolean equals(Object o) {
		boolean isEquals = false;

		if (o instanceof DeadlineTaskData) {
			DeadlineTaskData data = (DeadlineTaskData) o;

			isEquals = this.taskName.equals(data.getName())
					&& this.isCompleted == data.isCompleted()
					&& this.dateTimeDeadline.equals(data.getDeadline());

			if (this.hasCategory() && data.hasCategory()) {
				isEquals = isEquals && this.category.equals(data.getCategory());
			} else if (this.hasCategory() || data.hasCategory()) {
				isEquals = false;
			}
		}

		return isEquals;
	}
	
	@Override
	public Task convertToTask() {
		Task task = new DeadlineTask(taskName, dateTimeDeadline);
		
		if(isCompleted){
			task.mark();
		}
		
		return task;
	}
}
```
###### src\dooyit\common\datatype\EventTaskData.java
``` java
package dooyit.common.datatype;

public class EventTaskData extends TaskData {
	private DateTime dateTimeStart;
	private DateTime dateTimeEnd;

	public EventTaskData(String name, DateTime start, DateTime end,
						boolean isCompleted) {
		this.taskName = name;
		this.dateTimeStart = start;
		this.dateTimeEnd = end;
		this.isCompleted = isCompleted;
	}
	
	public EventTaskData(String name, DateTime start, DateTime end,
						String category, boolean isCompleted) {
		this(name, start, end, isCompleted);
		this.category = category;
	}

	public DateTime getStart() {
		return this.dateTimeStart;
	}

	public DateTime getEnd() {
		return this.dateTimeEnd;
	}
	
	@Override
	public boolean equals(Object o) {
		boolean isEquals = false;

		if (o instanceof EventTaskData) {
			EventTaskData data = (EventTaskData) o;

			isEquals = this.taskName.equals(data.getName())
					&& this.isCompleted == data.isCompleted()
					&& this.dateTimeStart.equals(data.getStart())
					&& this.dateTimeEnd.equals(data.getEnd());

			if (this.hasCategory() && data.hasCategory()) {
				isEquals = isEquals && this.category.equals(data.getCategory());
			} else if (this.hasCategory() || data.hasCategory()) {
				isEquals = false;
			}
		}

		return isEquals;
	}

	@Override
	public Task convertToTask() {
		Task task = new EventTask(taskName, dateTimeStart, dateTimeEnd);

		if (isCompleted) {
			task.mark();
		}

		return task;
	}
}
```
###### src\dooyit\common\datatype\FloatingTaskData.java
``` java
package dooyit.common.datatype;

public class FloatingTaskData extends TaskData {

	public FloatingTaskData(String name, boolean isCompleted) {
		this.taskName = name;
		this.isCompleted = isCompleted;
	}

	public FloatingTaskData(String name, String category, boolean isCompleted) {
		this(name, isCompleted);
		this.category = category;
	}
	
	@Override
	public boolean equals(Object o) {
		boolean isEquals = false;

		if (o instanceof FloatingTaskData) {
			FloatingTaskData data = (FloatingTaskData) o;

			isEquals = this.taskName.equals(data.getName())
					&& this.isCompleted == data.isCompleted();

			if (this.hasCategory() && data.hasCategory()) {
				isEquals = isEquals && this.category.equals(data.getCategory());
			} else if (this.hasCategory() || data.hasCategory()) {
				isEquals = false;
			}
		}

		return isEquals;
	}

	@Override
	public Task convertToTask() {
		Task task = new FloatingTask(taskName);

		if (isCompleted) {
			task.mark();
		}

		return task;
	}
}
```
###### src\dooyit\common\datatype\TaskData.java
``` java
package dooyit.common.datatype;

public abstract class TaskData {
	protected String taskName;
	protected String category;
	protected boolean isCompleted;
	
	public boolean hasCategory(Task task) {
		return task.hasCategory();
	}
	
	public String getCategory() {
		return this.category;
	}
	
	public String getName() {
		return this.taskName;
	}
	
	public boolean isCompleted() {
		return this.isCompleted;
	}
	
	public boolean hasCategory() {
		return category != null;
	}
	
	public abstract Task convertToTask();
}
```
###### src\dooyit\common\utils\OsUtils.java
``` java
package dooyit.common.utils;

public final class OsUtils {
	private static final String OS_NAME = "os.name";
	private static final String WINDOWS = "Windows";
	private static final String MAC = "Mac";
	
	private static String osName = null;

	public static String getOsName() {
		if (osName == null) {
			osName = System.getProperty(OS_NAME);
		}
		return osName;
	}

	public static boolean isWindows() {
		return OsUtils.getOsName().startsWith(WINDOWS);
	}

	public static boolean isMac() {
		return OsUtils.getOsName().startsWith(MAC);
	}
}
```
###### src\dooyit\storage\CategoryController.java
``` java
package dooyit.storage;

import java.io.IOException;
import java.util.ArrayList;

import dooyit.common.datatype.CategoryData;

/**
 * The CategoryController is a facade class for the StorageController to save or
 * load categories
 * 
 * @author Dex
 *
 */
public class CategoryController {
	private CategorySaver categorySaver;
	private CategoryLoader categoryLoader;

	public CategoryController(String path) {
		categoryLoader = new CategoryLoader(path);
		categorySaver = new CategorySaver(path);
	}

	/**
	 * Saves the list of categories.
	 * 
	 * @param tasks
	 *        A list of CategoryData to be saved
	 *        
	 * @return Returns true if categories are saved successfully, otherwise returns
	 *         false
	 *         
	 * @throws IOException
	 *         If the save file cannot be accessed
	 */
	public boolean save(ArrayList<CategoryData> categories) throws IOException {
		return categorySaver.save(categories);
	}

	/**
	 * Loads the list of categories from the save file.
	 * 
	 * @return A list of CategoryData to be loaded
	 * 
	 * @throws IOException
	 *         If loading fails
	 */
	public ArrayList<CategoryData> load() throws IOException {
		return categoryLoader.load();
	}
}
```
###### src\dooyit\storage\CategoryDataDeserializer.java
``` java
package dooyit.storage;

import java.lang.reflect.Type;

import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import dooyit.common.datatype.CategoryData;

/**
 * The CategoryDataDeserializer converts the JSON representation of CategoryData
 * to a CategoryData object.
 * 
 * @author Dex
 *
 */
public class CategoryDataDeserializer implements JsonDeserializer<CategoryData> {
	private static final String CATEGORY_NAME = "name";
	private static final String CATEGORY_COLOR = "color";
	private static final String DEFAULT_NAME = "category";
	private static final String DEFAULT_COLOR = "blue";
	private static int count = 1;

	@Override
	public CategoryData deserialize(JsonElement element, Type arg1, JsonDeserializationContext arg2)
			throws JsonParseException {
		JsonObject object = (JsonObject) element;
		
		String name = DEFAULT_NAME;
		if (object.has(CATEGORY_NAME)) {
			name = object.get(CATEGORY_NAME).getAsString();
		} else {
			//If name field is missing, give it a default name
			name += count++;
		}
		String color = DEFAULT_COLOR;
		if (object.has(CATEGORY_COLOR)) {
			color = object.get(CATEGORY_COLOR).getAsString();
		}
		CategoryData categoryData = new CategoryData(name, color);

		return categoryData;
	}

}
```
###### src\dooyit\storage\CategoryLoader.java
``` java
package dooyit.storage;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonObject;
import com.google.gson.JsonSyntaxException;

import dooyit.common.datatype.CategoryData;

/**
 * The CategoryLoader class contains methods and attributes necessary for
 * loading categories.
 * 
 * @author Dex
 *
 */
public class CategoryLoader extends Loader<CategoryData> {

	private String filePath;
	private Gson gson;

	protected CategoryLoader(String filePath) {
		super();
		this.filePath = filePath;
		this.gson = gsonWithCategoryDataDeserializer();
	}

	/**
	 * Loads CategoryData from the saved file after checking if the file exists.
	 * 
	 * @return An ArrayList of CategoryData
	 * 
	 * @throws IOException
	 *         If unable to read from the file
	 */
	public ArrayList<CategoryData> load() throws IOException {
		File categoryFile = new File(filePath);
		ArrayList<CategoryData> categories = new ArrayList<CategoryData>();

		if (categoryFile.exists()) {
			categories = loadFromFile(categoryFile);
		}
		return categories;
	}

	/**
	 * Loads CategoryData from an existing file.
	 * 
	 * @param file
	 *        File instance of the existing save file
	 *        
	 * @return ArrayList of TaskData from the save file
	 * 
	 * @throws IOException
	 *         If unable to read from the save file
	 */
	private ArrayList<CategoryData> loadFromFile(File file) throws IOException {
		FileReader fReader;
		ArrayList<CategoryData> categories = new ArrayList<CategoryData>();

		fReader = open(file);
		BufferedReader bReader = new BufferedReader(fReader);

		String categoryData = bReader.readLine();
		JsonObject jsonCategory;
		while (categoryData != null) {
			try {
				jsonCategory = getAsJson(categoryData);
			} catch (JsonSyntaxException e) {
				//Null the object if the JSON string is corrupted
				jsonCategory = null;
			}

			if (jsonCategory != null) {
				CategoryData category = resolveCategory(jsonCategory);
				categories.add(category);
			}
			categoryData = bReader.readLine();
		}
		bReader.close();
		fReader.close();

		return categories;
	}
	
	/**
	 * Converts the JSON representation of a category to CategoryData.
	 * 
	 * @param jsonCategory JsonObject of CategoryData
	 * 
	 * @return Returns the CategoryData of the JsonObject
	 */
	private CategoryData resolveCategory(JsonObject jsonCategory) {
		CategoryData category = gson.fromJson(jsonCategory, CategoryData.class);

		return category;
	}

	/**
	 * Registers CategoryDataDataDeserializer when creating Gson object.
	 * 
	 * @return Returns a Gson object with CategoryDataDeserializer
	 */
	private Gson gsonWithCategoryDataDeserializer() {
		return new GsonBuilder().registerTypeAdapter(CategoryData.class, new CategoryDataDeserializer()).create();
	}
}
```
###### src\dooyit\storage\CategorySaver.java
``` java
package dooyit.storage;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;

import com.google.gson.Gson;

import dooyit.common.datatype.CategoryData;

/**
 * The CategorySaver class contains methods and attributes necessary for saving
 * categories.
 * 
 * @author Dex
 *
 */
public class CategorySaver extends Saver<CategoryData> {
	private static final String ERROR_MESSAGE_CATEGORY_SAVING = "Unable to save category data";

	private String filePath;
	private Gson gson;

	protected CategorySaver(String filePath) {
		this.filePath = filePath;
		this.gson = new Gson();
	}

	/**
	 * Saves the list of categories.
	 * 
	 * @param tasks
	 *        An ArrayList of CategoryData to be saved
	 *        
	 * @return Returns true if save is successful, otherwise returns false
	 * 
	 * @throws IOException
	 *         If the saved file cannot be written to
	 */
	boolean save(ArrayList<CategoryData> categories) throws IOException {
		File file = new File(filePath);

		try {
			BufferedWriter bWriter = new BufferedWriter(new FileWriter(file));

			for (CategoryData existingCategory : categories) {
				bWriter.append(setFormat(existingCategory));
				bWriter.newLine();
			}
			bWriter.close();
		} catch (IOException e) {
			throw new IOException(ERROR_MESSAGE_CATEGORY_SAVING);
		}

		return true;
	}

	/**
	 * Converts the Category object to CategoryData before further conversion to
	 * its JSON string.
	 * 
	 * @param category
	 *        The category to be converted
	 *            
	 * @return Returns the JSON string representation of the CategoryData
	 */
	String setFormat(CategoryData category) {
		String categoryName = category.getName();
		String colorName = category.getColor();
		CategoryData categoryFormat = new CategoryData(categoryName, colorName);
		String json = gson.toJson(categoryFormat);

		return json;
	}
}
```
###### src\dooyit\storage\Constants.java
``` java
package dooyit.storage;

import java.io.File;

/**
 * The Constants class holds all the Storage constants which are shared by the
 * various classes in the Storage component
 * 
 * @author Dex
 *
 */
public class Constants {

	// System related constants
	static final char SEPARATOR_CHAR = File.separatorChar;
	static final String CURRENT_DIRECTORY = System.getProperty("user.dir");

	// Default data folder
	static final String FOLDER_DATA = CURRENT_DIRECTORY + SEPARATOR_CHAR + "data" + SEPARATOR_CHAR;

	// Default file paths
	static final String DEFAULT_BACKUP_DESTINATION = FOLDER_DATA + "backup.txt";
	static final String DEFAULT_CATEGORIES_DESTINATION = FOLDER_DATA + "categories.txt";
	static final String DEFAULT_CONFIG_DESTINATION = CURRENT_DIRECTORY + SEPARATOR_CHAR + "config.txt";
	static final String DEFAULT_TASKS_DESTINATION = FOLDER_DATA + "tasks.txt";
	static final String DEFAULT_THEME_DESTINATION = FOLDER_DATA + "custom.css";
	
	// Log Messages
	static final String LOG_STORAGE = "Storage";
	static final String LOG_MSG_INIT_STORAGE = "Initialising Storage";
	static final String LOG_MSG_SAVING_TASKS = "Attempting to save tasks";
	static final String LOG_MSG_LOADING_TASKS ="Attempting to load tasks";
	static final String LOG_MSG_SAVING_CATEGORIES = "Attempting to save categories";
	static final String LOG_MSG_LOADING_CATEGORIES ="Attempting to load categories";
	static final String LOG_MSG_CHANGE_FILE_DESTINATION = "Changing file destination";
	static final String LOG_MSG_GENERATING_CSS = "Attempting to generate CSS";
	static final String LOG_MSG_MODIFYING_CONFIG = "Attempting to modify configurations";

	public Constants() {

	}
}
```
###### src\dooyit\storage\DateTimeDeserializer.java
``` java
package dooyit.storage;

import java.lang.reflect.Type;

import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import dooyit.common.datatype.DateTime;

/**
 * The DateTimeDeserializer converts the JSON representation of DateTime to a
 * DateTime object
 * 
 * @author Dex
 *
 */
public class DateTimeDeserializer implements JsonDeserializer<DateTime>{
	private static final String DATE = "date";
	private static final String TIME = "time";
	private static final int DAY = 0;
	private static final int MONTH = 1;
	private static final int YEAR = 2;

	@Override
	public DateTime deserialize(JsonElement dateTime, Type arg1, JsonDeserializationContext arg2)
			throws JsonParseException {
		JsonObject jsonDateTime = (JsonObject) dateTime;
		String dateString = jsonDateTime.get(DATE).getAsString();
		
		String[] parts = dateString.split(" ");
		int[] date = new int[] { Integer.valueOf(parts[DAY]),
								Integer.valueOf(parts[MONTH]),
								Integer.valueOf(parts[YEAR]) };
		
		int timeInt = jsonDateTime.get(TIME).getAsInt();
		return new DateTime(date, timeInt);
	}

}
```
###### src\dooyit\storage\DateTimeSerializer.java
``` java
package dooyit.storage;

import java.lang.reflect.Type;

import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;

import dooyit.common.datatype.DateTime;

/**
 * The DateTimeSerializer converts the DateTime object to a JSON object
 * 
 * @author Dex
 *
 */
public class DateTimeSerializer implements JsonSerializer<DateTime> {

	private static final String SPACE = " ";
	private static final String DATE = "date";
	private static final String TIME = "time";

	@Override
	public JsonElement serialize(DateTime dt, Type typeOfSrc, JsonSerializationContext context) {
		JsonObject jsonObject = new JsonObject();
		String date = "";
		
		date = dt.getDD() + SPACE + dt.getMM() + SPACE + dt.getYY();
		jsonObject.addProperty(DATE, date);
		
		jsonObject.addProperty(TIME, dt.getTimeInt());
		return jsonObject;
	}

}
```
###### src\dooyit\storage\Loader.java
``` java
package dooyit.storage;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;

import com.google.gson.JsonObject;
import com.google.gson.JsonParser;

public abstract class Loader<T> {
	private static final String ERROR_MESSAGE_FILE_MISSING = "Unable to find %1$s";
	private static final String EMPTY_STRING = "";
	
	private JsonParser parser;
	
	public Loader() {
		this.parser = new JsonParser();
		
	}
	
	protected abstract ArrayList<T> load() throws IOException;

	/**
	 * Creates a new FileReader given the File to read from
	 * 
	 * @param file
	 *        File to read from.
	 *        
	 * @return FileReader instance of the File to read from.
	 * 
	 * @throws FileNotFoundException
	 *         If the file is not found.
	 */
	FileReader open(File file) throws FileNotFoundException {
		FileReader fReader = null;
		if (file.exists()) {
			try {
				fReader = new FileReader(file);
			} catch (FileNotFoundException e) {
				throw new FileNotFoundException(String.format(ERROR_MESSAGE_FILE_MISSING, file.getName()));
			}
		}
		return fReader;
	}
	
	/**
	 * Converts the Json String to a JsonObject.
	 * 
	 * @param format
	 *        The String representation of the JsonObject.
	 *        
	 * @return JsonObject from String representation if it is not an empty
	 *         string. Otherwise return null.
	 */
	JsonObject getAsJson(String format) {
		JsonObject object = null;

		if (!format.equals(EMPTY_STRING)) {
			object = parser.parse(format).getAsJsonObject();
		}

		return object;
	}
}
```
###### src\dooyit\storage\Saver.java
``` java
package dooyit.storage;

import java.io.IOException;
import java.util.ArrayList;

public abstract class Saver<T> {
	abstract boolean save(ArrayList<T> t) throws IOException;
}
```
###### src\dooyit\storage\StorageController.java
``` java
package dooyit.storage;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URL;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

import dooyit.common.datatype.CategoryData;
import dooyit.common.datatype.TaskData;
import dooyit.common.exception.IncorrectInputException;
import dooyit.common.utils.OsUtils;

/**
 * The StorageController class provides methods and attributes necessary for
 * loading and saving categories, tasks and custom css. It also contains methods
 * to change the storage location and save the user's preferences
 * 
 * @author Dex
 *
 */
public class StorageController {

	// Path related constants
	private static final String CSS = ".css";
	private static final String TXT = ".txt";
	private static final String FORWARD_SLASH = "/";
	private static final String BACK_SLASH = "\\";;

	// Error Messages
	private static final String ERROR_MESSAGE_FILEPATH = "INVALID path. Path needs to end with %1$s";
	private static final String ERROR_MESSAGE_ACCESS_CONFIG = "Cannot access configurations";
	private static final String ERROR_MESSAGE_LOAD_CSS = "Unable to load custom css";

	// Preferences related constants
	private static final int TASK_DESTINATION = 0;
	private static final int THEME_DESTINATION = 1;
	private static final int PREFERENCES_SIZE = 2;

	private String configFilePath;
	private String[] preferences;
	private CategoryController categoryControl;
	private TaskController taskControl;
	private static Logger logger = Logger.getLogger(Constants.LOG_STORAGE);

	public StorageController() throws IOException {
		logger.log(Level.INFO, Constants.LOG_MSG_INIT_STORAGE);
		
		configFilePath = Constants.DEFAULT_CONFIG_DESTINATION;
		preferences = loadPreferences(configFilePath);
		categoryControl = new CategoryController(Constants.DEFAULT_CATEGORIES_DESTINATION);
		taskControl = new TaskController(preferences[TASK_DESTINATION]);
	}

	/**
	 * Saves the existing tasks.
	 * 
	 * @param categories
	 *        ArrayList of TaskData
	 *        
	 * @return Returns true if save is successful
	 * 
	 * @throws IOException
	 *         If saving fails
	 */
	public boolean saveTasks(ArrayList<TaskData> tasks) throws IOException {
		logger.log(Level.INFO, Constants.LOG_MSG_SAVING_TASKS);
		assert tasks != null;

		return taskControl.save(tasks);
	}

	/**
	 * Loads the existing tasks.
	 * 
	 * @return Returns true if the load is successful
	 * 
	 * @throws IOException
	 *         If loading fails
	 */
	public ArrayList<TaskData> loadTasks() throws IOException {
		logger.log(Level.INFO, Constants.LOG_MSG_LOADING_TASKS);
		ArrayList<TaskData> taskList = taskControl.load();
		assert taskList != null;

		return taskList;
	}

	/**
	 * Saves the existing categories.
	 * 
	 * @param categories
	 *        ArrayList of CategoryData
	 *            
	 * @return Returns true if save is successful
	 * 
	 * @throws IOException
	 *         If saving fails
	 */
	public boolean saveCategories(ArrayList<CategoryData> categories) throws IOException {
		logger.log(Level.INFO, Constants.LOG_MSG_SAVING_CATEGORIES);
		assert categories != null;
		return categoryControl.save(categories);
	}

	/**
	 * Loads the existing categories.
	 * 
	 * @return Returns true if the load is successful
	 * 
	 * @throws IOException
	 *         If loading fails
	 */
	public ArrayList<CategoryData> loadCategories() throws IOException {
		logger.log(Level.INFO, Constants.LOG_MSG_LOADING_CATEGORIES);
		ArrayList<CategoryData> categories = categoryControl.load();
		assert categories != null;

		return categories;
	}
	
	/**
	 * Sets a new storage location.
	 * 
	 * @param newFilePath
	 *        The new storage location
	 *            
	 * @return If the file exists, returns true. Otherwise returns false
	 * 
	 * @throws IOException
	 *         If unable to modify the config file
	 */
	public boolean setFileDestination(String newFilePath) throws IOException {
		logger.log(Level.INFO, Constants.LOG_MSG_CHANGE_FILE_DESTINATION);

		if (isValidPath(newFilePath, TXT)) {
			preferences[TASK_DESTINATION] = newFilePath;
			modifyConfig(preferences);
			taskControl.setFileDestination(newFilePath);
			File file = new File(newFilePath);
			if (file.exists()) {
				return true;
			}
		}

		return false;
	}

	/**
	 * Checks if the path specified ends with the file extension required.
	 * 
	 * @param path
	 *        The specified path
	 *        
	 * @param fileExtension
	 *        The file extension
	 *            
	 * @return Returns true if the path is valid
	 * 
	 * @throws IncorrectInputException
	 *         If the path is invalid
	 */
	private boolean isValidPath(String path, String fileExtension) throws IncorrectInputException {
		if (!path.endsWith(fileExtension)) {
			String errorMessage = String.format(ERROR_MESSAGE_FILEPATH, fileExtension);
			throw new IncorrectInputException(errorMessage);
		}

		return true;
	}

	/**
	 * Generates the default custom.css file if it does not exist.
	 * 
	 * @param path
	 *        URL representation of the path to the default custom css file
	 *        inside the JAR
	 *        
	 * @throws IOException
	 *         If unable to generate the css file
	 */
	public void generateCss(URL path) throws IOException {
		String defaultPath = preferences[THEME_DESTINATION];

		File file = new File(defaultPath);
		if (!file.exists()) {
			logger.log(Level.INFO, Constants.LOG_MSG_GENERATING_CSS);
			try {
				InputStream inputStream = path.openStream();
				BufferedReader bReader = new BufferedReader(new InputStreamReader(inputStream));
				BufferedWriter bWriter = new BufferedWriter(new FileWriter(defaultPath));
				copy(bReader, bWriter);
			} catch (IOException e) {
				throw new IOException(ERROR_MESSAGE_LOAD_CSS);
			}
		}
	}

	private void copy(BufferedReader reader, BufferedWriter writer) throws IOException {
		String line = reader.readLine();
		while (line != null) {
			writer.append(line);
			writer.newLine();
			line = reader.readLine();
		}
		reader.close();
		writer.close();
	}

	/**
	 * Loads the user's preferences from the config file and sets any invalid
	 * paths to the default.
	 * 
	 * @param configFilePath
	 *        The path to the config file
	 *        
	 * @return The preferences of the user
	 * 
	 * @throws IOException
	 *         If unable to access the config file
	 */
	private String[] loadPreferences(String configFilePath) throws IOException {
		File configFile = new File(configFilePath);
		String[] preferences = new String[PREFERENCES_SIZE];
		if (configFile.exists()) {
			try {
				BufferedReader bReader = new BufferedReader(new FileReader(configFile));
				for (int i = 0; i < PREFERENCES_SIZE; i++) {
					preferences[i] = bReader.readLine();
				}
				bReader.close();
			} catch (IOException e) {
				throw new IOException(ERROR_MESSAGE_ACCESS_CONFIG);
			}
		}

		if (isInvalidPath(preferences[TASK_DESTINATION], TXT)) {
			preferences[TASK_DESTINATION] = Constants.DEFAULT_TASKS_DESTINATION;
		}
		if (isInvalidPath(preferences[THEME_DESTINATION], CSS)) {
			preferences[THEME_DESTINATION] = Constants.DEFAULT_THEME_DESTINATION;
		}

		modifyConfig(preferences);

		return preferences;
	}

	/**
	 * Checks if the specified path is invalid.
	 * 
	 * @param filePath
	 *        The specified path
	 *        
	 * @param fileExtension
	 *        The required file extension
	 *            
	 * @return Returns true if the path is invalid, otherwise returns false
	 */
	private boolean isInvalidPath(String filePath, String fileExtension) {
		if (filePath == null || !filePath.endsWith(fileExtension)) {
			return true;
		}
		return false;
	}

	/**
	 * Modifies the config file with the updated preferences.
	 * 
	 * @param preferences
	 *        The preferences containing the save path and the location of
	 *        custom.css
	 *            
	 * @throws IOException
	 *         If unable to write to the config file
	 */
	private void modifyConfig(String[] preferences) throws IOException {
		logger.log(Level.INFO, Constants.LOG_MSG_MODIFYING_CONFIG);
		File configFile = new File(configFilePath);
		FileWriter fileWriter = null;
		try {
			fileWriter = new FileWriter(configFile);
		} catch (IOException e) {
			throw new IOException(ERROR_MESSAGE_ACCESS_CONFIG);
		}

		assert fileWriter != null;
		BufferedWriter bWriter = new BufferedWriter(fileWriter);
		for (String path : preferences) {
			bWriter.append(path);
			bWriter.newLine();
		}
		bWriter.close();
	}
	
	//*****************************
	//******** Get methods ********
	//*****************************
	
	/**
	 * Returns the default css path in a standardised format.
	 * 
	 * @return The String representation of the default css path
	 */
	public String getCssPath() {
		String cssPath = preferences[THEME_DESTINATION].replace(BACK_SLASH, FORWARD_SLASH);

		if (OsUtils.isWindows()) {
			// Prepend "/" to Windows file path since Mac file system has "/"
			// for root
			cssPath = FORWARD_SLASH + cssPath;
		}

		return cssPath;
	}

	/**
	 * Returns the path of the save file for tasks.
	 * 
	 * @return Returns the tasks save path in String representation
	 */
	public String getFilePath() {
		return preferences[TASK_DESTINATION];
	}
}
```
###### src\dooyit\storage\TaskController.java
``` java
package dooyit.storage;

import java.io.IOException;
import java.util.ArrayList;

import dooyit.common.datatype.TaskData;

/**
 * The TaskController is a facade class for the StorageController to save or
 * load tasks
 * 
 * @author Dex
 *
 */
public class TaskController {
	private TaskSaver taskSaver;
	private TaskLoader taskLoader;

	public TaskController(String filePath) {
		taskLoader = new TaskLoader(filePath);
		taskSaver = new TaskSaver(filePath);
	}

	/**
	 * Updates the path which tasks will be saved and loaded
	 * 
	 * @param newFilePath
	 *        The new path for saving and loading
	 */
	protected void setFileDestination(String newFilePath) {
		taskSaver.setFileDestination(newFilePath);
		taskLoader.setFileDestination(newFilePath);
	}

	/**
	 * Saves the list of tasks
	 * 
	 * @param tasks
	 *        A list of TaskData to be saved
	 *        
	 * @return Returns true if tasks are saved successfully, otherwise returns
	 *         false
	 *         
	 * @throws IOException
	 *         If the save file cannot be accessed
	 */
	protected boolean save(ArrayList<TaskData> tasks) throws IOException {
		return taskSaver.save(tasks);
	}

	/**
	 * Loads the list of tasks from the save file
	 * 
	 * @return A list of TaskData to be loaded
	 * 
	 * @throws IOException
	 *         If loading fails
	 */
	protected ArrayList<TaskData> load() throws IOException {
		return taskLoader.load();
	}
}
```
###### src\dooyit\storage\TaskDataDeserializer.java
``` java
package dooyit.storage;

import java.lang.reflect.Type;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import dooyit.common.datatype.DateTime;
import dooyit.common.datatype.DeadlineTaskData;
import dooyit.common.datatype.EventTaskData;
import dooyit.common.datatype.FloatingTaskData;
import dooyit.common.datatype.TaskData;

/**
 * The TaskDataDeserializer creates the TaskData object from its JSON
 * representation for loading
 * 
 * @author Dex
 *
 */
public class TaskDataDeserializer implements JsonDeserializer<TaskData> {

	//Attribute names of TaskData types
	private static final String DEADLINE = "dateTimeDeadline";
	private static final String EVENT_START = "dateTimeStart";
	private static final String EVENT_END = "dateTimeEnd";
	private static final String NAME = "taskName";
	private static final String CATEGORY = "category";
	private static final String IS_COMPLETED = "isCompleted";
	
	private static final String DEFAULT_NAME = "task ";
	
	private static int count = 1;
	
	@Override
	public TaskData deserialize(JsonElement object, Type arg1, JsonDeserializationContext arg2)
			throws JsonParseException {
		TaskData task = null;
		JsonObject jsonTask = (JsonObject) object;

		String name = getName(jsonTask);
		boolean isCompleted = isCompleted(jsonTask);
		String categoryName = getCategoryName(jsonTask);

		if (jsonTask.has(DEADLINE)) {
			DateTime deadline = resolveDateTime(jsonTask, DEADLINE);
			task = (TaskData) new DeadlineTaskData(name, deadline, categoryName, isCompleted);
		} else if (jsonTask.has(EVENT_START) && jsonTask.has(EVENT_END)) {
			DateTime eventStart = resolveDateTime(jsonTask, EVENT_START);
			DateTime eventEnd = resolveDateTime(jsonTask, EVENT_END);
			task = (TaskData) new EventTaskData(name, eventStart, eventEnd, categoryName, isCompleted);
		} else {
			task = (TaskData) new FloatingTaskData(name, categoryName, isCompleted);
		}

		return task;
	}

	/**
	 * Checks if the task has been completed.
	 * 
	 * @param jsonTask The JSON representation of TaskData
	 * 
	 * @return The boolean value of isCompleted
	 */
	private boolean isCompleted(JsonObject jsonTask) {
		boolean isCompleted = false;

		if (jsonTask.has(IS_COMPLETED)) {
			isCompleted = jsonTask.get(IS_COMPLETED).getAsBoolean();
		}
		return isCompleted;
	}

	/**
	 * Gets the name of the task from the JSON representation of TaskData.
	 * 
	 * @param jsonTask The JSON representation of TaskData
	 * 
	 * @return The name of the task
	 */
	private String getName(JsonObject jsonTask) {
		String name = DEFAULT_NAME;

		if (jsonTask.has(NAME)) {
			name = jsonTask.get(NAME).getAsString();
		} else {
			name += count++;
		}

		return name;
	}
	
	/**
	 * Gets the name of the category which the task is assigned to.
	 * 
	 * @param jsonTask
	 *        The JSON representation of TaskData
	 * 
	 * @return The category name which the task is assigned to
	 */
	private String getCategoryName(JsonObject jsonTask) {
		String categoryName = null;
		if (jsonTask.has(CATEGORY)) {
			categoryName = jsonTask.get(CATEGORY).getAsString();
		}

		return categoryName;
	}
	
	/**
	 * Creates a DateTime object from its JSON representation.
	 * 
	 * @param jsonTask
	 *        The JSON representation of the TaskData
	 * 
	 * @param type
	 *        The type of DateTime - deadline, start time or end time
	 * 
	 * @return The DateTime object of the JSON representation
	 */
	private DateTime resolveDateTime(JsonObject jsonTask, String type) {
		Gson gson = gsonWithDateTimeDeserializer();
		JsonObject dateTimeJson = jsonTask.get(type).getAsJsonObject();
		DateTime dateTime = gson.fromJson(dateTimeJson, DateTime.class);

		return dateTime;
	}
	
	/**
	 * Registers DateTimeDeserializer when creating Gson object.
	 * 
	 * @return Gson object with DateTimeDeserializer
	 */
	private Gson gsonWithDateTimeDeserializer() {
		return new GsonBuilder().registerTypeAdapter(DateTime.class, new DateTimeDeserializer()).create();
	}
}
```
###### src\dooyit\storage\TaskLoader.java
``` java
package dooyit.storage;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonObject;
import com.google.gson.JsonSyntaxException;

import dooyit.common.datatype.TaskData;

/**
 * The TaskLoader class contains methods and attributes necessary for loading
 * tasks.
 * 
 * @author Dex
 */
public class TaskLoader extends Loader<TaskData> {
	private static final String ERROR_MESSAGE_LOAD = "Unable to load";
	private static final String ERROR_MESSAGE_FILE_CREATION = "Failed to create %1$s";

	private String filePath;
	private Gson gson;

	TaskLoader(String filePath) {
		super();
		this.filePath = filePath;
		this.gson = gsonWithTaskDataDeserializer();
	}

	/**
	 * Loads TaskData from the saved file after checking if the file exists.
	 * 
	 * @return An ArrayList of TaskData
	 * 
	 * @throws IOException
	 *         If unable to generate missing save file or unable to read
	 *         from the file
	 */
	protected ArrayList<TaskData> load() throws IOException {
		File file = new File(filePath);
		File directory = file.getParentFile();
		ArrayList<TaskData> taskList = new ArrayList<TaskData>();

		if (file.exists()) {
			taskList = loadFromFile(file);
		} else if (directory.exists()) {
			// create the file before finishing load
			createFile(file);
		} else {
			// create parent directories and file before finishing load
			createFile(directory, file);
		}

		return taskList;
	}

	/**
	 * Replaces the current filePath with path.
	 * 
	 * @param path
	 *        String representation of the save file path
	 */
	protected void setFileDestination(String path) {
		this.filePath = path;
	}

	/**
	 * Creates the save file.
	 * 
	 * @param file
	 *        File instance of save file
	 *        
	 * @throws IOException
	 *         If unable to create file
	 */
	private void createFile(File file) throws IOException {
		try {
			file.createNewFile();
		} catch (IOException e) {
			String errorMessage = String.format(ERROR_MESSAGE_FILE_CREATION, file.getName());
			throw new IOException(errorMessage);
		}
	}

	/**
	 * Creates the parent directories before creating the file.
	 * 
	 * @param parent
	 *        File instance of the parent directories
	 *        
	 * @param file
	 *        File instance of the save file
	 *        
	 * @throws IOException
	 *         If unable to create file
	 */
	private void createFile(File parent, File file) throws IOException {
		parent.mkdirs();
		createFile(file);
	}

	/**
	 * Loads TaskData from an existing file.
	 * 
	 * @param file
	 *        File instance of the existing save file
	 *        
	 * @return ArrayList of TaskData from the save file
	 * 
	 * @throws IOException
	 *         If unable to read from the save file
	 */
	private ArrayList<TaskData> loadFromFile(File file) throws IOException {
		FileReader fReader = open(file);
		BufferedReader bReader = new BufferedReader(fReader);
		ArrayList<TaskData> taskList = new ArrayList<TaskData>();
		String taskInfo;
		JsonObject jsonTask;
		
		try {
			taskInfo = bReader.readLine();
		} catch (IOException e) {
			throw new IOException(ERROR_MESSAGE_LOAD);
		}

		while (taskInfo != null) {
			try {
				jsonTask = getAsJson(taskInfo);
			} catch (JsonSyntaxException e) {
				//Null the object if the JSON string is corrupted
				jsonTask = null;
			}	
			if (jsonTask != null) {
				TaskData existingTask = gson.fromJson(jsonTask, TaskData.class);
				taskList.add(existingTask);
			}
			taskInfo = bReader.readLine();
		}
		bReader.close();

		return taskList;
	}

	/**
	 * Registers TaskDataDeserializer when creating Gson object.
	 * 
	 * @return Gson object with registered TaskDataDeserializer
	 */
	private Gson gsonWithTaskDataDeserializer() {
		return new GsonBuilder().registerTypeAdapter(TaskData.class, new TaskDataDeserializer()).create();
	}
}
```
###### src\dooyit\storage\TaskSaver.java
``` java
package dooyit.storage;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import dooyit.common.datatype.DateTime;
import dooyit.common.datatype.DeadlineTaskData;
import dooyit.common.datatype.EventTaskData;
import dooyit.common.datatype.FloatingTaskData;
import dooyit.common.datatype.TaskData;

/**
 * The TaskSaver class contains methods and attributes necessary for saving
 * tasks.
 * 
 * @author Dex
 *
 */
public class TaskSaver extends Saver<TaskData> {
	private static final int BACKUP_LIMIT = 5;

	// Error Messages
	private static final String ERROR_MESSAGE_TASK_SAVING = "Unable to save task data";

	private static final String EMPTY_STRING = "";

	private String filePath;
	private Gson gson;

	//Backup counter
	private static int count = 0;

	protected TaskSaver(String filePath) {
		this.filePath = filePath;
		this.gson = gsonWithDateTimeSerializer();
	}

	/**
	 * Creates the directories if necessary before saving the list of tasks.
	 * 
	 * @param tasks
	 *        An ArrayList of TaskData to be saved
	 *        
	 * @return Returns true if save is successful, otherwise returns false
	 * 
	 * @throws IOException
	 *         If the saved file cannot be written or failure to create save
	 *         file
	 */
	boolean save(ArrayList<TaskData> tasks) throws IOException {
		File file = new File(filePath);
		boolean isSaved = false;

		try {
			isSaved = saveToFile(file, tasks);
		} catch (IOException e) {
			throw new IOException(ERROR_MESSAGE_TASK_SAVING);
		}

		return isSaved;
	}

	/**
	 * Writes the list of TaskData into the File specified. A backup is also
	 * saved when count exceeds the limit.
	 * 
	 * @param file
	 *        The File specified by the filePath
	 *        
	 * @param tasks
	 *        The list of TaskData
	 *        
	 * @return Returns true if the save is successful, otherwise returns false
	 * 
	 * @throws IOException
	 *         If unable to write to save file.
	 */
	private boolean saveToFile(File file, ArrayList<TaskData> tasks) throws IOException {
		BufferedWriter bWriter = new BufferedWriter(new FileWriter(file));

		for (TaskData existingTask : tasks) {
			bWriter.append(setFormat(existingTask));
			bWriter.newLine();
		}
		bWriter.close();
		count++;

		if (count > BACKUP_LIMIT) {
			saveBackup(tasks);
			count = 0;
		}

		return true;
	}

	/**
	 * Saves a backup of the list of tasks.
	 * 
	 * @param tasks
	 *        The list of tasks to be saved
	 * @throws IOException
	 *         If unable to write to the backup file
	 */
	private void saveBackup(ArrayList<TaskData> tasks) throws IOException {
		File backupFile = new File(Constants.DEFAULT_BACKUP_DESTINATION);
		BufferedWriter bWriter = new BufferedWriter(new FileWriter(backupFile));

		for (TaskData existingTask : tasks) {
			bWriter.append(setFormat(existingTask));
			bWriter.newLine();
		}
		bWriter.close();
	}

	/**
	 * Updates the file path for saving.
	 * 
	 * @param path
	 *        The new file path for saving
	 */
	protected void setFileDestination(String path) {
		this.filePath = path;
	}

	/**
	 * Converts a TaskData object to its specific TaskData type before
	 * further conversion to a JSON string.
	 * 
	 * @param task
	 *        The task to be converted
	 *        
	 * @return The JSON string representation of the TaskData
	 */
	String setFormat(TaskData task) {
		String json = EMPTY_STRING;

		if (task instanceof DeadlineTaskData) {
			DeadlineTaskData deadline = (DeadlineTaskData) task;
			json = gson.toJson(deadline);
		} else if (task instanceof EventTaskData) {
			EventTaskData event = (EventTaskData) task;
			json = gson.toJson(event);
		} else {
			FloatingTaskData floatData = (FloatingTaskData) task;
			json = gson.toJson(floatData);
		}

		return json;
	}

	/**
	 * Registers DateTimeSerializer when creating Gson object.
	 * 
	 * @return Gson object with DateTimeSerializer
	 */
	private Gson gsonWithDateTimeSerializer() {
		return new GsonBuilder().registerTypeAdapter(DateTime.class, new DateTimeSerializer()).create();
	}
}
```
###### test\dooyit\logic\commands\DeleteCategoryCommandTest.java
``` java
package dooyit.logic.commands;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;

import org.junit.Before;
import org.junit.Test;
import org.powermock.reflect.Whitebox;

import dooyit.common.datatype.Category;
import dooyit.common.datatype.CustomColour;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class DeleteCategoryCommandTest {
	private static final String ACTION = "action";

	LogicController logic;
	DeleteCategoryCommand deleteCatCommand;

	@Before
	public void setUp() {
		logic = new LogicController();
		logic.disableSave();
		logic.clearTasks();
	}

	@Test
	public void execute_ContainsCategory_ExpectedPass() {
		logic.clearCategory();
		Category personal = new Category("Personal", CustomColour.RED);
		Category assignments = new Category("Assignments", CustomColour.GREEN);
		logic.addCategory(personal);
		logic.addCategory(assignments);
		deleteCatCommand = new DeleteCategoryCommand("Personal");
		deleteCatCommand.execute(logic);
		assertFalse(logic.containsCategory("Personal"));
	}

	@Test
	public void execute_MissingCategory_IncorrectInputException() {
		logic.clearCategory();
		deleteCatCommand = new DeleteCategoryCommand("Personal");
		LogicAction logicAction = deleteCatCommand.execute(logic);
		Action action = Whitebox.getInternalState(logicAction, ACTION);
		assertEquals(Action.ERROR, action);
	}

}
```
###### test\dooyit\logic\commands\SearchCommandTest.java
``` java
package dooyit.logic.commands;

import static org.junit.Assert.assertEquals;

import java.util.ArrayList;

import org.junit.Before;
import org.junit.Test;
import org.powermock.reflect.Whitebox;

import dooyit.common.datatype.DateTime;
import dooyit.common.datatype.DateTime.Month;
import dooyit.common.datatype.DeadlineTask;
import dooyit.common.datatype.EventTask;
import dooyit.common.datatype.FloatingTask;
import dooyit.common.datatype.Task;
import dooyit.common.datatype.TaskGroup;
import dooyit.logic.api.LogicController;
import dooyit.logic.api.TaskManager;

public class SearchCommandTest {

	LogicController logic;
	SearchCommand searchCommand;

	Task floatingTask1;
	Task floatingTask2;
	Task deadlineTask;
	Task eventTask;
	Task floatingTask3;

	@Before
	public void setUp() {
		logic = new LogicController();
		logic.disableSave();
		logic.clearTasks();
	}

	public void setupTasks() {
		logic.clearTasks();

		int[] date1 = { 25, 4, 2016 };
		int[] date2 = { 30, 4, 2016 };
		DateTime dateTimeDeadline = new DateTime(date1, 1000);
		DateTime dateTimeStart = new DateTime(date2, 1200);
		DateTime dateTimeEnd = new DateTime(date2, 1400);

		floatingTask1 = new FloatingTask("hello");
		floatingTask2 = new FloatingTask("go");
		floatingTask3 = new FloatingTask("water");
		deadlineTask = new DeadlineTask("car", dateTimeDeadline);
		eventTask = new EventTask("house", dateTimeStart, dateTimeEnd);

		logic.addTask(floatingTask1);
		logic.addTask(floatingTask2);
		logic.addTask(deadlineTask);
		logic.addTask(eventTask);
		logic.addTask(floatingTask3);
	}

	@Test
	public void search_Name_WithResults() {
		setupTasks();

		String searchString = "h";
		searchCommand = new SearchCommand(searchString);
		searchCommand.execute(logic);

		TaskManager manager = logic.getTaskManager();
		ArrayList<TaskGroup> taskGroup = manager.getTaskGroupSearched();
		ArrayList<Task> floatingTasks = Whitebox.getInternalState(taskGroup.get(0), "tasks");
		ArrayList<Task> eventTasks = Whitebox.getInternalState(taskGroup.get(1), "tasks");

		// floatingTasks should only contain the task with name "hello"
		assertEquals(1, floatingTasks.size());

		// eventTasks should only contain the task with name "house"
		assertEquals(1, eventTasks.size());

		// Assert that the references are the same.
		assertEquals(floatingTask1, floatingTasks.get(0));
		assertEquals(eventTask, eventTasks.get(0));
	}

	@Test
	public void search_Name_NoResults() {
		setupTasks();

		String searchString = "haha";
		searchCommand = new SearchCommand(searchString);
		searchCommand.execute(logic);

		TaskManager manager = logic.getTaskManager();
		ArrayList<TaskGroup> taskGroup = manager.getTaskGroupSearched();
		ArrayList<Task> tasks = Whitebox.getInternalState(taskGroup.get(0), "tasks");
		assertEquals(0, tasks.size());
	}

	@Test
	public void search_Month_WithResults() {
		setupTasks();

		searchCommand = new SearchCommand("april", Month.APR);
		searchCommand.execute(logic);
		TaskManager manager = logic.getTaskManager();
		ArrayList<TaskGroup> taskGroup = manager.getTaskGroupSearched();
		ArrayList<Task> tasks1 = Whitebox.getInternalState(taskGroup.get(0), "tasks");
		ArrayList<Task> tasks2 = Whitebox.getInternalState(taskGroup.get(1), "tasks");

		assertEquals(1, tasks1.size());
		assertEquals(1, tasks2.size());

		assertEquals(deadlineTask, tasks1.get(0));
		assertEquals(eventTask, tasks2.get(0));
	}

	@Test
	public void search_Month_NoResults() {
		setupTasks();

		searchCommand = new SearchCommand("january", Month.JAN);
		searchCommand.execute(logic);

		TaskManager manager = logic.getTaskManager();
		ArrayList<TaskGroup> taskGroup = manager.getTaskGroupSearched();
		ArrayList<Task> tasks = Whitebox.getInternalState(taskGroup.get(0), "tasks");
		assertEquals(0, tasks.size());
	}

	@Test
	public void search_Date_WithResults() {
		setupTasks();

		int[] date = { 25, 4, 2016 };
		DateTime dt = new DateTime(date);
		searchCommand = new SearchCommand(dt);
		searchCommand.execute(logic);

		TaskManager manager = logic.getTaskManager();
		ArrayList<TaskGroup> taskGroup = manager.getTaskGroupSearched();
		ArrayList<Task> tasks = Whitebox.getInternalState(taskGroup.get(0), "tasks");
		assertEquals(1, tasks.size());
		assertEquals(deadlineTask, tasks.get(0));
	}

	@Test
	public void search_Date_NoResults() {
		setupTasks();

		int[] date = { 17, 4, 2016 };
		DateTime dt = new DateTime(date);
		searchCommand = new SearchCommand(dt);
		searchCommand.execute(logic);

		TaskManager manager = logic.getTaskManager();
		ArrayList<TaskGroup> taskGroup = manager.getTaskGroupSearched();
		ArrayList<Task> tasks = Whitebox.getInternalState(taskGroup.get(0), "tasks");
		assertEquals(0, tasks.size());
	}
}
```
###### test\dooyit\logic\commands\SetCategoryCommandTest.java
``` java
package dooyit.logic.commands;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import java.util.ArrayList;

import org.junit.Before;
import org.junit.Test;
import org.powermock.reflect.Whitebox;

import dooyit.common.datatype.Category;
import dooyit.common.datatype.CustomColour;
import dooyit.common.datatype.DateTime;
import dooyit.common.datatype.Task;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class SetCategoryCommandTest {
	private static final String ACTION = "action";

	LogicController logic;
	MoveToCategory setCatCommand;

	@Before
	public void setup() {
		logic = new LogicController();
		logic.disableSave();
	}

	public void clear() {
		logic.clearTasks();
		logic.clearCategory();
	}

	@Test
	public void SetCategory_MissingCategory_CategoryCreated() {
		clear();
		int[] date = { 20, 4, 2016 };
		DateTime deadline = new DateTime(date, 1000);
		logic.addDeadlineTask("Project Proposal", deadline);
		ArrayList<Task> tasks = logic.getTaskManager().getAllTasks();
		int taskId = tasks.get(0).getUniqueId();
		setCatCommand = new MoveToCategory(taskId, "Deadlines");
		setCatCommand.execute(logic);
		assertTrue(logic.containsCategory("Deadlines"));
	}

	@Test
	public void SetCategory_InvalidId_IncorrectInputException() {
		clear();
		int[] date = { 20, 4, 2016 };
		DateTime deadline = new DateTime(date, 1000);
		logic.addDeadlineTask("Project Proposal", deadline);

		setCatCommand = new MoveToCategory(100, "Deadlines");
		LogicAction logicAction = setCatCommand.execute(logic);
		Action action = Whitebox.getInternalState(logicAction, ACTION);
		assertEquals(Action.ERROR, action);
	}

	@Test
	public void SetCategory_ExistingCategory_CategoryAssigned() {
		clear();
		int[] date = { 20, 4, 2016 };
		DateTime deadline = new DateTime(date, 1000);
		logic.addDeadlineTask("Project Proposal", deadline);

		// Add the category first
		Category category = new Category("Deadlines", CustomColour.BLUE);
		logic.addCategory(category);
		assertTrue(logic.containsCategory("Deadlines"));

		// Get the Id of the task we added to reference for editting
		ArrayList<Task> tasks = logic.getTaskManager().getAllTasks();
		Task task = tasks.get(0);
		int taskId = task.getUniqueId();
		setCatCommand = new MoveToCategory(taskId, "Deadlines");

		setCatCommand.execute(logic);
		assertEquals(task.getCategory(), category);
	}
}
```
###### test\dooyit\logic\commands\ShowCommandTest.java
``` java
package dooyit.logic.commands;

import static org.junit.Assert.assertEquals;

import org.junit.Before;
import org.junit.Test;

import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;
import dooyit.logic.commands.ShowCommand.ShowCommandType;

public class ShowCommandTest {
	LogicController logic;
	ShowCommand showCommand;

	@Before
	public void setup() {
		logic = new LogicController();
		logic.disableSave();
		logic.clearTasks();
		logic.addCategory("Test");
	}

	@Test
	public void Show_Today_LogicActionToday() {
		showCommand = new ShowCommand(ShowCommandType.TODAY);
		LogicAction logicAction = showCommand.execute(logic);
		assertEquals(Action.SHOW_TODAY_TASK, logicAction.getAction());
	}

	@Test
	public void Show_Next7_LogicActionNext7() {
		showCommand = new ShowCommand(ShowCommandType.NEXT7DAY);
		LogicAction logicAction = showCommand.execute(logic);
		assertEquals(Action.SHOW_NEXT7DAY_TASK, logicAction.getAction());
	}

	@Test
	public void Show_CategoryExisting_LogicActionShowCategory() {
		showCommand = new ShowCommand(ShowCommandType.CATEGORY, "Test");
		LogicAction logicAction = showCommand.execute(logic);
		assertEquals(Action.SHOW_CATEGORY, logicAction.getAction());
	}

	@Test
	public void Show_CategoryMissing_LogicActionError() {
		showCommand = new ShowCommand(ShowCommandType.CATEGORY, "Missing");
		LogicAction logicAction = showCommand.execute(logic);
		assertEquals(Action.ERROR, logicAction.getAction());
	}

	@Test
	public void Show_Float_LogicActionShowFloat() {
		showCommand = new ShowCommand(ShowCommandType.FLOAT);
		LogicAction logicAction = showCommand.execute(logic);
		assertEquals(Action.SHOW_FLOATING_TASK, logicAction.getAction());
	}

	@Test
	public void Show_Completed_LogicActionShowAll() {
		showCommand = new ShowCommand(ShowCommandType.ALL);
		LogicAction logicAction = showCommand.execute(logic);
		assertEquals(Action.SHOW_ALL_TASK, logicAction.getAction());
	}

	@Test
	public void Show_Completed_LogicActionShowCompleted() {
		showCommand = new ShowCommand(ShowCommandType.COMPLETED);
		LogicAction logicAction = showCommand.execute(logic);
		assertEquals(Action.SHOW_COMPLETED, logicAction.getAction());
	}
}
```
###### test\dooyit\logic\TaskManagerTest.java
``` java
	@Test
	public void GetSize() {
		taskManager.clear();
		assertEquals(0, taskManager.size());
	}

	@Test
	public void GetTaskWithCat() {
		taskManager.clear();
		ArrayList<Task> tasks = new ArrayList<Task>();
		Category category = new Category("Personal", CustomColour.BLUE);

		Task task1 = (Task) new FloatingTask("Buy milk");
		task1.setCategory(category);
		tasks.add(task1);

		Task task2 = (Task) new FloatingTask("Go gym");
		task2.setCategory(category);
		tasks.add(task2);

		taskManager.add(task1);
		taskManager.add(task2);

		ArrayList<Task> expectedTasks = taskManager.getTasksWithCategory(category);

		assertTrue(expectedTasks.equals(tasks));
	}

	@Test
	public void GetIncompletedTask() {
		setupTasks();

		ArrayList<Task> tasks = new ArrayList<Task>();
		tasks.add(task1);
		tasks.add(task2);
		tasks.add(task6);

		assertTrue(tasks.equals(taskManager.getIncompleteTasks()));
	}

	@Test
	public void GetCompletedTasks() {
		setupTasks();

		ArrayList<Task> tasks = new ArrayList<Task>();
		tasks.add(task3);
		tasks.add(task4);
		tasks.add(task5);

		assertTrue(tasks.equals(taskManager.getCompletedTasks()));
	}

	@Test
	public void GetEventTasks() {
		setupTasks();

		ArrayList<Task> tasks = new ArrayList<Task>();
		tasks.add(task1);
		tasks.add(task4);

		assertTrue(tasks.equals(taskManager.getEventTasks()));
	}

	@Test
	public void GetIncompletedEventTask() {
		setupTasks();

		ArrayList<Task> tasks = new ArrayList<Task>();
		tasks.add(task1);

		assertTrue(tasks.equals(taskManager.getIncompleteEventTasks()));
	}

	@Test
	public void GetIncompleteEventTasksToday() {
		setupTasks();

		ArrayList<Task> tasks = new ArrayList<Task>();

		DateTime dateTime = new DateTime();
		tasks.add(task1);

		assertTrue(tasks.equals(taskManager.getIncompleteEventTasks(dateTime)));
	}

	@Test
	public void GetEventTasksToday() {
		setupTasks();

		ArrayList<Task> tasks = new ArrayList<Task>();

		DateTime dateTime = new DateTime();
		tasks.add(task1);
		tasks.add(task4);

		assertTrue(tasks.equals(taskManager.getEventTasks(dateTime)));
	}

	@Test
	public void GetDeadlineTasks() {
		setupTasks();

		ArrayList<Task> tasks = new ArrayList<Task>();
		tasks.add(task3);
		tasks.add(task6);

		assertTrue(tasks.equals(taskManager.getDeadlineTasks()));
	}

	@Test
	public void GetIncompleteDeadlineTask() {
		setupTasks();

		ArrayList<Task> tasks = new ArrayList<Task>();
		tasks.add(task6);
		ArrayList<Task> expectedTasks = taskManager.getIncompleteDeadlineTasks();
		assertTrue(tasks.equals(expectedTasks));

		tasks.add(task3);
		assertFalse(tasks.equals(expectedTasks));
	}

	@Test
	public void GetIncompleteDeadlineTaskToday() {
		setupTasks();

		ArrayList<Task> tasks = new ArrayList<Task>();
		tasks.add(task6);
		DateTime dateTime = new DateTime();
		ArrayList<Task> expectedTasks = taskManager.getIncompleteDeadlineTasks(dateTime);
		assertTrue(tasks.equals(expectedTasks));

		tasks.add(task3);
		assertFalse(tasks.equals(expectedTasks));
	}

	@Test
	public void GetFloatingTasks() {
		setupTasks();

		ArrayList<Task> tasks = new ArrayList<Task>();
		tasks.add(task2);
		tasks.add(task5);

		assertTrue(tasks.equals(taskManager.getFloatingTasks()));
	}

	@Test
	public void GetIncompleteFloatingTasks() {
		setupTasks();

		ArrayList<Task> tasks = new ArrayList<Task>();
		tasks.add(task2);

		assertTrue(tasks.equals(taskManager.getIncompleteFloatingTasks()));
	}

	@Test
	public void SortTasks() {
		setupTasks();

		taskManager.sortTasks(taskManager.getAllTasks());
		ArrayList<Task> tasks = new ArrayList<Task>();
		tasks.add(task1);
		tasks.add(task3);
		tasks.add(task4);
		tasks.add(task6);
		tasks.add(task2);
		tasks.add(task5);

		assertTrue(tasks.equals(taskManager.getAllTasks()));
	}

	@Test
	public void MarkTask_MarkWithIncompleteTaskObject() {
		setupTasks();

		ArrayList<Task> tasks = taskManager.getIncompleteDeadlineTasks();
		assertEquals(1, tasks.size());
		taskManager.markTask(tasks.get(0));
		tasks = taskManager.getIncompleteDeadlineTasks();
		assertEquals(0, tasks.size());
	}

	@Test
	public void UnmarkTask_UnmarkWithCompletedTaskObject() {
		setupTasks();

		ArrayList<Task> tasks = taskManager.getCompletedTasks();
		assertEquals(3, tasks.size());
		taskManager.unmarkTask(tasks.get(0));
		tasks = taskManager.getCompletedTasks();
		assertEquals(2, tasks.size());
	}

	@Test
	public void RemoveTasksWithCategory() {
		setupTasks();

		ArrayList<Task> allTasks = taskManager.getAllTasks();
		Category personal = new Category("Personal", CustomColour.BLUE);
		Task task1 = allTasks.get(0);
		task1.setCategory(personal);

		ArrayList<Task> removedTasks = taskManager.removeTasksWithCategory(personal);
		assertEquals(1, removedTasks.size());
	}

	@Test
	public void GetOverDueTasks() {
		setupTasks();
		int[] date = { 20, 10, 2016 };
		DateTime overdue = new DateTime(date, 800);

		ArrayList<Task> expectedOverdue = new ArrayList<Task>();
		expectedOverdue.add(task1);
		expectedOverdue.add(task6);
		ArrayList<Task> overdueTasks = taskManager.getOverdueTasks(overdue);
		assertTrue(expectedOverdue.equals(overdueTasks));
		assertEquals(expectedOverdue.size(), taskManager.getOverdueTasksSize(overdue));
	}
}
```
###### test\dooyit\storage\CategoryControllerTest.java
``` java
package dooyit.storage;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;

import org.junit.Assert;
import org.junit.Test;

import dooyit.common.datatype.Category;
import dooyit.common.datatype.CategoryData;
import dooyit.common.datatype.CustomColour;

public class CategoryControllerTest extends Constants {

	static final String FOLDER_TEST = CURRENT_DIRECTORY + SEPARATOR_CHAR 
									+ "test" + SEPARATOR_CHAR + "dooyit"
									+ SEPARATOR_CHAR;
	
	static final String FOLDER_TEST_STORAGE = FOLDER_TEST + "storage" + SEPARATOR_CHAR;
	static final String FILE_NAME_EXPECTED_CAT = "expectedSaveCat.txt";
	static final String FILE_NAME_SAVE_CAT = "testSaveCat.txt";

	private static final String BLACK = "black";
	private static final String BLUE = "blue";
	private static final String CYAN = "cyan";
	private static final String WHITE = "white";
	private static final String GREY = "grey";
	private static final String MAGENTA = "magenta";
	private static final String GREEN = "green";
	private static final String YELLOW = "yellow";
	private static final String RED = "red";
	private static final String PINK = "pink";

	@Test
	public void Save_ContentComparison_ExpectedPass() throws IOException {
		CategoryController categoryController = new CategoryController(FOLDER_TEST_STORAGE + FILE_NAME_SAVE_CAT);
		ArrayList<CategoryData> categories = new ArrayList<CategoryData>();
		categories.add(new CategoryData("A", BLUE));
		categories.add(new CategoryData("B", RED));
		categories.add(new CategoryData("C", PINK));
		categories.add(new CategoryData("D", YELLOW));

		Assert.assertTrue(categoryController.save(categories));

		String expected = "", saved = "";
		BufferedReader bReader = new BufferedReader(new FileReader(FOLDER_TEST_STORAGE + FILE_NAME_EXPECTED_CAT));
		String categoryInfo = bReader.readLine();
		while (categoryInfo != null) {
			expected += categoryInfo;
			categoryInfo = bReader.readLine();
		}
		bReader.close();

		bReader = new BufferedReader(new FileReader(FOLDER_TEST_STORAGE + FILE_NAME_SAVE_CAT));
		categoryInfo = bReader.readLine();
		while (categoryInfo != null) {
			saved += categoryInfo;
			categoryInfo = bReader.readLine();
		}
		bReader.close();

		Assert.assertEquals(expected, saved);
	}

	@Test
	public void Load_ContentComparison_ExpectedPass() throws IOException {
		CategoryController categoryController = new CategoryController(FOLDER_TEST_STORAGE + FILE_NAME_EXPECTED_CAT);
		ArrayList<Category> categories = new ArrayList<Category>();

		categories.add(new Category("A", CustomColour.BLUE));
		categories.add(new Category("B", CustomColour.RED));
		categories.add(new Category("C", CustomColour.PINK));
		categories.add(new Category("D", CustomColour.YELLOW));

		ArrayList<CategoryData> loaded = categoryController.load();
		ArrayList<Category> existingCat = new ArrayList<Category>();
		for (CategoryData data : loaded) {
			Category existing = new Category(data.getName(), resolveColor(data.getColor()));
			existingCat.add(existing);
		}
		Assert.assertTrue(categories.equals(existingCat));
	}

	// Referenced from CustomColor class
	private CustomColour resolveColor(String colorName) {
		CustomColour color;
		String name = colorName.toLowerCase();

		if (name.equals(BLACK)) {
			color = CustomColour.BLACK;
		} else if (name.equals(BLUE)) {
			color = CustomColour.BLUE;
		} else if (name.equals(CYAN)) {
			color = CustomColour.CYAN;
		} else if (name.equals(GREY)) {
			color = CustomColour.GREY;
		} else if (name.equals(GREEN)) {
			color = CustomColour.GREEN;
		} else if (name.equals(MAGENTA)) {
			color = CustomColour.MAGENTA;
		} else if (name.equals(PINK)) {
			color = CustomColour.PINK;
		} else if (name.equals(RED)) {
			color = CustomColour.RED;
		} else if (name.equals(YELLOW)) {
			color = CustomColour.YELLOW;
		} else if (name.equals(WHITE)) {
			color = CustomColour.WHITE;
		} else {
			// Random color generated but assume blue
			color = CustomColour.BLUE;
		}

		return color;
	}
}
```
###### test\dooyit\storage\StorageControllerTest.java
``` java
package dooyit.storage;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

import dooyit.common.datatype.TaskData;
import dooyit.common.exception.IncorrectInputException;

public class StorageControllerTest extends Constants {
	
	static final String FOLDER_TEST = CURRENT_DIRECTORY + SEPARATOR_CHAR 
									+ "test" + SEPARATOR_CHAR + "dooyit" 
									+ SEPARATOR_CHAR;
	
	static final String FOLDER_TEST_STORAGE = FOLDER_TEST + "storage" + SEPARATOR_CHAR;
	
	static final String TEST_VALID_EXTENSION = "testSave.txt";
	static final String TEST_MISSING_FILE = "missing.txt";
	static final String TEST_INVALID_EXTENSION = "abc.css";
	
	static final String NAME_FILE_CONFIG = SEPARATOR_CHAR + "config.txt";
	
	StorageController storage;
	
	@Before
	public void setup() throws IOException {
	storage = new StorageController();
	}
	
	
	//Case for negative partition - folder
	@Test(expected = IncorrectInputException.class)
	public void SetFileDestination_InvalidAsFolder_AssertionError() throws IOException {
		
		//filePath is expected to end with .txt extension, this should throw exception
		String filePath = FOLDER_TEST_STORAGE;
		storage.setFileDestination(filePath);
	}
	
	//Case for negative partition - file extension
	@Test(expected = IncorrectInputException.class)
	public void testBadExtensionSetFileDestination() throws IOException {
		
		//filePath is expected to end with .txt extension
		String filePath = FOLDER_TEST_STORAGE + TEST_INVALID_EXTENSION;
		storage.setFileDestination(filePath);
	}
	
	@Test
	public void setFileDestination_ValidMissingFile_ExpectedPass() throws IOException {
		
		String originalPath = storage.getFilePath();
		
		//filePath ending with .txt extension
		String filePath = FOLDER_TEST_STORAGE + TEST_MISSING_FILE;
		
		//Expected false if file does not exist
		Assert.assertFalse(storage.setFileDestination(filePath));
		
		//Read file path from config
		BufferedReader bReader = new BufferedReader(new FileReader(CURRENT_DIRECTORY + NAME_FILE_CONFIG));
		String taskPath = bReader.readLine();
		bReader.close();
		
		//Checking if the file contains the same path as application
		Assert.assertEquals(taskPath, filePath);
		
		//Revert to original path
		Assert.assertTrue(storage.setFileDestination(originalPath));
		Assert.assertEquals(storage.getFilePath(), originalPath);
		
	}
	
	@Test
	public void setFileDestination_ValidExistingFile_ExpectedPass() throws IOException {
		
		String originalPath = storage.getFilePath();
		
		String filePath = FOLDER_TEST_STORAGE + TEST_VALID_EXTENSION;
		
		//Expected true since file exists
		Assert.assertTrue(storage.setFileDestination(filePath));

		//Checking if file path is saved correctly on application
		Assert.assertEquals(storage.getFilePath(), filePath);
		
		BufferedReader bReader = new BufferedReader(new FileReader(CURRENT_DIRECTORY + NAME_FILE_CONFIG));
		String taskPath = bReader.readLine();
		bReader.close();
		
		//Checking if the file contains the same path as application
		Assert.assertEquals(taskPath, filePath);
		
		//Revert the path to original
		storage.setFileDestination(originalPath);
		Assert.assertEquals(storage.getFilePath(), originalPath);
	}
	
	@Test (expected = AssertionError.class)
	public void save_NullArray_AssertionError() throws IOException {
		ArrayList<TaskData> tasks = null;
		storage.saveTasks(tasks);
	}
}
```
###### test\dooyit\storage\StorageTestSuite.java
``` java
package dooyit.storage;

import org.junit.runner.RunWith;
import org.junit.runners.Suite;

@RunWith(Suite.class)
@Suite.SuiteClasses({ StorageControllerTest.class, TaskControllerTest.class, CategoryControllerTest.class })
public class StorageTestSuite {
}
```
###### test\dooyit\storage\TaskControllerTest.java
``` java
package dooyit.storage;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;

import org.junit.Assert;
import org.junit.Test;

import dooyit.common.datatype.DateTime;
import dooyit.common.datatype.DeadlineTaskData;
import dooyit.common.datatype.EventTaskData;
import dooyit.common.datatype.FloatingTaskData;
import dooyit.common.datatype.TaskData;

public class TaskControllerTest extends Constants {

	static final String FOLDER_TEST = CURRENT_DIRECTORY + SEPARATOR_CHAR + "test" + SEPARATOR_CHAR + "dooyit"
			+ SEPARATOR_CHAR;
	static final String FOLDER_TEST_STORAGE = FOLDER_TEST + "storage" + SEPARATOR_CHAR;
	static final String EXPECTED = "expectedTasks.txt";
	static final String SAVE = "testSaveTasks.txt";

	@Test
	public void testSave() throws IOException {
		ArrayList<TaskData> tasks = new ArrayList<TaskData>();
		TaskController taskControl = new TaskController(FOLDER_TEST_STORAGE + SAVE);

		// 10 December 2016
		int[] date = { 10, 12, 2016 };

		// {"deadline":{"date":"10 12 2016","time":-1},"taskName":"buy
		// milk","isCompleted":false}
		DateTime deadline_no_time = new DateTime(date);
		DeadlineTaskData deadlineData1 = new DeadlineTaskData("buy milk", deadline_no_time, false);
		tasks.add(deadlineData1);

		// {"deadline":{"date":"10 12
		// 2016","time":800},"taskName":"homework","isCompleted":false}
		DateTime deadline = new DateTime(date, 800);
		DeadlineTaskData deadlineData2 = new DeadlineTaskData("homework", deadline, false);
		tasks.add(deadlineData2);

		// {"taskName":"float","isCompleted":false}
		FloatingTaskData floatData = new FloatingTaskData("float", false);
		tasks.add(floatData);

		// {"start":{"date":"10 12 2016","time":1000},"end":{"date":"10 12
		// 2016","time":1200},"taskName":"brunch","isCompleted":false}
		DateTime event_start = new DateTime(date, 1000);
		DateTime event_end = new DateTime(date, 1200);
		EventTaskData eventData = new EventTaskData("brunch", event_start, event_end, false);
		tasks.add(eventData);

		taskControl.save(tasks);

		// Compare expected and test case result
		String expected = "", saved = "";
		BufferedReader bReader = new BufferedReader(new FileReader(FOLDER_TEST_STORAGE + EXPECTED));
		String taskInfo = bReader.readLine();
		while (taskInfo != null) {
			expected += taskInfo;
			taskInfo = bReader.readLine();
		}
		bReader.close();

		bReader = new BufferedReader(new FileReader(FOLDER_TEST_STORAGE + SAVE));
		taskInfo = bReader.readLine();
		while (taskInfo != null) {
			saved += taskInfo;
			taskInfo = bReader.readLine();
		}
		bReader.close();

		Assert.assertEquals(expected, saved);
	}

	@Test
	public void testLoad() throws IOException {
		TaskController taskControl = new TaskController(FOLDER_TEST_STORAGE + EXPECTED);
		ArrayList<TaskData> loadedTasks = taskControl.load();

		// 10 December 2016
		int[] date = { 10, 12, 2016 };

		// {"deadline":{"date":"10 12 2016","time":-1},"taskName":"buy
		// milk","isCompleted":false}
		DateTime deadline_no_time = new DateTime(date);
		DeadlineTaskData deadlineData1 = new DeadlineTaskData("buy milk", deadline_no_time, false);
		DeadlineTaskData expectedDeadline1 = (DeadlineTaskData) loadedTasks.get(0);
		Assert.assertTrue(expectedDeadline1.equals(deadlineData1));

		// {"deadline":{"date":"10 12
		// 2016","time":800},"taskName":"homework","isCompleted":false}
		DateTime deadline = new DateTime(date, 800);
		DeadlineTaskData deadlineData2 = new DeadlineTaskData("homework", deadline, false);
		DeadlineTaskData expectedDeadline2 = (DeadlineTaskData) loadedTasks.get(1);
		Assert.assertTrue(expectedDeadline2.equals(deadlineData2));

		// {"taskName":"float","isCompleted":false}
		FloatingTaskData floatData = new FloatingTaskData("float", false);
		FloatingTaskData expectedFloat = (FloatingTaskData) loadedTasks.get(2);
		Assert.assertTrue(expectedFloat.equals(floatData));

		// {"start":{"date":"10 12 2016","time":1000},"end":{"date":"10 12
		// 2016","time":1200},"taskName":"brunch","isCompleted":false}
		DateTime event_start = new DateTime(date, 1000);
		DateTime event_end = new DateTime(date, 1200);
		EventTaskData eventData = new EventTaskData("brunch", event_start, event_end, false);
		EventTaskData expectedEvent = (EventTaskData) loadedTasks.get(3);
		Assert.assertTrue(expectedEvent.equals(eventData));
	}
}
```
###### test\IntegrationTest.java
``` java
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import org.junit.Before;
import org.junit.Test;
import org.powermock.reflect.Whitebox;

import dooyit.common.datatype.DateTime;
import dooyit.common.datatype.Task;
import dooyit.common.datatype.Task.TaskType;
import dooyit.logic.api.LogicController;
import dooyit.parser.AddParser;
import dooyit.parser.ParserController;

public class IntegrationTest {

	LogicController logic;

	@Before
	public void setUp() {
		logic = new LogicController();
		logic.disableSave();
		logic.clearTasks();
	}

	@Test
	public void addFloatingTask_ValidInput_FloatingTask() {
		logic.clearTasks();
		logic.processInput("add a");

		// Checking Logic
		Task task = logic.getTaskManager().getMostRecentTask();
		assertTrue(logic.containsTask(task));
		assertEquals(TaskType.FLOATING, task.getTaskType());

		// Checking Parser
		ParserController parser = Whitebox.getInternalState(logic, "parserController");
		AddParser addParser = Whitebox.getInternalState(parser, "addParser");

		String userInput = Whitebox.getInternalState(addParser, "userInput");
		assertEquals("a", userInput);

		String taskName = Whitebox.getInternalState(addParser, "taskName");
		assertEquals("a", taskName);

	}

	@Test
	public void addDeadlineTask_ValidDateTime_DeadlineTask() {
		logic.clearTasks();
		logic.processInput("add buy milk by 30/3/2016");

		// Checking Logic
		Task task = logic.getTaskManager().getMostRecentTask();
		assertTrue(logic.containsTask(task));
		assertEquals(TaskType.DEADLINE, task.getTaskType());

		// Checking Parser
		ParserController parser = Whitebox.getInternalState(logic, "parserController");
		AddParser addParser = Whitebox.getInternalState(parser, "addParser");

		String userInput = Whitebox.getInternalState(addParser, "userInput");
		assertEquals("buy milk by 30/3/2016", userInput);

		String taskName = Whitebox.getInternalState(addParser, "taskName");
		assertEquals("buy milk", taskName);

		DateTime dt = Whitebox.getInternalState(addParser, "deadline");
		DateTime expectedDateTime = new DateTime(new int[] { 30, 3, 2016 });
		assertTrue(dt.equals(expectedDateTime));
	}

	@Test
	public void addEventTask_ValidDateTime_EventTask() {
		logic.clearTasks();
		logic.processInput("add buy milk from 30/3/2016 to 31/3/2016");

		// Checking Logic
		Task task = logic.getTaskManager().getMostRecentTask();
		assertTrue(logic.containsTask(task));
		assertEquals(TaskType.EVENT, task.getTaskType());

		// Checking Parser
		ParserController parser = Whitebox.getInternalState(logic, "parserController");
		AddParser addParser = Whitebox.getInternalState(parser, "addParser");

		String userInput = Whitebox.getInternalState(addParser, "userInput");
		assertEquals("buy milk from 30/3/2016 to 31/3/2016", userInput);

		String taskName = Whitebox.getInternalState(addParser, "taskName");
		assertEquals("buy milk", taskName);

		DateTime start = Whitebox.getInternalState(addParser, "start");
		DateTime expectedStart = new DateTime(new int[] { 30, 3, 2016 }, 0);
		assertTrue(start.equals(expectedStart));

		DateTime end = Whitebox.getInternalState(addParser, "end");
		DateTime expectedEnd = new DateTime(new int[] { 31, 3, 2016 }, 2359);
		assertTrue(end.equals(expectedEnd));
	}

	@Test
	public void addEventTask_InvalidDateTime_FloatingTask() {
		logic.clearTasks();
		logic.processInput("add buy milk from 30/3/2016");

		// Checking Logic
		Task task = logic.getTaskManager().getMostRecentTask();
		assertEquals(TaskType.FLOATING, task.getTaskType());

		// Checking Parser
		ParserController parser = Whitebox.getInternalState(logic, "parserController");
		AddParser addParser = Whitebox.getInternalState(parser, "addParser");

		String userInput = Whitebox.getInternalState(addParser, "userInput");
		assertEquals("buy milk from 30/3/2016", userInput);

		String taskName = Whitebox.getInternalState(addParser, "taskName");
		assertEquals("buy milk from 30/3/2016", taskName);
	}

}
```
