# A0126356E
###### .git\logs\HEAD
``` 
0b01333d582c0ea77067d47f25686ea3a830a99d a66c363996afb2040b0e12886ec0504ba9ab5be6 Ta Eu <taeu93@gmail.com> 1459774170 +0800	pull origin master: Merge made by the 'recursive' strategy.
a66c363996afb2040b0e12886ec0504ba9ab5be6 b4b48a1f413a3cf0d8a0595f105b942994c8a8ba Ta Eu <taeu93@gmail.com> 1459775501 +0800	commit: rename commands
b4b48a1f413a3cf0d8a0595f105b942994c8a8ba a0a14c16b039e08dc033ef6244afced1e8e20cb3 Ta Eu <taeu93@gmail.com> 1459775511 +0800	pull origin master: Merge made by the 'recursive' strategy.
```
###### .git\logs\refs\heads\master
``` 
0b01333d582c0ea77067d47f25686ea3a830a99d a66c363996afb2040b0e12886ec0504ba9ab5be6 Ta Eu <taeu93@gmail.com> 1459774170 +0800	pull origin master: Merge made by the 'recursive' strategy.
a66c363996afb2040b0e12886ec0504ba9ab5be6 b4b48a1f413a3cf0d8a0595f105b942994c8a8ba Ta Eu <taeu93@gmail.com> 1459775501 +0800	commit: rename commands
b4b48a1f413a3cf0d8a0595f105b942994c8a8ba a0a14c16b039e08dc033ef6244afced1e8e20cb3 Ta Eu <taeu93@gmail.com> 1459775511 +0800	pull origin master: Merge made by the 'recursive' strategy.
```
###### src\dooyit\common\comparator\TaskDateComparator.java
``` java
package dooyit.common.comparator;

import java.util.Comparator;

import dooyit.common.datatype.Task;

public class TaskDateComparator implements Comparator<Task>{
	
	public int compare(Task task1, Task task2){
		
		return task1.compareDateTo(task2);
	}
	
	public boolean equals(Object obj){
		return this == obj;
	}
	
}
```
###### src\dooyit\common\comparator\TaskUniqueIdComparator.java
``` java
package dooyit.common.comparator;

import java.util.Comparator;

import dooyit.common.datatype.Task;

public class TaskUniqueIdComparator implements Comparator<Task>{

	public int compare(Task task1, Task task2) {

		if (task1.getUniqueId() < task2.getUniqueId()) {
			return -1;
		} else if (task1.getUniqueId() > task2.getUniqueId()) {
			return 1;
		} else {
			return 0;
		}

	}

	public boolean equals(Object obj) {
		return this == obj;
	}
}
```
###### src\dooyit\common\datatype\Category.java
``` java
package dooyit.common.datatype;

import javafx.scene.paint.Color;

public class Category {
	private String name;

	private CustomColor customColor;

	public Category(String name) {
		this.name = name;
	}

	public Category(String name, CustomColor customColour) {
		this.name = name;
		this.customColor = customColour;
	}

	public String getName() {
		return this.name;
	}

	public Color getColour() {
		return customColor.getColor();
	}

	public CustomColor getCustomColour() {
		return customColor;
	}

	public String getCustomColourName() {
		return customColor.getName();
	}

	@Override
	public boolean equals(Object o) {
		if (o instanceof String) {
			String categoryName = (String) o;
			return getName().toLowerCase().equals(categoryName.toLowerCase());
		} else if (o instanceof Category) {
			Category category = (Category) o;
			return getName().toLowerCase().equals(category.getName().toLowerCase());
		}
		return false;
	}

	@Override
	public String toString() {
		return name + " " + customColor.toString();
	}

	public CategoryData convertToData() {
		CategoryData categoryData;
		categoryData = new CategoryData(name, getCustomColourName());
		return categoryData;
	}
}
```
###### src\dooyit\common\datatype\CustomColor.java
``` java
package dooyit.common.datatype;

import javafx.scene.paint.Color;

public class CustomColor {
	public float r; // red
	public float g; // green
	public float b; // blue
	public String name; // colour name
	
	public CustomColor(String name, float r, float g, float b) {
		this.name = name;
		this.r = r / 255.0f;
		this.g = g / 255.0f;
		this.b = b / 255.0f;
	}

	public static final CustomColor BLACK = new CustomColor("black", 40, 40, 40);
	public static final CustomColor BLUE = new CustomColor("blue", 26, 214, 253);
	public static final CustomColor CYAN = new CustomColor("cyan", 82, 237, 199);
	public static final CustomColor GREY = new CustomColor("grey", 219, 221, 222);
	public static final CustomColor GREEN = new CustomColor("green", 135, 252, 125);
	public static final CustomColor MAGENTA = new CustomColor("magenta", 239, 77, 182);
	public static final CustomColor PINK = new CustomColor("pink", 255, 73, 129);
	public static final CustomColor RED = new CustomColor("red", 255, 58, 84);
	public static final CustomColor YELLOW = new CustomColor("yellow", 255, 204, 0);
	public static final CustomColor WHITE = new CustomColor("white", 247, 247, 247);

	public Color getColor(){
		return Color.color(r, g, b);
	}
	
	public String getName(){
		return name;
	}
	
	@Override
	public boolean equals(Object o) {
		if(o instanceof String){
			String colourString = (String)o;
			return name.equals(colourString);
		}
		
		if (o instanceof CustomColor) {
			CustomColor colour = (CustomColor) o;
			return r == colour.r && g == colour.g && b == colour.b;
		}
		
		return false;
	}

	@Override
	public String toString() {
		return "Colour: " + r + "," + g + "," + b;
	}

	public String toSavableString() {
		return this.r + " " + this.g + " " + this.b;
	}
	
	
}
```
###### src\dooyit\common\datatype\DeadlineTask.java
``` java
package dooyit.common.datatype;

public class DeadlineTask extends Task {

	DateTime dateTimeDeadline;
	
	public DeadlineTask(String taskName, DateTime deadline){
		assert (taskName != null && deadline != null);

		taskType = TaskType.DEADLINE;
		this.taskName = taskName;
		this.dateTimeDeadline = deadline;
	}
	
	public DeadlineTask(String taskName, DateTime deadline, Category category){
		assert (taskName != null && deadline != null);

		taskType = TaskType.DEADLINE;
		this.taskName = taskName;
		this.dateTimeDeadline = deadline;
		this.category = category;
	}
	
	public DeadlineTask(Task task, DateTime dateTimeDeadline){
		assert(task != null);
		
		this.taskType = TaskType.DEADLINE;
		this.taskId = task.taskId;
		this.uniqueId = task.uniqueId;
		this.taskName = task.taskName;
		this.category = task.category;
		this.isCompleted = task.isCompleted;
		this.dateTimeDeadline = dateTimeDeadline;
	}
	
	public DeadlineTask(DeadlineTask deadlineTask){
		assert(deadlineTask != null);
		
		this.taskType = TaskType.DEADLINE;
		this.taskId = deadlineTask.taskId;
		this.uniqueId = deadlineTask.uniqueId;
		this.taskName = deadlineTask.taskName;
		this.dateTimeDeadline = deadlineTask.dateTimeDeadline;
		this.category = deadlineTask.category;
		this.isCompleted = deadlineTask.isCompleted;
	}
	
	public DateTime getDateTimeDeadline() {
		return dateTimeDeadline;
	}
	
	@Override
	public DateTime getDateTime(){
		return dateTimeDeadline;
	}
	
	@Override
	public int compareDateTo(Task task){
		if(task instanceof FloatingTask){
			return -1;
		}
			
		return this.dateTimeDeadline.compareTo(task.getDateTime());
	}
	
	@Override
	public Task copy(){
		return new DeadlineTask(this);
	}
	
	@Override
	public boolean isSameDate(DateTime dateTime){
		return dateTimeDeadline.isTheSameDateAs(dateTime);
	}
	
	@Override
	public boolean isOverDue(DateTime dateTime){
		return !isSameDate(dateTime) && !isCompleted && dateTimeDeadline.compareTo(dateTime) == -1;
	}
	
	@Override
	public String getDateString(){
		if(dateTimeDeadline.hasTime()){
			return dateTimeDeadline.getTime24hStr();
		}
		else{
			return "";
		}
	}
	
	@Override
	public String toString() {
		String taskString = taskName + ", Deadline: " + dateTimeDeadline.toString();
		String categoryString = "";
		
		if(hasCategory()){
			categoryString = " ,Cat: " + category.getName() + "-" + category.getCustomColourName();
		}
		
		return taskString + categoryString;
	}
	
	@Override
	public boolean equals(Object o) {
		if (o instanceof DeadlineTask) {
			DeadlineTask deadlineTask = (DeadlineTask) o;
			return this.uniqueId == deadlineTask.uniqueId && this.getName().equals(deadlineTask.getName()) 
					&& this.getDateTimeDeadline().equals(deadlineTask.getDateTimeDeadline());
		}
		return false;
	}
	
	@Override
	public TaskData convertToData(){
		DeadlineTaskData deadlineTaskData;
		
		if(!hasCategory()){
			deadlineTaskData = new DeadlineTaskData(taskName, dateTimeDeadline, isCompleted);
		}else{
			deadlineTaskData = new DeadlineTaskData(taskName, dateTimeDeadline, category.getName(), isCompleted);
		}
		
		return deadlineTaskData;
	}
}
```
###### src\dooyit\common\datatype\EventTask.java
``` java
package dooyit.common.datatype;

import java.util.ArrayList;

public class EventTask extends Task {

	private DateTime dateTimeStart;
	private DateTime dateTimeEnd;
	private boolean hasMultiDay = false;
	private boolean isMultiDayOn = false;
	private int currentMultiDay = 0;
	private ArrayList<String> multiDayString;

	public EventTask(String taskName, DateTime start, DateTime end) {
		assert (taskName != null && start != null && end != null);

		taskType = TaskType.EVENT;
		this.taskName = taskName;
		this.dateTimeStart = start;
		this.dateTimeEnd = end;

		checkMultiDay(start, end);
	}

	public EventTask(String taskName, DateTime start, DateTime end, Category category) {
		assert (taskName != null && start != null && end != null);

		taskType = TaskType.EVENT;
		this.taskName = taskName;
		this.dateTimeStart = start;
		this.dateTimeEnd = end;
		this.category = category;

		checkMultiDay(start, end);
	}

	public EventTask(Task task, DateTime start, DateTime end) {
		assert (task != null);

		this.taskType = TaskType.EVENT;
		this.taskId = task.taskId;
		this.uniqueId = task.uniqueId;
		this.taskName = task.taskName;
		this.category = task.category;
		this.isCompleted = task.isCompleted;
		this.dateTimeStart = start;
		this.dateTimeEnd = end;

		checkMultiDay(start, end);
	}

	public EventTask(EventTask eventTask) {
		assert (eventTask != null);

		this.taskType = TaskType.EVENT;
		this.taskId = eventTask.taskId;
		this.uniqueId = eventTask.uniqueId;
		this.taskName = eventTask.taskName;
		this.dateTimeStart = eventTask.dateTimeStart;
		this.dateTimeEnd = eventTask.dateTimeEnd;
		this.category = eventTask.category;
		this.isCompleted = eventTask.isCompleted;

		checkMultiDay(dateTimeStart, dateTimeEnd);
	}

	/**
	 * @param start
	 * @param end
	 */
	public void checkMultiDay(DateTime start, DateTime end) {
		if (DateTime.hasMultiDay(start, end)) {
			multiDayString = DateTime.getMultiDayString(start, end);
			hasMultiDay = true;
		}
	}

	public void onMultiDay() {
		isMultiDayOn = true;
		currentMultiDay = 0;
	}

	public void offMultiDay() {
		isMultiDayOn = false;
	}

	// @Override
	// public boolean isCompleted(){
	// //offMultiDay();
	// return super.isCompleted();
	// }

	public int size() {
		if (hasMultiDay) {
			return multiDayString.size();
		}

		return 1;
	}

	@Override
	public DateTime getDateTime() {
		return dateTimeStart;
	}

	@Override
	public int compareDateTo(Task task) {
		if (task instanceof FloatingTask) {
			return -1;
		}

		return this.dateTimeStart.compareTo(task.getDateTime());
	}

	public DateTime getDateTimeStart() {
		return dateTimeStart;
	}

	public DateTime getDateTimeEnd() {
		return dateTimeEnd;
	}

	@Override
	public Task copy() {
		return new EventTask(this);
	}

	@Override
	public boolean isSameDate(DateTime dateTime) {
		if (hasMultiDay && isMultiDayOn) {
			return dateTimeStart.isTheSameDateAs(dateTime) || DateTime.isWithin(dateTime, dateTimeStart, dateTimeEnd)
					|| dateTimeEnd.isTheSameDateAs(dateTime);
		} else {
			return dateTimeStart.isTheSameDateAs(dateTime);
		}
	}

	@Override
	public boolean isOverDue(DateTime dateTime) {
		// return !isSameDate(dateTime) && !isCompleted &&
		// dateTimeEnd.compareTo(dateTime) == -1;
		boolean isOverDue = !dateTimeStart.isTheSameDateAs(dateTime) && dateTimeStart.compareTo(dateTime) == -1
				&& !isCompleted;

		if (isOverDue) {
			hasMultiDay = false;
		}

		return isOverDue;
	}

	@Override
	public String getDateString() {
		if (hasMultiDay && isMultiDayOn) {

			return multiDayString.get((currentMultiDay++) % multiDayString.size());
		}

		return dateTimeStart.getTime24hStr() + " - " + dateTimeEnd.getTime24hStr();
	}

	@Override
	public String toString() {
		String taskString = taskName + ", Event: " + dateTimeStart.toString() + " to " + dateTimeEnd.toString();
		String categoryString = "";

		if (hasCategory()) {
			categoryString = ", Cat: " + category.getName() + "-" + category.getCustomColourName();
		}

		return taskString + categoryString;
	}

	@Override
	public boolean equals(Object o) {
		if (o instanceof EventTask) {
			EventTask eventTask = (EventTask) o;
			return this.uniqueId == eventTask.uniqueId && this.getName().equals(eventTask.getName())
					&& this.getDateTimeStart().equals(eventTask.getDateTimeStart())
					&& this.getDateTimeEnd().equals(eventTask.getDateTimeEnd());
		}
		return false;
	}

	@Override
	public TaskData convertToData() {
		EventTaskData eventTaskData;

		if (!hasCategory()) {
			eventTaskData = new EventTaskData(taskName, dateTimeStart, dateTimeEnd, isCompleted);
		} else {
			eventTaskData = new EventTaskData(taskName, dateTimeStart, dateTimeEnd, category.getName(), isCompleted);
		}

		return eventTaskData;
	}
}
```
###### src\dooyit\common\datatype\FloatingTask.java
``` java
package dooyit.common.datatype;

public class FloatingTask extends Task {

	public FloatingTask(String taskName) {
		assert (taskName != null);

		taskType = TaskType.FLOATING;
		this.taskName = taskName;
	}

	public FloatingTask(String taskName, Category category) {
		assert (taskName != null);

		taskType = TaskType.FLOATING;
		this.taskName = taskName;
		this.category = category;
	}

	public FloatingTask(FloatingTask floatingTask) {
		assert (floatingTask != null);

		this.taskType = floatingTask.taskType;
		this.taskId = floatingTask.taskId;
		this.uniqueId = floatingTask.uniqueId;
		this.taskName = floatingTask.taskName;
		this.category = floatingTask.category;
		this.isCompleted = floatingTask.isCompleted;
	}

	public FloatingTask(Task task) {
		assert (task != null);

		this.taskType = TaskType.FLOATING;
		this.taskId = task.taskId;
		this.uniqueId = task.uniqueId;
		this.taskName = task.taskName;
		this.category = task.category;
		this.isCompleted = task.isCompleted;
	}

	@Override
	public DateTime getDateTime() {
		return null;
	}

	@Override
	public int compareDateTo(Task task) {
		return 1;
	}

	@Override
	public Task copy() {
		return new FloatingTask(this);
	}

	@Override
	public boolean isSameDate(DateTime dateTime) {
		return false;
	}

	@Override
	public boolean isOverDue(DateTime dateTime) {
		return false;
	}

	@Override
	public String getDateString() {
		return "";
	}

	@Override
	public String toString() {

		String taskString = taskName;
		String categoryString = "";

		if (hasCategory()) {
			categoryString = " ,Cat: " + category.getName() + "-" + category.getCustomColourName();
		}

		return uniqueId + ")" + taskString + categoryString;
	}

	@Override
	public boolean equals(Object o) {
		if (o instanceof FloatingTask) {
			FloatingTask floatingTask = (FloatingTask) o;
			return this.uniqueId == floatingTask.uniqueId && this.getName().equals(floatingTask.getName());
		}
		return false;
	}

	@Override
	public TaskData convertToData() {
		FloatingTaskData floatingTaskData;

		if (!hasCategory()) {
			floatingTaskData = new FloatingTaskData(taskName, isCompleted);
		} else {
			floatingTaskData = new FloatingTaskData(taskName, category.getName(), isCompleted);
		}

		return floatingTaskData;
	}
}
```
###### src\dooyit\common\datatype\Task.java
``` java
package dooyit.common.datatype;

public abstract class Task {

	public enum TaskType {
		DEADLINE, EVENT, FLOATING
	};

	protected String taskName;
	protected int taskId;
	protected TaskType taskType;

	protected boolean isCompleted;
	protected Category category;

	public static int curUniqueTaskId = 1;
	public int uniqueId; // to determine which task is created first

	public Task() {
		uniqueId = curUniqueTaskId;
		taskId = curUniqueTaskId;
		curUniqueTaskId++;
	}

	public void changeName(String taskName) {
		this.taskName = taskName;
	}

	public void mark() {
		isCompleted = true;
	}

	public void unMark() {
		isCompleted = false;
	}

	public boolean isCompleted() {
		return isCompleted;
	}

	public void setCategory(Category category) {
		this.category = category;
	}

	public Category getCategory() {
		return category;
	}

	public void removeCategory() {
		category = null;
	}

	public boolean hasCategory() {
		return category != null;
	}

	public String getName() {
		return taskName;
	}

	public int getId() {
		return taskId;
	}

	public void setId(int taskId) {
		this.taskId = taskId;
	}

	public void resetId() {
		this.taskId = -1;
	}

	public int getUniqueId() {
		return uniqueId;
	}

	public void setUniqueId(int uniqueId) {
		this.uniqueId = uniqueId;
	}

	public TaskType getTaskType() {
		return taskType;
	}

	@Override
	public boolean equals(Object o) {
		if (o instanceof Task) {
			Task task = (Task) o;
			return task.getId() == taskId;
		} else {
			return false;
		}
	}

	public abstract String toString();

	public abstract DateTime getDateTime();

	public abstract int compareDateTo(Task task);

	public abstract Task copy();

	public abstract String getDateString();

	public abstract TaskData convertToData();

	public abstract boolean isOverDue(DateTime dateTime);

	public abstract boolean isSameDate(DateTime dateTime);
}
```
###### src\dooyit\common\datatype\TaskGroup.java
``` java
package dooyit.common.datatype;

import java.util.ArrayList;

public class TaskGroup {

	private String title;
	private ArrayList<Task> tasks;
	private DateTime dateTime;

	public TaskGroup(String title) {
		this.title = title;
		tasks = new ArrayList<Task>();
	}

	public TaskGroup(String title, DateTime dateTime) {
		this.title = title;
		this.dateTime = dateTime;
		tasks = new ArrayList<Task>();
	}

	public void addTask(Task task) {
		this.tasks.add(task);
	}

	public void addTasks(ArrayList<Task> tasks) {
		this.tasks.addAll(tasks);
	}

	public DateTime getDateTime() {
		return dateTime;
	}

	public void setTitle(String title) {
		this.title = title;
	}

	public String getTitle() {
		if (hasDateTime()) {
			String dateString = dateTime.getDate();
			dateString = dateString.substring(0, dateString.length() - 5);
			return title + ", " + dateString;
		} else {
			return title;
		}
	}

	public ArrayList<Task> getTasks() {

		return tasks;
	}

	public int size() {
		return tasks.size();
	}

	public boolean isEmpty() {
		return tasks.isEmpty();
	}

	public boolean hasDateTime() {
		return dateTime != null;
	}
}
```
###### src\dooyit\common\exception\IncorrectInputException.java
``` java

package dooyit.common.exception;

public class IncorrectInputException extends RuntimeException {

	private static final long serialVersionUID = 1L;

	public IncorrectInputException() {
		super();
	}

	public IncorrectInputException(String s) {
		super(s);
	}

	public IncorrectInputException(String s, Throwable throwable) {
		super(s, throwable);
	}

	public IncorrectInputException(Throwable throwable) {
		super(throwable);
	}
}
```
###### src\dooyit\logic\api\Action.java
``` java
package dooyit.logic.api;

public enum Action {
	ADD_TODAY_TASK,
	ADD_NEXT7DAY_TASK,
	ADD_FLOATING_TASK,
	ADD_ALL_TASK,
	DELETE_TASK,
	ADD_CATEGORY,
	DELETE_CATEGORY,
	REMOVE_CAT_FROM_TASK,
	SET_CATEGORY,
	CLEAR_TASK,
	CLEAR_CATEGORY,
	MARK_TASK,
	UNMARK_TASK,
	EDIT_NAME,
	EDIT_TO_TODAY_TASK,
	EDIT_TO_NEXT7DAY_TASK,
	EDIT_TO_FLOATING_TASK,
	EDIT_TO_ALL_TASK,
	SHOW_TODAY_TASK,
	SHOW_NEXT7DAY_TASK,
	SHOW_FLOATING_TASK,
	SHOW_ALL_TASK,
	SHOW_COMPLETED,
	SHOW_CATEGORY,
	SEARCH,
	HELP,
	UNDO,
	REDO,
	CHANGE_THEME_DEFAULT,
	CHANGE_THEME_DARK,
	CHANGE_THEME_AQUA,
	CHANGE_THEME_CUSTOM,
	SET_STORAGE_PATH,
	ERROR,
	EXIT
}
```
###### src\dooyit\logic\api\LogicAction.java
``` java
package dooyit.logic.api;

public class LogicAction {

	Action action;
	String message = "";

	public LogicAction(Action action) {
		this.action = action;
	}

	public LogicAction(Action action, String message) {
		this.action = action;
		this.message = message;
	}

	public Action getAction() {
		return this.action;
	}

	public String getMessage() {
		return this.message;
	}

	public void setMessage(String message) {
		this.message = message;
	}

	public boolean hasMessage() {
		return !message.equals("");
	}
}
```
###### src\dooyit\logic\api\LogicController.java
``` java
package dooyit.logic.api;

import dooyit.storage.StorageController;
import dooyit.ui.UIController;
import dooyit.parser.Parser;
import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.CategoryManager;
import dooyit.logic.DataManager;
import dooyit.logic.HistoryManager;
import dooyit.logic.TaskManager;
import dooyit.logic.commands.*;
import java.io.IOException;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

import dooyit.common.datatype.Category;
import dooyit.common.datatype.CategoryData;
import dooyit.common.datatype.DateTime;
import dooyit.common.datatype.Task;
import dooyit.common.datatype.TaskData;
import dooyit.common.datatype.TaskGroup;

public class LogicController {

	private Parser parser;
	private TaskManager taskManager;
	private CategoryManager categoryManager;
	private StorageController storage;
	private HistoryManager historyManager;
	private DataManager dataManager;
	private UIController uiController;
	private static Logger logger = Logger.getLogger("Logic");

	private boolean isSaveOn = true;
	private boolean displayCommandline = true;
	private Category selectedCategory;
	private String currentSearch = "";

	public LogicController() {
		logger.log(Level.INFO, "Initialising logic class");

		initParser();
		initTaskManager();
		initCategoryManager();
		initHistoryManager();
		initStorage();
		initDataManager();
		loadFromStorage();
		setDefaultCategories();
		save();

		logger.log(Level.INFO, "End of initialising logic class");
	}

	/**
	 * 
	 */
	public void initParser() {
		parser = new Parser();
	}

	/**
	 * 
	 */
	public void initTaskManager() {
		taskManager = new TaskManager();
	}

	/**
	 * 
	 */
	public void initCategoryManager() {
		categoryManager = new CategoryManager();
	}

	/**
	 * 
	 */
	public void initHistoryManager() {
		historyManager = new HistoryManager();
	}

	/**
	 * 
	 */
	private void initStorage() {
		try {
			storage = new StorageController();
		} catch (IOException e) {
			logger.log(Level.SEVERE, "ERROR: Fail to create storage");
			// uiController.displayMessage("ERROR: CREATING STORAGE");
		}
	}

	private void initDataManager() {
		dataManager = new DataManager();
	}

	/**
	 * 
	 */
	public void loadFromStorage() {
		try {
			loadCategoryDataFromStorage();
			loadTaskDataFromStorage();
		} catch (IOException e) {
			logger.log(Level.SEVERE, "ERROR: Fail to load task from storage");
			// uiController.displayMessage("ERROR: LOAD TASK");
		}
	}

	/**
	 * @param tasks
	 */
	public void loadTasks(ArrayList<Task> tasks) {
		taskManager.load(tasks);
	}

	public void setDefaultCategories() {
		categoryManager.setDefaultCategories();
	}

	/**
	 * process and execute command input from user
	 * 
	 * @param input
	 */
	public LogicAction processInput(String input) {
		Command command = parser.getCommand(input);
		assert (command != null);
		LogicAction logicAction = processCommand(command);
		return logicAction;
	}

	/**
	 * @param command
	 */
	public LogicAction processCommand(Command command) {
		LogicAction logicAction = executeCommand(command);
		addCommandToHistory(command);
		save();
		displayInCommandline();
		return logicAction;
	}

	/**
	 * @param command
	 */
	private LogicAction executeCommand(Command command) {
		LogicAction logicAction = null;

		try {
			logicAction = command.execute(this);
		} catch (IncorrectInputException e) {
			logicAction = new LogicAction(Action.ERROR, "INVALID COMMAND");
		}
		return logicAction;
	}

	/**
	 * @param command
	 */
	private void addCommandToHistory(Command command) {
		historyManager.addCommand(command);
	}

	public void undo() {
		historyManager.undoCommand(this);
	}

	public void redo() {
		historyManager.redoCommand(this);
	}

	private void save() {
		if (!isSaveOn) {
			return;
		}

		try {
			storage.saveTasks(getTaskDatas());
			storage.saveCategory(getCategoryDatas());
		} catch (IOException e) {
			logger.log(Level.SEVERE, "ERROR: Fail to save");
			// uiController.displayMessage("ERROR: SAVING");
		}

	}

	/**
	 * 
	 */
	private void displayInCommandline() {
		if (displayCommandline) {
			taskManager.display();
		}
	}

	public void enableSave() {
		isSaveOn = true;
	}

	public void disableSave() {
		isSaveOn = false;
	}

	public ArrayList<TaskData> getTaskDatas() {
		ArrayList<Task> tasks = taskManager.getAllTasks();
		return dataManager.convertTaskstoTaskDatas(tasks);
	}

	public ArrayList<CategoryData> getCategoryDatas() {
		ArrayList<Category> categories = categoryManager.getAllCategories();
		return dataManager.convertCategorytoCategoryDatas(categories);
	}

	public void loadCategoryDataFromStorage() throws IOException {
		ArrayList<CategoryData> categoryDatas = storage.loadCategory();
		dataManager.loadCategoryData(this, categoryDatas);
	}

	public void loadTaskDataFromStorage() throws IOException {
		ArrayList<TaskData> taskDatas = storage.loadTasks();
		dataManager.loadTaskData(this, taskDatas);
	}

	public void setSelectedCategory(Category category) {
		this.selectedCategory = category;
	}

	public Category getSelectedCategory() {
		return selectedCategory;
	}

	public void setSearchKey(String searchString) {
		this.currentSearch = searchString;
	}

	public ArrayList<TaskGroup> getTaskGroupsToday() {
		return taskManager.getTaskGroupsToday();
	}

	public ArrayList<TaskGroup> getTaskGroupsNext7Days() {
		return taskManager.getTaskGroupsNext7Days();
	}

	public ArrayList<TaskGroup> getTaskGroupsAll() {
		return taskManager.getTaskGroupsAll();
	}

	public ArrayList<TaskGroup> getTaskGroupsCompleted() {
		return taskManager.getTaskGroupsCompleted();
	}

	public ArrayList<TaskGroup> getTaskGroupsFloating() {
		return taskManager.getTaskGroupsFloating();
	}

	public ArrayList<TaskGroup> getTaskGroupCategory() {
		return taskManager.getTaskGroupCategory(selectedCategory);
	}

	public ArrayList<Category> getAllCategories() {
		return categoryManager.getAllCategories();
	}

	public ArrayList<TaskGroup> getSearchTaskGroup() {
		return taskManager.getTaskGroupSearched(currentSearch);
	}

	public void addTask(Task task) {
		taskManager.add(task);
	}

	public Task addFloatingTask(String taskName) {
		Task addedTask = taskManager.addFloatingTask(taskName);
		return addedTask;
	}

	public Task addDeadlineTask(String taskName, DateTime dateTimeDeadline) {
		Task addedTask = taskManager.addDeadlineTask(taskName, dateTimeDeadline);
		return addedTask;
	}

	public Task addEventTask(String taskName, DateTime dateTimeStart, DateTime dateTimeEnd) {
		Task addedTask = taskManager.addEventTask(taskName, dateTimeStart, dateTimeEnd);
		return addedTask;
	}

	public Task changeTaskName(int taskId, String newName) {
		return taskManager.changeTaskName(taskId, newName);
	}

	public Task changeTaskToDeadline(int taskId, DateTime dateTimeDeadline) {
		return taskManager.changeTaskToDeadline(taskId, dateTimeDeadline);
	}

	public Task changeTaskToEvent(int taskId, DateTime dateTimeStart, DateTime dateTimeEnd) {
		return taskManager.changeTaskToEvent(taskId, dateTimeStart, dateTimeEnd);
	}

	public boolean containsTask(int taskId) {
		return taskManager.contains(taskId);
	}

	public boolean containsTask(Task task) {
		return taskManager.contains(task);
	}

	public Task findTask(int taskId) {
		return taskManager.find(taskId);
	}

	public Task removeTask(int taskId) {
		Task removedTask = taskManager.remove(taskId);
		return removedTask;
	}

	public boolean removeTask(Task task) {
		boolean isRemoved = taskManager.remove(task);
		return isRemoved;
	}

	public void markTask(Task task) {
		taskManager.markTask(task);
	}

	public void markTask(int taskId) {
		taskManager.markTask(taskId);
	}

	public void unmarkTask(Task task) {
		taskManager.unmarkTask(task);
	}

	public void unmarkTask(int taskId) {
		taskManager.unmarkTask(taskId);
	}

	public int noOfTask() {
		return taskManager.size();
	}

	public ArrayList<Task> removeTasksWithCategory(Category category) {
		ArrayList<Task> tasksWithCategoty = taskManager.removeTasksWithCategory(category);
		return tasksWithCategoty;
	}

	public ArrayList<Task> clearTask() {
		ArrayList<Task> clearedTasks = taskManager.clear();
		// save();
		return clearedTasks;
	}

	public void addCategory(Category category) {
		categoryManager.addCategory(category);
	}

	public Category addCategory(String categoryName) {
		Category addedCategory = categoryManager.addCategory(categoryName);
		return addedCategory;
	}

	public Category addCategory(String categoryName, String colourString) {
		Category addedCategory = categoryManager.addCategory(categoryName, colourString);
		return addedCategory;
	}

	public Category removeCategory(String categoryName) {
		Category removedCategory = categoryManager.remove(categoryName);
		return removedCategory;
	}

	public boolean removeCategory(Category category) {
		return categoryManager.remove(category);
	}

	public boolean containsCategory(String categoryName) {
		return categoryManager.contains(categoryName);
	}

	public Category findCategory(String categoryName) {
		return categoryManager.find(categoryName);
	}

	public ArrayList<Category> clearCategory() {
		ArrayList<Category> clearedCategories = categoryManager.clear();
		return clearedCategories;
	}

	public boolean isFloatingTask(Task task) {
		return taskManager.isFloatingTask(task);
	}

	public boolean isTodayTask(Task task) {
		return taskManager.isTodayTask(task);
	}

	public boolean isNext7daysTask(Task task) {
		return taskManager.isNext7DaysTask(task);
	}

	public String getFilePath() {
		return storage.getFilePath();
	}

	public boolean setFileDestinationPath(String path) throws IncorrectInputException {
		try {
			return storage.setFileDestination(path);
		} catch (IOException e) {
			throw new IncorrectInputException("Invalid path: " + path);
		}
	}

	/**
	 * pass the uicontroller references to this class
	 * 
	 * @param ui
	 */
	public void setUIController(UIController ui) {
		this.uiController = ui;
	}

	/**
	 * Get the TaskManager object
	 * 
	 * @return TaskManager
	 */
	public TaskManager getTaskManager() {
		return taskManager;
	}

	/**
	 * Get UIController object
	 * 
	 * @return UIController
	 */
	public UIController getUIController() {
		return uiController;
	}

	/**
	 * Get Storage object
	 * 
	 * @return Storage
	 */
	public StorageController getStorage() {
		return storage;
	}

	/**
	 * Get CategoryManager object
	 * 
	 * @return CategoryManager
	 */
	public CategoryManager getCategoryManager() {
		return categoryManager;
	}

	public HistoryManager getHistoryManager() {
		return historyManager;
	}
}
```
###### src\dooyit\logic\CategoryManager.java
``` java
package dooyit.logic;

import java.util.ArrayList;

import dooyit.common.datatype.Category;
import dooyit.common.datatype.CustomColor;
import dooyit.common.exception.IncorrectInputException;

public class CategoryManager {
	ArrayList<Category> categories;
	ColourManager colourManager;

	public CategoryManager() {
		colourManager = new ColourManager();
		categories = new ArrayList<Category>();
		// setDefaultCategories();
	}

	public void setDefaultCategories() {
		if (categories.size() == 0) {
			addCategory("School");
			addCategory("Entertainment");
		}
	}

	public void addCategory(Category category) throws IncorrectInputException {
		if (contains(category)) {
			throw new IncorrectInputException("Category: " + category.getName() + " already exists.");
		}

		categories.add(category);
	}

	public Category addCategory(String categoryName) throws IncorrectInputException {
		if (contains(categoryName)) {
			throw new IncorrectInputException("Category: " + categoryName + " already exists.");
		}

		categoryName = capitalizeFirstCharacter(categoryName);
		Category category = new Category(categoryName, colourManager.pickRandomCustomColour());
		categories.add(category);
		return category;
	}

	public Category addCategory(String categoryName, String customColourString) throws IncorrectInputException {
		if (contains(categoryName)) {
			throw new IncorrectInputException("Category: " + categoryName + " already exists.");
		}

		if (!colourManager.contains(customColourString)) {
			addCategory(categoryName);
			throw new IncorrectInputException(
					"Colour: " + customColourString + " is not available. A random colour has been picked for you!");
		}

		categoryName = capitalizeFirstCharacter(categoryName);
		CustomColor customColour = colourManager.find(customColourString);
		Category category = new Category(categoryName, customColour);
		categories.add(category);
		return category;
	}

	public Category remove(String categoryName) {
		for (Category category : categories) {
			if (category.equals(categoryName)) {
				categories.remove(category);
				return category;
			}
		}
		return null;
	}

	public boolean remove(Category inCategory) {
		for (Category category : categories) {
			if (category.equals(inCategory)) {
				categories.remove(category);
				return true;
			}
		}
		return false;
	}

	public boolean contains(String categoryName) {
		for (int i = 0; i < categories.size(); i++) {
			if (categories.get(i).equals(categoryName)) {
				return true;
			}
		}
		return false;
	}

	public boolean contains(Category category) {
		for (int i = 0; i < categories.size(); i++) {
			if (categories.get(i).equals(category)) {
				return true;
			}
		}
		return false;
	}

	public Category find(String categoryName) {
		for (int i = 0; i < categories.size(); i++) {
			if (categories.get(i).equals(categoryName)) {
				return categories.get(i);
			}
		}
		return null;
	}

	public Category find(Category category) {
		for (int i = 0; i < categories.size(); i++) {
			if (categories.get(i).equals(category)) {
				return categories.get(i);
			}
		}
		return null;
	}

	public ArrayList<Category> getAllCategories() {
		return categories;
	}

	public ArrayList<Category> clear() {
		ArrayList<Category> clearedCategories = new ArrayList<Category>(categories);
		this.categories.clear();
		return clearedCategories;
	}

	public void load(ArrayList<Category> categories) {
		this.categories.addAll(categories);
	}

	private String capitalizeFirstCharacter(String categoryName) {
		assert (categoryName != null);

		if (categoryName == "") {
			return "";
		}

		categoryName = categoryName.toLowerCase();
		char capitalFirstLetter = Character.toUpperCase(categoryName.charAt(0));
		String string = capitalFirstLetter + categoryName.substring(1);

		return string;
	}
}
```
###### src\dooyit\logic\ColourManager.java
``` java
package dooyit.logic;

import java.util.ArrayList;
import java.util.Random;

import dooyit.common.datatype.CustomColor;

public class ColourManager {
	ArrayList<CustomColor> usedColours;
	Random random;
	ArrayList<CustomColor> recommendedColours;
	ArrayList<CustomColor> availableColours;
	ArrayList<CustomColor> colourPool;

	public ColourManager() {
		random = new Random();
		availableColours = new ArrayList<CustomColor>();
		availableColours.add(CustomColor.BLACK);
		availableColours.add(CustomColor.BLUE);
		availableColours.add(CustomColor.CYAN);
		availableColours.add(CustomColor.GREY);
		availableColours.add(CustomColor.GREEN);
		availableColours.add(CustomColor.MAGENTA);
		availableColours.add(CustomColor.PINK);
		availableColours.add(CustomColor.RED);
		availableColours.add(CustomColor.YELLOW);
		availableColours.add(CustomColor.WHITE);

		recommendedColours = new ArrayList<CustomColor>();
		recommendedColours.add(CustomColor.BLUE);
		recommendedColours.add(CustomColor.CYAN);
		recommendedColours.add(CustomColor.GREEN);
		recommendedColours.add(CustomColor.MAGENTA);
		recommendedColours.add(CustomColor.PINK);
		recommendedColours.add(CustomColor.RED);
		recommendedColours.add(CustomColor.YELLOW);
		// recommendedColours.add(CustomColor.GREY);

		colourPool = new ArrayList<CustomColor>(recommendedColours);
	}

	public CustomColor pickRandomCustomColour() {
		if (colourPool.size() == 0) {
			colourPool = new ArrayList<CustomColor>(recommendedColours);
		}
		return colourPool.remove(random.nextInt(colourPool.size()));
	}

	public boolean contains(String name) {
		for (CustomColor customColor : availableColours) {
			if (customColor.equals(name)) {
				return true;
			}
		}
		return false;
	}

	public boolean contains(CustomColor customColor) {
		boolean hasCustomColor = availableColours.contains(customColor);
		return hasCustomColor;
	}

	public CustomColor find(String customColorString) {
		for (CustomColor customColor : availableColours) {
			if (customColor.equals(customColorString)) {
				return customColor;
			}
		}
		return null;
	}

}
```
###### src\dooyit\logic\commands\AddCategoryCommand.java
``` java
package dooyit.logic.commands;

import dooyit.common.datatype.Category;
import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class AddCategoryCommand implements Command, ReversibleCommand {

	private String categoryName;
	private String colorString;
	Category addedCategory;
	private boolean hasError = false;

	public AddCategoryCommand(String categoryName) {
		this.categoryName = categoryName;
	}

	public AddCategoryCommand(String categoryName, String colorString) {
		this.categoryName = categoryName;
		this.colorString = colorString;
	}

	private boolean hasColorString() {
		return colorString != null;
	}

	public boolean hasError() {
		return hasError;
	}

	public void undo(LogicController logic) {
		logic.removeCategory(addedCategory);
	}

	public void redo(LogicController logic) {
		logic.addCategory(addedCategory);
	}

	public LogicAction execute(LogicController logic) throws IncorrectInputException {
		LogicAction logicAction;

		if (!logic.containsCategory(categoryName)) {
			if (hasColorString()) {
				addedCategory = logic.addCategory(categoryName, colorString);
			} else {
				addedCategory = logic.addCategory(categoryName);
			}

			logicAction = new LogicAction(Action.ADD_CATEGORY);
		} else {
			logicAction = new LogicAction(Action.ERROR);
			hasError = true;
			throw new IncorrectInputException("Category: " + categoryName + " already exists.");
		}

		return logicAction;
	}

}
```
###### src\dooyit\logic\commands\AddTaskCommand.java
``` java
package dooyit.logic.commands;

import dooyit.common.datatype.DateTime;
import dooyit.common.datatype.Task;
import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class AddTaskCommand implements Command, ReversibleCommand {

	private String taskName;
	private Task.TaskType taskType;
	private DateTime dateTimeDeadline;
	private DateTime dateTimeStart;
	private DateTime dateTimeEnd;
	private Task addedTask;
	private boolean hasError = false;

	public AddTaskCommand(String taskName) {
		this.taskName = taskName;
		taskType = Task.TaskType.FLOATING;
	}

	public AddTaskCommand(String data, DateTime deadline) {
		this.taskName = data;
		this.dateTimeDeadline = deadline;
		taskType = Task.TaskType.DEADLINE;
	}

	public AddTaskCommand(String data, DateTime start, DateTime end) {
		this.taskName = data;
		this.dateTimeStart = start;
		this.dateTimeEnd = end;
		taskType = Task.TaskType.EVENT;
	}

	public boolean hasError() {
		return hasError;
	}

	public void undo(LogicController logic) {
		logic.removeTask(addedTask);
	}

	public void redo(LogicController logic) {
		logic.addTask(addedTask);
	}

	public LogicAction execute(LogicController logic) throws IncorrectInputException {
		assert (logic != null);
		LogicAction logicAction = null;

		switch (taskType) {
		case FLOATING:
			addedTask = logic.addFloatingTask(taskName);
			break;

		case DEADLINE:
			addedTask = logic.addDeadlineTask(taskName, dateTimeDeadline);
			break;

		case EVENT:
			addedTask = logic.addEventTask(taskName, dateTimeStart, dateTimeEnd);
			break;
		}

		logicAction = getActionBasedOnAddedTask(logic, addedTask);
		return logicAction;
	}

	public LogicAction getActionBasedOnAddedTask(LogicController logic, Task addedTask) {
		LogicAction logicAction;

		if (logic.isFloatingTask(addedTask)) {
			logicAction = new LogicAction(Action.ADD_FLOATING_TASK);

		} else if (logic.isTodayTask(addedTask)) {
			logicAction = new LogicAction(Action.ADD_TODAY_TASK);

		} else if (logic.isNext7daysTask(addedTask)) {
			logicAction = new LogicAction(Action.ADD_NEXT7DAY_TASK);

		} else {
			logicAction = new LogicAction(Action.ADD_ALL_TASK);
		}

		return logicAction;
	}

}
```
###### src\dooyit\logic\commands\ChangeThemeCommand.java
``` java
package dooyit.logic.commands;

import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class ChangeThemeCommand implements Command {

	private String themeString;
	private boolean hasError = false;

	public ChangeThemeCommand(String themeString) {
		this.themeString = themeString;
	}

	public boolean hasError() {
		return hasError;
	}

	public LogicAction execute(LogicController logic) throws IncorrectInputException {
		LogicAction logicAction = null;

		String lowerThemeString = themeString.toLowerCase();

		switch (lowerThemeString) {
		case "default":
			logicAction = new LogicAction(Action.CHANGE_THEME_DEFAULT);
			break;

		case "light":
			logicAction = new LogicAction(Action.CHANGE_THEME_DEFAULT);
			break;

		case "dark":
			logicAction = new LogicAction(Action.CHANGE_THEME_DARK);
			break;

		case "aqua":
			logicAction = new LogicAction(Action.CHANGE_THEME_AQUA);
			break;

		case "custom":
			logicAction = new LogicAction(Action.CHANGE_THEME_CUSTOM);
			break;

		default:
			logicAction = new LogicAction(Action.ERROR);
			throw new IncorrectInputException(themeString + " is not available, try DEFAULT, DARK, AQUA or CUSTOM");
		}

		return logicAction;
	}

}
```
###### src\dooyit\logic\commands\ClearTaskCommand.java
``` java
package dooyit.logic.commands;

import java.util.ArrayList;

import dooyit.common.datatype.Task;
import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class ClearTaskCommand implements Command, ReversibleCommand {

	ArrayList<Task> clearedTasks;
	private boolean hasError = false;

	public ClearTaskCommand() {

	}

	public boolean hasError() {
		return hasError;
	}

	public void undo(LogicController logic) {
		logic.loadTasks(clearedTasks);
	}

	public void redo(LogicController logic) {
		clearedTasks = logic.clearTask();
	}

	public LogicAction execute(LogicController logic) throws IncorrectInputException {
		assert (logic != null);
		LogicAction logicAction;

		clearedTasks = logic.clearTask();

		logicAction = new LogicAction(Action.CLEAR_TASK, "All tasks are CLEARED!");
		return logicAction;
	}

}
```
###### src\dooyit\logic\commands\Command.java
``` java
package dooyit.logic.commands;

import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public interface Command {

	public LogicAction execute(LogicController logic) throws IncorrectInputException;

	public boolean hasError();
}
```
###### src\dooyit\logic\commands\CommandFactory.java
``` java
package dooyit.logic.commands;

public class CommandFactory {

	public CommandFactory() {

	}
	//
	//
	// public Command createAddCommandFloat(String data){
	// AddCommand addCommand = new AddCommand();
	// addCommand.initAddCommandFloat(data);
	// return addCommand;
	// }
	//
	// public Command createAddCommandDeadline(String data, DateTime deadline){
	// AddCommand addCommand = new AddCommand();
	// addCommand.initAddCommandDeadline(data, deadline);
	// return addCommand;
	// }
	//
	// public Command createAddCommandEvent(String data, DateTime start,
	// DateTime end){
	// AddCommand addCommand = new AddCommand();
	// addCommand.initAddCommandEvent(data, start, end);
	// return addCommand;
	// }
	//
	//
	//
	//
	// public Command createDeleteCommand(int deleteId){
	// DeleteCommand deleteCommand = new DeleteCommand();
	// deleteCommand.initDeleteCommand(deleteId);
	// return deleteCommand;
	// }
	//
	// public Command createDeleteCommand(ArrayList<Integer> deleteIds){
	// DeleteCommand deleteCommand = new DeleteCommand();
	// deleteCommand.initDeleteCommand(deleteIds);
	// return deleteCommand;
	// }
	//
	//
	//
	// public Command createMarkCommand(int markId){
	// MarkCommand deleteCommand = new MarkCommand();
	// deleteCommand.initMarkCommand(markId);
	// return deleteCommand;
	// }
	//
	// public Command createMarkCommand(ArrayList<Integer> markIds){
	// MarkCommand deleteCommand = new MarkCommand();
	// deleteCommand.initMarkCommand(markIds);
	// return deleteCommand;
	// }
	//
	//
	// public Command createAddCategoryCommand(String categoryName){
	// AddCategoryCommand addCategoryCommand = new
	// AddCategoryCommand(categoryName);
	// return addCategoryCommand;
	// }
	//
	// public Command createAddCategoryCommand(String categoryName, CustomColor
	// colour){
	// AddCategoryCommand addCategoryCommand = new
	// AddCategoryCommand(categoryName, colour);
	// return addCategoryCommand;
	// }
	//
	//
	// public Command createShowTodayCommand(){
	// ShowCommand showCommand = new ShowCommand(UIMainViewType.TODAY);
	//
	// return showCommand;
	// }
	//
	// public Command createShowNext7DaysCommand(){
	// ShowCommand showCommand = new ShowCommand(UIMainViewType.EXTENDED);
	//
	// return showCommand;
	// }
	//
	// public Command createShowAllCommand(){
	// ShowCommand showCommand = new ShowCommand(UIMainViewType.ALL);
	//
	// return showCommand;
	// }
	//
	// public Command createShowCompletedCommand(){
	// ShowCommand showCommand = new ShowCommand(UIMainViewType.COMPLETED);
	//
	// return showCommand;
	// }
	//
	// public Command createShowCategoryCommand(String categoryName){
	// // temp
	// ShowCommand showCommand = new ShowCommand(UIMainViewType.COMPLETED,
	// categoryName);
	//
	// return showCommand;
	// }
	//
	//
	//
	//
	//
	// public Command createEditCommandName(int taskId, String taskName){
	// EditCommand editCommand = new EditCommand();
	// editCommand.initEditCommandName(taskId, taskName);
	// return editCommand;
	// }
	//
	// public Command createEditCommandDeadline(int taskId, DateTime deadline){
	// EditCommand editCommand = new EditCommand();
	// editCommand.initEditCommandDeadline(taskId, deadline);
	// return editCommand;
	// }
	//
	// public Command createEditCommandEvent(int taskId, DateTime start,
	// DateTime end){
	// EditCommand editCommand = new EditCommand();
	// editCommand.initEditCommandEvent(taskId, start, end);
	// return editCommand;
	// }
	//
	// public Command createEditCommandNameAndDeadline(int taskId, String
	// taskName, DateTime deadline){
	// EditCommand editCommand = new EditCommand();
	// editCommand.initEditCommandNameAndDeadline(taskId, taskName, deadline);
	// return editCommand;
	// }
	//
	// public Command createEditCommandNameAndEvent(int taskId, String taskName,
	// DateTime start, DateTime end){
	// EditCommand editCommand = new EditCommand();
	// editCommand.initEditCommandNameAndEvent(taskId, taskName, start, end);
	// return editCommand;
	// }
	//
	// public Command createStorageCommand(String path){
	// StorageCommand storageCommand = new StorageCommand(path);
	// return storageCommand;
	// }
	//
	// public Command createInvalidCommand(String errorMessage){
	// InvalidCommand invalidCommand = new InvalidCommand(errorMessage);
	// return invalidCommand;
	// }
	//
	//
	// public Command createExitCommand(){
	// ExitCommand exitCommand = new ExitCommand();
	// return exitCommand;
	// }
	//

}
```
###### src\dooyit\logic\commands\CommandUtils.java
``` java
package dooyit.logic.commands;

import java.util.ArrayList;
import dooyit.common.datatype.DateTime;

public class CommandUtils {

	public static Command createAddCommandFloat(String data) {
		AddTaskCommand addCommand = new AddTaskCommand(data);
		return addCommand;
	}

	public static Command createAddCommandDeadline(String data, DateTime deadline) {
		AddTaskCommand addCommand = new AddTaskCommand(data, deadline);
		return addCommand;
	}

	public static Command createAddCommandEvent(String data, DateTime start, DateTime end) {
		AddTaskCommand addCommand = new AddTaskCommand(data, start, end);
		return addCommand;
	}

	public static Command createDeleteCommand(int deleteId) {
		DeleteTaskCommand deleteCommand = new DeleteTaskCommand(deleteId);
		return deleteCommand;
	}

	public static Command createDeleteCommand(ArrayList<Integer> deleteIds) {
		DeleteTaskCommand deleteCommand = new DeleteTaskCommand(deleteIds);
		return deleteCommand;
	}

	public static Command createMarkCommand(int markId) {
		MarkTaskCommand deleteCommand = new MarkTaskCommand(markId);
		return deleteCommand;
	}

	public static Command createMarkCommand(ArrayList<Integer> markIds) {
		MarkTaskCommand deleteCommand = new MarkTaskCommand(markIds);
		return deleteCommand;
	}

	public static Command createUnMarkCommand(int unMarkId) {
		UnmarkTaskCommand deleteCommand = new UnmarkTaskCommand(unMarkId);
		return deleteCommand;
	}

	public static Command createUnMarkCommand(ArrayList<Integer> unMarkIds) {
		UnmarkTaskCommand deleteCommand = new UnmarkTaskCommand(unMarkIds);
		return deleteCommand;
	}

	public static Command createAddCategoryCommand(String categoryName) {
		AddCategoryCommand addCategoryCommand = new AddCategoryCommand(categoryName);
		return addCategoryCommand;
	}

	public static Command createAddCategoryCommand(String categoryName, String colorString) {
		AddCategoryCommand addCategoryCommand = new AddCategoryCommand(categoryName, colorString);
		return addCategoryCommand;
	}

	public static Command createSetCategoryCommand(int taskID, String categoryName) {
		SetCategoryCommand addCategoryCommand = new SetCategoryCommand(taskID, categoryName);
		return addCategoryCommand;
	}

	public static Command createSetCategoryCommand(ArrayList<Integer> taskIDs, String categoryName) {
		SetCategoryCommand addCategoryCommand = new SetCategoryCommand(taskIDs, categoryName);
		return addCategoryCommand;
	}

	public static Command createDeleteCategoryCommand(String categoryName) {
		DeleteCategoryCommand deleteCategoryCommand = new DeleteCategoryCommand(categoryName);
		return deleteCategoryCommand;
	}

	public static Command createShowTodayCommand() {
		ShowCommand showCommand = new ShowCommand(ShowCommand.ShowCommandType.TODAY);

		return showCommand;
	}

	public static Command createShowNext7DaysCommand() {
		ShowCommand showCommand = new ShowCommand(ShowCommand.ShowCommandType.NEXT7DAY);

		return showCommand;
	}

	public static Command createShowFloatCommand() {
		ShowCommand showCommand = new ShowCommand(ShowCommand.ShowCommandType.FLOAT);

		return showCommand;
	}

	public static Command createShowAllCommand() {
		ShowCommand showCommand = new ShowCommand(ShowCommand.ShowCommandType.ALL);

		return showCommand;
	}

	public static Command createShowCompletedCommand() {
		ShowCommand showCommand = new ShowCommand(ShowCommand.ShowCommandType.COMPLETED);

		return showCommand;
	}

	public static Command createShowCategoryCommand(String categoryName) {
		// temp
		ShowCommand showCommand = new ShowCommand(ShowCommand.ShowCommandType.CATEGORY, categoryName);

		return showCommand;
	}

	public static Command createEditCommandName(int taskId, String taskName) {
		EditTaskCommand editCommand = new EditTaskCommand(taskId, taskName);
		return editCommand;
	}

	public static Command createEditCommandDeadline(int taskId, DateTime deadline) {
		EditTaskCommand editCommand = new EditTaskCommand(taskId, deadline);
		return editCommand;
	}

	public static Command createEditCommandEvent(int taskId, DateTime start, DateTime end) {
		EditTaskCommand editCommand = new EditTaskCommand(taskId, start, end);
		return editCommand;
	}

	public static Command createEditCommandNameAndDeadline(int taskId, String taskName, DateTime deadline) {
		EditTaskCommand editCommand = new EditTaskCommand(taskId, taskName, deadline);
		return editCommand;
	}

	public static Command createEditCommandNameAndEvent(int taskId, String taskName, DateTime start, DateTime end) {
		EditTaskCommand editCommand = new EditTaskCommand(taskId, taskName, start, end);
		return editCommand;
	}

	public static Command createStorageCommand(String path) {
		StorageCommand storageCommand = new StorageCommand(path);
		return storageCommand;
	}

	public static Command createChangeThemeCommand(String themeString) {
		ChangeThemeCommand changeThemeCommand = new ChangeThemeCommand(themeString);
		return changeThemeCommand;
	}

	public static Command createUndoCommand() {
		UndoCommand undoCommand = new UndoCommand();
		return undoCommand;
	}

	public static Command createRedoCommand() {
		RedoCommand undoCommand = new RedoCommand();
		return undoCommand;
	}

	public static Command createSearchCommand(String searchString) {
		SearchCommand searchCommand = new SearchCommand(searchString);
		return searchCommand;
	}

	public static Command createClearCommand() {
		ClearTaskCommand clearCommand = new ClearTaskCommand();
		return clearCommand;
	}

	public static Command createHelpCommand() {
		HelpCommand undoCommand = new HelpCommand();
		return undoCommand;
	}

	public static Command createInvalidCommand(String errorMessage) {
		InvalidCommand invalidCommand = new InvalidCommand(errorMessage);
		return invalidCommand;
	}

	public static Command createExitCommand() {
		ExitCommand exitCommand = new ExitCommand();
		return exitCommand;
	}

}
```
###### src\dooyit\logic\commands\DeleteCategoryCommand.java
``` java
package dooyit.logic.commands;

import java.util.ArrayList;

import dooyit.common.datatype.Category;
import dooyit.common.datatype.Task;
import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class DeleteCategoryCommand implements Command, ReversibleCommand {

	private String categoryName;
	Category removedCategory;
	ArrayList<Task> removedTask;
	private boolean hasError = false;

	public DeleteCategoryCommand(String categoryName) {
		this.categoryName = categoryName;
	}

	public boolean hasError() {
		return hasError;
	}

	public void undo(LogicController logic) {
		logic.loadTasks(removedTask);
		logic.addCategory(removedCategory);
	}

	public void redo(LogicController logic) {
		logic.removeCategory(removedCategory);
		for (Task task : removedTask) {
			logic.removeTask(task);
		}
	}

	public LogicAction execute(LogicController logic) throws IncorrectInputException {
		assert (logic != null);
		LogicAction logicAction;

		if (logic.containsCategory(categoryName)) {
			removedCategory = logic.removeCategory(categoryName);
			removedTask = logic.removeTasksWithCategory(removedCategory);
			logicAction = new LogicAction(Action.DELETE_CATEGORY);
		} else {
			logicAction = new LogicAction(Action.ERROR);
			hasError = true;
			throw new IncorrectInputException("Category: " + categoryName + " doesn't exist.");
		}
		return logicAction;
	}

}
```
###### src\dooyit\logic\commands\DeleteTaskCommand.java
``` java
package dooyit.logic.commands;

import java.util.ArrayList;

import dooyit.common.datatype.Task;
import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class DeleteTaskCommand implements Command, ReversibleCommand {

	private ArrayList<Integer> deleteIds;
	private ArrayList<Task> deletedTasks;
	private boolean hasError = false;

	public DeleteTaskCommand(int deleteId) {
		this.deleteIds = new ArrayList<Integer>();
		this.deletedTasks = new ArrayList<Task>();
		this.deleteIds.add(deleteId);
	}

	public DeleteTaskCommand(ArrayList<Integer> deleteIds) {
		this.deleteIds = new ArrayList<Integer>();
		this.deletedTasks = new ArrayList<Task>();
		this.deleteIds.addAll(deleteIds);
	}

	public boolean hasError() {
		return hasError;
	}

	public void undo(LogicController logic) {

		for (Task deletedTask : deletedTasks) {
			logic.addTask(deletedTask);
		}
	}

	public void redo(LogicController logic) {
		for (Task deletedTask : deletedTasks) {
			logic.removeTask(deletedTask);
		}
	}

	public LogicAction execute(LogicController logic) throws IncorrectInputException {
		assert (logic != null);
		LogicAction logicAction = null;

		String errorMessageBody = "";

		for (Integer deleteId : deleteIds) {
			if (logic.containsTask(deleteId)) {
				Task deletedTask = logic.removeTask(deleteId);
				deletedTasks.add(deletedTask);

				logicAction = new LogicAction(Action.DELETE_TASK);
			} else {
				errorMessageBody += " " + "[" + deleteId + "]";
			}
		}

		if (errorMessageBody != "") {
			logicAction = new LogicAction(Action.DELETE_TASK);
			throw new IncorrectInputException("Index" + errorMessageBody + " doesn't exists");
		}

		return logicAction;
	}
}
```
###### src\dooyit\logic\commands\EditTaskCommand.java
``` java
package dooyit.logic.commands;

import dooyit.common.datatype.DateTime;
import dooyit.common.datatype.Task;
import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class EditTaskCommand implements Command, ReversibleCommand {

	private enum EditCommandType {
		NAME, DEADLINE, EVENT, NAME_N_DEADLINE, NAME_N_EVENT
	};

	private EditCommandType editCommandType;
	private int taskId;
	private String taskName;
	private Task originalTask;
	private Task newTask;
	private DateTime dateTimeDeadline;
	private DateTime dateTimeStart;
	private DateTime dateTimeEnd;
	private boolean hasError = false;

	public EditTaskCommand(int taskId, String taskName) {
		editCommandType = EditCommandType.NAME;
		this.taskName = taskName;
		this.taskId = taskId;
	}

	public EditTaskCommand(int taskId, DateTime deadline) {
		editCommandType = EditCommandType.DEADLINE;
		this.dateTimeDeadline = deadline;
		this.taskId = taskId;
	}

	public EditTaskCommand(int taskId, DateTime start, DateTime end) {
		editCommandType = EditCommandType.EVENT;
		this.dateTimeStart = start;
		this.dateTimeEnd = end;
		this.taskId = taskId;
	}

	public EditTaskCommand(int taskId, String taskName, DateTime deadline) {
		editCommandType = EditCommandType.NAME_N_DEADLINE;
		this.taskName = taskName;
		this.dateTimeDeadline = deadline;
		this.taskId = taskId;
	}

	public EditTaskCommand(int taskId, String taskName, DateTime start, DateTime end) {
		assert (start != null && end != null);

		editCommandType = EditCommandType.NAME_N_EVENT;
		this.taskName = taskName;
		this.dateTimeStart = start;
		this.dateTimeEnd = end;
		this.taskId = taskId;
	}

	public boolean hasError() {
		return hasError;
	}

	public void undo(LogicController logic) {
		assert (logic != null);

		logic.removeTask(newTask);
		logic.addTask(originalTask);
	}

	public void redo(LogicController logic) {
		logic.addTask(newTask);
		logic.removeTask(originalTask);
	}

	public LogicAction execute(LogicController logic) throws IncorrectInputException {
		assert (logic != null);
		LogicAction logicAction = null;

		if (!logic.containsTask(taskId)) {
			hasError = true;
			throw new IncorrectInputException("Cant find task ID: " + taskId);
		}

		// save original task for undo
		originalTask = logic.findTask(taskId);

		switch (editCommandType) {
		case NAME:
			newTask = logic.changeTaskName(taskId, taskName);
			logicAction = new LogicAction(Action.EDIT_NAME);
			break;

		case DEADLINE:
			newTask = logic.changeTaskToDeadline(taskId, dateTimeDeadline);
			logicAction = getActionBasedOnEditedTask(logic, newTask);
			break;

		case EVENT:
			newTask = logic.changeTaskToEvent(taskId, dateTimeStart, dateTimeEnd);
			logicAction = getActionBasedOnEditedTask(logic, newTask);
			break;

		case NAME_N_DEADLINE:
			logic.changeTaskName(taskId, taskName);
			newTask = logic.changeTaskToDeadline(taskId, dateTimeDeadline);
			logicAction = getActionBasedOnEditedTask(logic, newTask);
			break;

		case NAME_N_EVENT:
			logic.changeTaskName(taskId, taskName);
			newTask = logic.changeTaskToEvent(taskId, dateTimeStart, dateTimeEnd);
			logicAction = getActionBasedOnEditedTask(logic, newTask);
			break;
		}

		return logicAction;
	}

	public LogicAction getActionBasedOnEditedTask(LogicController logic, Task newTask) {
		LogicAction logicAction;

		if (logic.isFloatingTask(newTask)) {
			logicAction = new LogicAction(Action.EDIT_TO_FLOATING_TASK);
		} else if (logic.isTodayTask(newTask)) {
			logicAction = new LogicAction(Action.EDIT_TO_TODAY_TASK);

		} else if (logic.isNext7daysTask(newTask)) {
			logicAction = new LogicAction(Action.EDIT_TO_NEXT7DAY_TASK);

		} else {
			logicAction = new LogicAction(Action.EDIT_TO_ALL_TASK);
		}

		return logicAction;
	}

}
```
###### src\dooyit\logic\commands\ExitCommand.java
``` java
package dooyit.logic.commands;

import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class ExitCommand implements Command {

	private boolean hasError = false;

	public ExitCommand() {

	}

	public boolean hasError() {
		return hasError;
	}

	public LogicAction execute(LogicController logic) throws IncorrectInputException {
		LogicAction logicAction = new LogicAction(Action.EXIT);
		System.exit(1);
		return logicAction;
	}
}
```
###### src\dooyit\logic\commands\HelpCommand.java
``` java
package dooyit.logic.commands;

import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class HelpCommand implements Command {

	private boolean hasError = false;

	public HelpCommand() {

	}

	public boolean hasError() {
		return hasError;
	}

	public LogicAction execute(LogicController logic) throws IncorrectInputException {
		LogicAction logicAction = new LogicAction(Action.HELP);
		return logicAction;
	}

}
```
###### src\dooyit\logic\commands\InvalidCommand.java
``` java
package dooyit.logic.commands;

import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class InvalidCommand implements Command {
	String errorMessage;
	private boolean hasError = false;

	public InvalidCommand(String errorMessage) {
		this.errorMessage = errorMessage;
	}

	public boolean hasError() {
		return hasError;
	}

	public LogicAction execute(LogicController logic) throws IncorrectInputException {
		LogicAction logicAction = new LogicAction(Action.ERROR, errorMessage);
		hasError = true;
		return logicAction;
	}

}
```
###### src\dooyit\logic\commands\MarkTaskCommand.java
``` java
package dooyit.logic.commands;

import java.util.ArrayList;

import dooyit.common.datatype.Task;
import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class MarkTaskCommand implements Command, ReversibleCommand {
	private ArrayList<Integer> markIds;
	private ArrayList<Task> markedTasks;
	private boolean hasError = false;

	public MarkTaskCommand(int markId) {
		this.markIds = new ArrayList<Integer>();
		this.markedTasks = new ArrayList<Task>();
		this.markIds.add(markId);
	}

	public MarkTaskCommand(ArrayList<Integer> markIds) {
		this.markIds = new ArrayList<Integer>();
		this.markedTasks = new ArrayList<Task>();
		this.markIds.addAll(markIds);
	}

	public boolean hasError() {
		return hasError;
	}

	public void undo(LogicController logic) {
		for (Task markedTask : markedTasks) {
			logic.unmarkTask(markedTask);
		}
	}

	public void redo(LogicController logic) {
		for (Task markedTask : markedTasks) {
			logic.markTask(markedTask);
		}
	}

	public LogicAction execute(LogicController logic) throws IncorrectInputException {
		assert (logic != null);
		LogicAction logicAction = null;

		String errorMessageBody = "";

		for (int markId : markIds) {
			if (logic.containsTask(markId)) {
				logic.markTask(markId);
				Task markedTask = logic.findTask(markId);
				markedTasks.add(markedTask);
				logicAction = new LogicAction(Action.MARK_TASK);
			} else {
				errorMessageBody += " " + markId;
			}
		}

		if (errorMessageBody != "") {
			logicAction = new LogicAction(Action.MARK_TASK);
			throw new IncorrectInputException("Index" + errorMessageBody + " doesn't exists");
		}

		return logicAction;
	}
}
```
###### src\dooyit\logic\commands\RedoCommand.java
``` java
package dooyit.logic.commands;

import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class RedoCommand implements Command {

	private boolean hasError = false;

	public RedoCommand() {

	}

	public boolean hasError() {
		return hasError;
	}

	public LogicAction execute(LogicController logic) throws IncorrectInputException {
		assert (logic != null);
		LogicAction logicAction;

		logic.redo();

		logicAction = new LogicAction(Action.REDO);
		return logicAction;
	}

}
```
###### src\dooyit\logic\commands\RemoveCategoryFromTaskCommand.java
``` java
package dooyit.logic.commands;

import dooyit.common.datatype.Category;
import dooyit.common.datatype.Task;
import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class RemoveCategoryFromTaskCommand implements Command, ReversibleCommand {

	private String categoryName;
	private int taskId;
	private Task taskWithoutCat;
	private Category category;
	private boolean hasError = false;

	public RemoveCategoryFromTaskCommand(String categoryName, int taskId) {
		this.categoryName = categoryName;
		this.taskId = taskId;
	}

	public boolean hasError() {
		return hasError;
	}

	public void undo(LogicController logic) {
		taskWithoutCat.removeCategory();
	}

	public void redo(LogicController logic) {
		taskWithoutCat.setCategory(category);
	}

	public LogicAction execute(LogicController logic) throws IncorrectInputException {
		assert (logic != null);
		LogicAction logicAction;

		if (!logic.containsTask(taskId)) {
			hasError = true;
			logicAction = new LogicAction(Action.ERROR, "Index: " + taskId + "doesn't exist.");
			return logicAction;
		}

		if (!logic.containsCategory(categoryName)) {
			hasError = true;
			logicAction = new LogicAction(Action.ERROR, "Category: " + categoryName + " doesn't exist.");
			return logicAction;
		}

		taskWithoutCat = logic.findTask(taskId);
		category = logic.findCategory(categoryName);
		taskWithoutCat.setCategory(category);
		logicAction = new LogicAction(Action.REMOVE_CAT_FROM_TASK);

		return logicAction;
	}

}
```
###### src\dooyit\logic\commands\ReversibleCommand.java
``` java
package dooyit.logic.commands;

import dooyit.logic.api.LogicController;

public interface ReversibleCommand {

	public void undo(LogicController logic);

	public void redo(LogicController logic);
}
```
###### src\dooyit\logic\commands\SearchCommand.java
``` java
package dooyit.logic.commands;

import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class SearchCommand implements Command {
	private String searchString;
	private boolean hasError = false;

	public SearchCommand(String searchString) {
		this.searchString = searchString;
	}

	public boolean hasError() {
		return hasError;
	}

	public LogicAction execute(LogicController logic) throws IncorrectInputException {
		// logic.setActiveViewSearch(searchString);
		logic.setSearchKey(searchString);
		LogicAction logicAction = new LogicAction(Action.SEARCH);
		return logicAction;
	}

}
```
###### src\dooyit\logic\commands\SetCategoryCommand.java
``` java
package dooyit.logic.commands;

import java.util.ArrayList;

import dooyit.common.datatype.Category;
import dooyit.common.datatype.Task;
import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class SetCategoryCommand implements Command, ReversibleCommand {

	private String categoryName;
	private ArrayList<Integer> taskIds;
	private ArrayList<Task> tasksWithCategory;
	private Category settedCategory;
	private Category prevCategory;
	private boolean isNewCatCreated;
	private boolean hasError = false;

	public SetCategoryCommand(int taskId, String categoryName) {
		this.taskIds = new ArrayList<Integer>();
		this.taskIds.add(taskId);
		this.categoryName = categoryName;
	}

	public SetCategoryCommand(ArrayList<Integer> taskIds, String categoryName) {
		this.taskIds = new ArrayList<Integer>();
		this.taskIds.addAll(taskIds);
		this.categoryName = categoryName;
	}

	public boolean hasError() {
		return hasError;
	}

	public void undo(LogicController logic) {
		for (Task task : tasksWithCategory) {
			task.setCategory(prevCategory);
		}

		if (isNewCatCreated) {
			logic.removeCategory(settedCategory);
		}
	}

	public void redo(LogicController logic) {
		for (Task task : tasksWithCategory) {
			task.setCategory(settedCategory);
		}

		if (isNewCatCreated) {
			logic.addCategory(settedCategory);
		}
	}

	public LogicAction execute(LogicController logic) throws IncorrectInputException {
		assert (logic != null);
		LogicAction logicAction = null;
		tasksWithCategory = new ArrayList<Task>();

		for (int taskId : taskIds) {
			if (logic.containsTask(taskId)) {
				if (logic.containsCategory(categoryName)) {
					isNewCatCreated = false;
					settedCategory = logic.findCategory(categoryName);
					Task task = logic.findTask(taskId);
					prevCategory = task.getCategory();
					task.setCategory(settedCategory);
					tasksWithCategory.add(task);
					logicAction = new LogicAction(Action.SET_CATEGORY);
				} else {
					isNewCatCreated = true;
					settedCategory = logic.addCategory(categoryName);
					Task task = logic.findTask(taskId);
					prevCategory = task.getCategory();
					task.setCategory(settedCategory);
					tasksWithCategory.add(task);
					logicAction = new LogicAction(Action.ADD_CATEGORY);
					throw new IncorrectInputException("Category: " + categoryName + " is created.");
				}
			} else {
				logicAction = new LogicAction(Action.ERROR);
				hasError = true;
				throw new IncorrectInputException("TaskID: " + taskId + " doesn't exist.");
			}
		}

		return logicAction;
	}

}
```
###### src\dooyit\logic\commands\ShowCommand.java
``` java
package dooyit.logic.commands;

import dooyit.common.datatype.Category;
import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class ShowCommand implements Command {

	public enum ShowCommandType {
		TODAY, NEXT7DAY, FLOAT, ALL, COMPLETED, CATEGORY
	}

	String categoryName;
	ShowCommandType showCommandType;
	private boolean hasError = false;

	public ShowCommand(ShowCommandType showCommandType) {
		this.showCommandType = showCommandType;
	}

	public ShowCommand(ShowCommandType showCommandType, String categoryName) {
		this.showCommandType = showCommandType;
		this.categoryName = categoryName;
	}

	public boolean hasError() {
		return hasError;
	}

	public LogicAction execute(LogicController logic) throws IncorrectInputException {
		assert (logic != null);

		LogicAction logicAction = null;

		switch (showCommandType) {
		case TODAY:
			logicAction = new LogicAction(Action.SHOW_TODAY_TASK);
			break;

		case NEXT7DAY:
			logicAction = new LogicAction(Action.SHOW_NEXT7DAY_TASK);
			break;

		case FLOAT:
			logicAction = new LogicAction(Action.SHOW_FLOATING_TASK);
			break;

		case ALL:
			logicAction = new LogicAction(Action.SHOW_ALL_TASK);
			break;

		case COMPLETED:
			logicAction = new LogicAction(Action.SHOW_COMPLETED);
			break;

		case CATEGORY:
			if (logic.containsCategory(categoryName)) {
				Category category = logic.findCategory(categoryName);
				logic.setSelectedCategory(category);
				logicAction = new LogicAction(Action.SHOW_CATEGORY);
			} else {
				logicAction = new LogicAction(Action.ERROR, "Category not found.");
			}
			break;
		}

		return logicAction;
	}

}
```
###### src\dooyit\logic\commands\StorageCommand.java
``` java
package dooyit.logic.commands;

import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class StorageCommand implements Command, ReversibleCommand {

	private String path;
	private String previousPath;
	private boolean hasError = false;

	public StorageCommand(String path) {
		this.path = path;
	}

	public boolean hasError() {
		return hasError;
	}

	public void undo(LogicController logic) {
		boolean fileExist = logic.setFileDestinationPath(previousPath);

		if (fileExist) {
			logic.loadFromStorage();
		}
	}

	public void redo(LogicController logic) {
		boolean fileExist = logic.setFileDestinationPath(path);

		if (fileExist) {
			logic.loadFromStorage();
		}
	}

	public LogicAction execute(LogicController logic) throws IncorrectInputException {
		assert (logic != null);
		LogicAction logicAction;

		try {
			previousPath = logic.getFilePath();
			boolean fileExist = logic.setFileDestinationPath(path);
			if (fileExist) {
				logic.loadFromStorage();
			}
		} catch (IncorrectInputException e) {
			logicAction = new LogicAction(Action.ERROR);
			hasError = true;
			throw new IncorrectInputException("Invalid path: " + path);
		}

		logicAction = new LogicAction(Action.SET_STORAGE_PATH);
		return logicAction;
	}

}
```
###### src\dooyit\logic\commands\UndoCommand.java
``` java
package dooyit.logic.commands;

import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class UndoCommand implements Command {

	private boolean hasError = false;

	public UndoCommand() {

	}

	public boolean hasError() {
		return hasError;
	}

	public LogicAction execute(LogicController logic) throws IncorrectInputException {
		assert (logic != null);
		LogicAction logicAction;

		logic.undo();

		logicAction = new LogicAction(Action.UNDO);
		return logicAction;
	}

}
```
###### src\dooyit\logic\commands\UnmarkTaskCommand.java
``` java
package dooyit.logic.commands;

import java.util.ArrayList;

import dooyit.common.datatype.Task;
import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class UnmarkTaskCommand implements Command, ReversibleCommand {

	private ArrayList<Integer> unmarkIds;
	private ArrayList<Task> unmarkedTasks;
	private boolean hasError = false;

	public UnmarkTaskCommand(int unMarkId) {
		this.unmarkIds = new ArrayList<Integer>();
		this.unmarkedTasks = new ArrayList<Task>();
		this.unmarkIds.add(unMarkId);
	}

	public UnmarkTaskCommand(ArrayList<Integer> unMarkIds) {
		this.unmarkIds = new ArrayList<Integer>();
		this.unmarkedTasks = new ArrayList<Task>();
		this.unmarkIds.addAll(unMarkIds);
	}

	public boolean hasError() {
		return hasError;
	}

	public void undo(LogicController logic) {

		for (Task unmarkedTask : unmarkedTasks) {
			logic.markTask(unmarkedTask);
		}
	}

	public void redo(LogicController logic) {
		for (Task unmarkedTask : unmarkedTasks) {
			logic.unmarkTask(unmarkedTask);
		}
	}

	public LogicAction execute(LogicController logic) throws IncorrectInputException {
		assert (logic != null);
		LogicAction logicAction = null;

		String errorMessageBody = "";

		for (int unmarkId : unmarkIds) {
			if (logic.containsTask(unmarkId)) {
				logic.unmarkTask(unmarkId);
				Task unmarkedTask = logic.findTask(unmarkId);
				unmarkedTasks.add(unmarkedTask);
				logicAction = new LogicAction(Action.UNMARK_TASK);
			} else {
				errorMessageBody += " " + unmarkId;
			}
		}

		if (errorMessageBody != "") {
			logicAction = new LogicAction(Action.UNMARK_TASK);
			throw new IncorrectInputException("Index" + errorMessageBody + " doesn't exists");
		}

		return logicAction;
	}
}
```
###### src\dooyit\logic\Constants.java
``` java
package dooyit.logic;

public class Constants {

}
```
###### src\dooyit\logic\DataManager.java
``` java
package dooyit.logic;

import java.util.ArrayList;

import dooyit.common.datatype.Category;
import dooyit.common.datatype.CategoryData;
import dooyit.common.datatype.Task;
import dooyit.common.datatype.TaskData;
import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.api.LogicController;

public class DataManager {

	public DataManager() {

	}

	public ArrayList<TaskData> convertTaskstoTaskDatas(ArrayList<Task> tasks) {
		ArrayList<TaskData> taskDatas = new ArrayList<TaskData>();

		for (Task task : tasks) {
			TaskData taskData = task.convertToData();
			taskDatas.add(taskData);
		}

		return taskDatas;
	}

	public ArrayList<CategoryData> convertCategorytoCategoryDatas(ArrayList<Category> categories) {
		ArrayList<CategoryData> categoryDatas = new ArrayList<CategoryData>();

		for (Category category : categories) {
			CategoryData categoryData = category.convertToData();
			categoryDatas.add(categoryData);
		}

		return categoryDatas;
	}

	public void loadCategoryData(LogicController logic, ArrayList<CategoryData> categoryDatas) {
		for (CategoryData categoryData : categoryDatas) {
			logic.addCategory(categoryData.getName(), categoryData.getColor());
		}
	}

	public void loadTaskData(LogicController logic, ArrayList<TaskData> taskDatas) {
		for (TaskData taskData : taskDatas) {
			Task task = taskData.convertToTask();

			if (taskData.hasCategory()) {
				Category category = logic.findCategory(taskData.getCategory());
				task.setCategory(category);
			}

			logic.addTask(task);
		}
	}

}
```
###### src\dooyit\logic\HistoryManager.java
``` java
package dooyit.logic;

import java.util.Stack;

import dooyit.logic.api.LogicController;
import dooyit.logic.commands.Command;
import dooyit.logic.commands.ReversibleCommand;

public class HistoryManager {

	private Stack<ReversibleCommand> undoHistory;
	private Stack<ReversibleCommand> redoHistory;

	public HistoryManager() {
		undoHistory = new Stack<ReversibleCommand>();
		redoHistory = new Stack<ReversibleCommand>();
	}

	public void addCommand(Command command) {
		if (command.hasError()) {
			return;
		}

		if (command instanceof ReversibleCommand) {
			undoHistory.push((ReversibleCommand) command);
		}
	}

	public void undoCommand(LogicController logic) {
		ReversibleCommand reversibleCommand;
		if (!undoHistory.isEmpty()) {
			reversibleCommand = undoHistory.pop();
			reversibleCommand.undo(logic);
			redoHistory.push(reversibleCommand);
		}
	}

	public void redoCommand(LogicController logic) {
		ReversibleCommand reversibleCommand;
		if (!redoHistory.isEmpty()) {
			reversibleCommand = redoHistory.pop();
			reversibleCommand.redo(logic);
			undoHistory.push(reversibleCommand);
		}
	}
}
```
###### src\dooyit\logic\TaskManager.java
``` java
package dooyit.logic;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;

import dooyit.common.comparator.TaskDateComparator;
import dooyit.common.comparator.TaskUniqueIdComparator;
import dooyit.common.datatype.Category;
import dooyit.common.datatype.DateTime;
import dooyit.common.datatype.DeadlineTask;
import dooyit.common.datatype.EventTask;
import dooyit.common.datatype.FloatingTask;
import dooyit.common.datatype.Task;
import dooyit.common.datatype.TaskGroup;
import dooyit.common.datatype.Task.TaskType;

public class TaskManager {
	private ArrayList<Task> tasks;

	public TaskManager() {
		tasks = new ArrayList<Task>();
	}

	public Task addFloatingTask(String data) {
		return addFloatingTask(data, false);
	}

	public Task addDeadlineTask(String data, DateTime dateTime) {
		return addDeadlineTask(data, dateTime, false);
	}

	public Task addEventTask(String data, DateTime start, DateTime end) {
		return addEventTask(data, start, end, false);
	}

	public Task addFloatingTask(String data, boolean isCompleted) {
		FloatingTask floatingTask = new FloatingTask(data);
		if (isCompleted) {
			floatingTask.mark();
		}

		tasks.add(floatingTask);

		return floatingTask;
	}

	public Task addDeadlineTask(String data, DateTime dateTime, boolean isCompleted) {
		DeadlineTask deadlineTask = new DeadlineTask(data, dateTime);
		if (isCompleted) {
			deadlineTask.mark();
		}

		tasks.add(deadlineTask);
		return deadlineTask;
	}

	public Task addEventTask(String data, DateTime start, DateTime end, boolean isCompleted) {
		EventTask eventTask = new EventTask(data, start, end);

		if (isCompleted) {
			eventTask.mark();
		}

		tasks.add(eventTask);
		return eventTask;
	}

	public void add(Task task) {
		tasks.add(task);
	}

	public void load(ArrayList<Task> tasks) {
		this.tasks.addAll(tasks);
	}

	public Task remove(int id) {
		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).getId() == id) {
				return tasks.remove(i);
			}
		}
		return null;
	}

	public boolean remove(Task task) {
		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).equals(task)) {
				tasks.remove(i);
				return true;
			}
		}
		return false;
	}

	/**
	 * Mark a task based on id
	 * 
	 * @param id
	 *            task id
	 * @return false if task is already marked
	 */
	public boolean markTask(int id) {
		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).getId() == id) {
				if (tasks.get(i).isCompleted()) {
					return false;
				} else {
					tasks.get(i).mark();
					return true;
				}
			}
		}
		// tell user if task is already marked.
		return false;
	}

	public boolean markTask(Task task) {
		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).equals(task)) {
				if (tasks.get(i).isCompleted()) {
					return false;
				} else {
					tasks.get(i).mark();
					return true;
				}
			}
		}
		// tell user if task is already marked.
		return false;
	}

	public boolean unmarkTask(int id) {
		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).getId() == id) {
				tasks.get(i).unMark();
				return true;
			}
		}
		// tell user if task is already marked.
		return false;
	}

	public boolean unmarkTask(Task task) {
		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).equals(task)) {
				tasks.get(i).unMark();
				return true;
			}
		}
		// tell user if task is already marked.
		return false;
	}

	public boolean contains(int id) {
		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).getId() == id) {
				return true;
			}
		}
		return false;
	}

	public boolean contains(Task task) {
		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).equals(task)) {
				return true;
			}
		}
		return false;
	}

	public Task find(int id) {
		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).getId() == id) {
				return tasks.get(i);
			}
		}
		return null;
	}

	public Task find(Task task) {
		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).equals(task)) {
				return tasks.get(i);
			}
		}
		return null;
	}

	public int size() {
		return tasks.size();
	}

	public ArrayList<Task> removeTasksWithCategory(Category category) {
		ArrayList<Task> taskWithCat = new ArrayList<Task>();

		Iterator<Task> itr = tasks.iterator();
		while (itr.hasNext()) {
			Task task = itr.next();

			if (task.hasCategory() && task.getCategory().equals(category)) {
				itr.remove();
				taskWithCat.add(task);
			}
		}

		return taskWithCat;
	}

	public ArrayList<Task> clear() {
		ArrayList<Task> clearedTasks = new ArrayList<Task>(tasks);
		tasks.clear();
		return clearedTasks;
	}

	public Task getMostRecentTask() {
		int latestId = Integer.MIN_VALUE;
		Task latestTask = null;

		for (Task task : tasks) {
			if (task.getUniqueId() > latestId) {
				latestId = task.getUniqueId();
				latestTask = task;
			}
		}
		return latestTask;
	}

	public Task changeTaskName(int taskId, String newName) {
		if (!contains(taskId)) {
			return null;
		}

		Task removedTask = remove(taskId);
		Task newTask = removedTask.copy();
		newTask.changeName(newName);
		add(newTask);
		return newTask;
	}

	public Task changeTaskToDeadline(int taskId, DateTime dateTimeDeadline) {
		if (!contains(taskId)) {
			return null;
		}

		Task task = remove(taskId);
		// Task newTask = addDeadlineTask(task.getName(), dateTimeDeadline,
		// task.isCompleted());
		Task newTask = new DeadlineTask(task, dateTimeDeadline);
		newTask.setCategory(task.getCategory());
		add(newTask);

		return newTask;
	}

	public Task changeTaskToEvent(int taskId, DateTime dateTimeStart, DateTime dateTimeEnd) {
		if (!contains(taskId)) {
			return null;
		}

		Task task = remove(taskId);
		// Task newTask = addEventTask(task.getName(), dateTimeStart,
		// dateTimeEnd, task.isCompleted());
		Task newTask = new EventTask(task, dateTimeStart, dateTimeEnd);
		newTask.setCategory(task.getCategory());
		add(newTask);

		return newTask;
	}

	public void offAllEventTasksMultiDayString() {
		for (Task task : tasks) {
			if (task.getTaskType() == TaskType.EVENT) {
				EventTask eventTask = (EventTask) task;
				eventTask.offMultiDay();
			}
		}
	}

	public void onAllEventTasksMultiDayString() {
		for (Task task : tasks) {
			if (task.getTaskType() == TaskType.EVENT) {
				EventTask eventTask = (EventTask) task;
				eventTask.onMultiDay();
			}
		}
	}

	public int getNoOfIncompleteEventAndDeadlineTask() {
		int size = 0;

		size += getIncompleteDeadlineTasks().size();
		size += getIncompleteEventTasksSize();

		return size;
	}

	public ArrayList<Task> getAllTasks() {
		return tasks;
	}

	public ArrayList<Task> searchTask(String searchString) {
		ArrayList<Task> searchedTasks = new ArrayList<Task>();

		for (Task task : tasks) {
			String taskName = task.getName();
			taskName = taskName.toLowerCase();
			searchString = searchString.toLowerCase();

			if (taskName.contains(searchString)) {
				searchedTasks.add(task);
			}
		}

		return searchedTasks;
	}

	public ArrayList<Task> getIncompletedTasks() {
		ArrayList<Task> allIncompleteTask = new ArrayList<Task>();

		for (Task task : tasks) {
			if (!task.isCompleted()) {
				allIncompleteTask.add(task);
			}
		}
		return allIncompleteTask;
	}

	public ArrayList<Task> getIncompletedTasks(DateTime overdueTime) {
		ArrayList<Task> allIncompleteTask = new ArrayList<Task>();

		for (Task task : tasks) {
			if (!task.isCompleted() && !task.isOverDue(overdueTime)) {
				allIncompleteTask.add(task);
			}
		}
		return allIncompleteTask;
	}

	public ArrayList<Task> getCompletedTasks() {
		ArrayList<Task> allCompletedTask = new ArrayList<Task>();

		for (Task task : tasks) {
			if (task.isCompleted()) {
				allCompletedTask.add(task);
			}
		}
		return allCompletedTask;
	}

	public ArrayList<Task> getFloatingTasks() {
		ArrayList<Task> floatingTasks = new ArrayList<Task>();

		for (Task task : tasks) {
			if (task.getTaskType() == TaskType.FLOATING) {
				floatingTasks.add(task);
			}
		}
		return floatingTasks;
	}

	public ArrayList<Task> getIncompleteFloatingTasks() {
		ArrayList<Task> floatingTasks = new ArrayList<Task>();

		for (Task task : tasks) {
			if (task.getTaskType() == TaskType.FLOATING && !task.isCompleted()) {
				floatingTasks.add(task);
			}
		}
		return floatingTasks;
	}

	public ArrayList<Task> getDeadlineTasks() {

		ArrayList<Task> deadlineTasks = new ArrayList<Task>();

		for (Task task : tasks) {
			if (task.getTaskType() == TaskType.DEADLINE) {
				deadlineTasks.add(task);
			}
		}
		return deadlineTasks;
	}

	public ArrayList<Task> getDeadlineTasks(DateTime dateTime) {

		ArrayList<Task> deadlineTasks = new ArrayList<Task>();

		for (Task task : tasks) {
			if (task.getTaskType() == TaskType.DEADLINE) {
				if (task.isSameDate(dateTime)) {
					deadlineTasks.add(task);
				}
			}
		}
		return deadlineTasks;
	}

	public ArrayList<Task> getIncompleteDeadlineTasks() {

		ArrayList<Task> deadlineTasks = new ArrayList<Task>();

		for (Task task : tasks) {
			if (task.getTaskType() == TaskType.DEADLINE) {
				if (!task.isCompleted()) {
					deadlineTasks.add(task);
				}
			}
		}
		return deadlineTasks;
	}

	public ArrayList<Task> getIncompleteDeadlineTasks(DateTime dateTime) {

		ArrayList<Task> deadlineTasks = new ArrayList<Task>();

		for (Task task : tasks) {
			if (task.getTaskType() == TaskType.DEADLINE) {
				if (task.isSameDate(dateTime) && !task.isCompleted()) {
					deadlineTasks.add(task);
				}
			}
		}
		return deadlineTasks;
	}

	public ArrayList<Task> getEventTasks() {

		ArrayList<Task> eventTasks = new ArrayList<Task>();

		for (Task task : tasks) {
			if (task.getTaskType() == TaskType.EVENT) {
				eventTasks.add(task);
			}
		}
		return eventTasks;
	}

	public ArrayList<Task> getEventTasks(DateTime dateTime) {

		ArrayList<Task> eventTasks = new ArrayList<Task>();

		for (Task task : tasks) {
			if (task.getTaskType() == TaskType.EVENT) {
				if (task.isSameDate(dateTime)) {
					eventTasks.add(task);
				}
			}
		}
		return eventTasks;
	}

	public int getIncompleteEventTasksSize() {

		int size = 0;

		for (Task task : tasks) {
			if (task.getTaskType() == TaskType.EVENT) {
				EventTask eventTask = (EventTask) task;
				if (!eventTask.isCompleted()) {
					size += eventTask.size();
				}
			}
		}
		return size;
	}

	public ArrayList<Task> getIncompleteEventTasks() {

		ArrayList<Task> eventTasks = new ArrayList<Task>();

		for (Task task : tasks) {
			if (task.getTaskType() == TaskType.EVENT) {
				if (!task.isCompleted()) {
					eventTasks.add(task);
				}
			}
		}
		return eventTasks;
	}

	public ArrayList<Task> getIncompleteEventTasks(DateTime dateTime) {

		ArrayList<Task> eventTasks = new ArrayList<Task>();

		for (Task task : tasks) {
			if (task.getTaskType() == TaskType.EVENT) {
				if (task.isSameDate(dateTime) && !task.isCompleted()) {
					eventTasks.add(task);
				}
			}
		}
		return eventTasks;
	}

	public ArrayList<Task> getOverdueTasks(DateTime dateTime) {
		ArrayList<Task> overdueTasks = new ArrayList<Task>();

		for (Task task : tasks) {
			if (task.isOverDue(dateTime)) {
				overdueTasks.add(task);
			}
		}

		return overdueTasks;
	}

	public int getOverdueTasksSize(DateTime dateTime) {
		int size = 0;

		for (Task task : tasks) {

			if (task.isOverDue(dateTime)) {
				if (task.getTaskType() == TaskType.EVENT) {
					EventTask eventTask = (EventTask) task;
					size += eventTask.size();
				} else {
					size++;
				}
			}
		}

		return size;
	}

	public ArrayList<Task> getTasksWithCategory(Category category) {
		ArrayList<Task> tasksWithCat = new ArrayList<Task>();

		for (Task task : tasks) {
			if (task.hasCategory() && task.getCategory().equals(category)) {
				tasksWithCat.add(task);
			}
		}

		return tasksWithCat;
	}

	public boolean isFloatingTask(Task task) {
		return (task instanceof FloatingTask);
	}

	public boolean isTodayTask(Task task) {
		DateTime currDate = new DateTime();
		return task.isSameDate(currDate);
	}

	public boolean isNext7DaysTask(Task task) {
		DateTime currDate = new DateTime();

		for (int i = 0; i < 7; i++) {
			if (task.isSameDate(currDate)) {
				return true;
			}
			currDate.increaseByOneDay();
		}

		return false;
	}

	public ArrayList<TaskGroup> getTaskGroupsAll() {
		onAllEventTasksMultiDayString();
		ArrayList<TaskGroup> taskGroups = new ArrayList<TaskGroup>();
		TaskGroup taskGroup;
		DateTime currDate = new DateTime();

		int numOverdueTask = getOverdueTasksSize(currDate);
		int totalSize = getNoOfIncompleteEventAndDeadlineTask() - numOverdueTask;

		addOverDueTaskGroup(taskGroups, currDate);

		taskGroup = new TaskGroup("Float");
		taskGroup.addTasks(getIncompleteFloatingTasks());
		if (!taskGroup.isEmpty()) {
			sortTask(taskGroup.getTasks());
			taskGroups.add(taskGroup);
		}

		taskGroup = new TaskGroup("Today", new DateTime(currDate));
		taskGroup.addTasks(getIncompleteDeadlineTasks(currDate));
		taskGroup.addTasks(getIncompleteEventTasks(currDate));
		if (!taskGroup.isEmpty()) {
			sortTask(taskGroup.getTasks());
			taskGroups.add(taskGroup);
			totalSize -= taskGroup.size();
		}
		currDate.increaseByOneDay();

		taskGroup = new TaskGroup("Tomorrow", new DateTime(currDate));
		taskGroup.addTasks(getIncompleteDeadlineTasks(currDate));
		taskGroup.addTasks(getIncompleteEventTasks(currDate));
		if (!taskGroup.isEmpty()) {
			sortTask(taskGroup.getTasks());
			taskGroups.add(taskGroup);
			totalSize -= taskGroup.size();
		}
		currDate.increaseByOneDay();

		while (totalSize > 0) {
			taskGroup = new TaskGroup(currDate.getDayStr(), new DateTime(currDate));
			taskGroup.addTasks(getIncompleteDeadlineTasks(currDate));
			taskGroup.addTasks(getIncompleteEventTasks(currDate));
			if (!taskGroup.isEmpty()) {
				sortTask(taskGroup.getTasks());
				taskGroups.add(taskGroup);
				totalSize -= taskGroup.size();
			}
			currDate.increaseByOneDay();
		}

		resetTasksId(taskGroups);
		return taskGroups;

	}

	public ArrayList<TaskGroup> getTaskGroupsToday() {
		onAllEventTasksMultiDayString();
		ArrayList<TaskGroup> taskGroups = new ArrayList<TaskGroup>();
		TaskGroup taskGroup;
		DateTime currDate = new DateTime();

		addOverDueTaskGroup(taskGroups, currDate);

		taskGroup = new TaskGroup("Today", currDate);
		taskGroup.addTasks(getIncompleteDeadlineTasks(currDate));
		taskGroup.addTasks(getIncompleteEventTasks(currDate));
		sortTask(taskGroup.getTasks());
		taskGroups.add(taskGroup);

		resetTasksId(taskGroups);
		return taskGroups;
	}

	public ArrayList<TaskGroup> getTaskGroupsFloating() {
		ArrayList<TaskGroup> taskGroups = new ArrayList<TaskGroup>();

		TaskGroup taskGroup = new TaskGroup("Float");
		taskGroup.addTasks(getIncompleteFloatingTasks());
		sortTask(taskGroup.getTasks());
		taskGroups.add(taskGroup);

		resetTasksId(taskGroups);
		return taskGroups;
	}

	public ArrayList<TaskGroup> getTaskGroupsCompleted() {
		offAllEventTasksMultiDayString();
		ArrayList<TaskGroup> taskGroups = new ArrayList<TaskGroup>();

		TaskGroup taskGroup = new TaskGroup("Completed");
		taskGroup.addTasks(getCompletedTasks());
		sortTask(taskGroup.getTasks());
		taskGroups.add(taskGroup);

		resetTasksId(taskGroups);
		return taskGroups;
	}

	public ArrayList<TaskGroup> getTaskGroupsNext7Days() {
		onAllEventTasksMultiDayString();
		DateTime currDate = new DateTime();
		ArrayList<TaskGroup> taskGroups = new ArrayList<TaskGroup>();
		TaskGroup taskGroup;

		addOverDueTaskGroup(taskGroups, currDate);

		String title;
		for (int i = 1; i <= 7; i++) {
			if (i == 1) {
				title = "Today";
			} else if (i == 2) {
				title = "Tomorrow";
			} else {
				title = currDate.getDayStr();
			}

			taskGroup = new TaskGroup(title, new DateTime(currDate));
			taskGroup.addTasks(getIncompleteDeadlineTasks(currDate));
			taskGroup.addTasks(getIncompleteEventTasks(currDate));
			sortTask(taskGroup.getTasks());
			taskGroups.add(taskGroup);
			currDate.increaseByOneDay();
		}

		resetTasksId(taskGroups);
		return taskGroups;
	}

	public ArrayList<TaskGroup> getTaskGroupCategory(Category category) {
		ArrayList<TaskGroup> taskGroups = new ArrayList<TaskGroup>();
		TaskGroup taskGroup = new TaskGroup(category.getName());
		taskGroup.addTasks(getTasksWithCategory(category));
		sortTask(taskGroup.getTasks());
		taskGroups.add(taskGroup);

		resetTasksId(taskGroups);
		return taskGroups;
	}

	public ArrayList<TaskGroup> getTaskGroupSearched(String searchString) {
		ArrayList<TaskGroup> taskGroups = new ArrayList<TaskGroup>();
		ArrayList<Task> searchedTasks = searchTask(searchString);

		TaskGroup taskGroup = new TaskGroup("Search List");
		taskGroup.addTasks(searchedTasks);

		taskGroups.add(taskGroup);

		resetTasksId(taskGroups);
		return taskGroups;
	}

	public void addOverDueTaskGroup(ArrayList<TaskGroup> taskGroups, DateTime currDate) {
		ArrayList<Task> overdueTasks = getOverdueTasks(currDate);
		if (!overdueTasks.isEmpty()) {
			TaskGroup taskGroup = new TaskGroup("Overdue");
			taskGroup.addTasks(getOverdueTasks(currDate));
			sortTask(taskGroup.getTasks());
			taskGroups.add(taskGroup);
		}
	}

	public void addTodayTaskGroup(ArrayList<TaskGroup> taskGroups, DateTime currDate) {
		ArrayList<Task> overdueTasks = getOverdueTasks(currDate);
		if (!overdueTasks.isEmpty()) {
			TaskGroup taskGroup = new TaskGroup("Overdue");
			taskGroup.addTasks(getOverdueTasks(currDate));
			sortTask(taskGroup.getTasks());
			taskGroups.add(taskGroup);
		}
	}

	public void sortTask(ArrayList<Task> tasks) {
		TaskUniqueIdComparator uniqueIdComparator = new TaskUniqueIdComparator();
		Collections.sort(tasks, uniqueIdComparator);

		TaskDateComparator dateComparator = new TaskDateComparator();
		Collections.sort(tasks, dateComparator);
	}

	public void resetTasksId(ArrayList<TaskGroup> taskGroups) {
		clearOldId();
		assignNewId(taskGroups);
	}

	/**
	 * 
	 */
	public void clearOldId() {
		for (Task task : tasks) {
			task.resetId();
		}
	}

	/**
	 * @param taskGroups
	 */
	public void assignNewId(ArrayList<TaskGroup> taskGroups) {
		int taskId = 1;

		for (TaskGroup taskGroup : taskGroups) {
			ArrayList<Task> tasks = taskGroup.getTasks();
			for (Task task : tasks) {
				task.setId(taskId++);
			}
		}
	}

	public void display() {
		System.out.println();
		System.out.println("Task List");

		for (Task task : tasks) {
			System.out.println(task.getId() + ": " + task);
		}

		System.out.println();
	}
}
```
