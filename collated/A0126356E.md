# A0126356E
###### src\dooyit\common\datatype\Category.java
``` java
public class Category {
	private String name;

	private CustomColor customColor;

	public Category(String name) {
		this.name = name;
		this.customColor = CustomColor.BLUE;
	}

	public Category(String name, CustomColor customColour) {
		this.name = name;
		this.customColor = customColour;
	}

	public String getName() {
		return this.name;
	}

	public Color getColour() {
		return customColor.getColor();
	}
	
	public CustomColor getCustomColour() {
		return customColor;
	}

	@Override
	public boolean equals(Object o) {
		if (o instanceof String) {
			String categoryName = (String) o;
			return getName().toLowerCase().equals(categoryName.toLowerCase());
		} else if (o instanceof Category) {
			Category category = (Category) o;
			return getName().toLowerCase().equals(category.getName().toLowerCase());
		}
		return false;
	}

	@Override
	public String toString() {
		return name + " " + customColor.toString();
	}
}
```
###### src\dooyit\common\datatype\CustomColor.java
``` java
public class CustomColor {
	public float r; // red
	public float g; // green
	public float b; // blue
	public String name; // colour name
	
	public CustomColor(String name, float r, float g, float b) {
		this.name = name;
		this.r = r / 255.0f;
		this.g = g / 255.0f;
		this.b = b / 255.0f;
	}

	public static final CustomColor BLACK = new CustomColor("black", 40, 40, 40);
	public static final CustomColor BLUE = new CustomColor("blue", 26, 214, 253);
	public static final CustomColor CYAN = new CustomColor("cyan", 82, 237, 199);
	public static final CustomColor GREY = new CustomColor("grey", 219, 221, 222);
	public static final CustomColor GREEN = new CustomColor("green", 135, 252, 125);
	public static final CustomColor MAGENTA = new CustomColor("magenta", 239, 77, 182);
	public static final CustomColor PINK = new CustomColor("pink", 255, 73, 129);
	public static final CustomColor RED = new CustomColor("red", 255, 58, 84);
	public static final CustomColor YELLOW = new CustomColor("yellow", 255, 204, 0);
	public static final CustomColor WHITE = new CustomColor("white", 247, 247, 247);

	public Color getColor(){
		return Color.color(r, g, b);
	}
	
	public String getName(){
		return name;
	}
	
	@Override
	public boolean equals(Object o) {
		if(o instanceof String){
			String colourString = (String)o;
			return name.equals(colourString);
		}
		
		if (o instanceof CustomColor) {
			CustomColor colour = (CustomColor) o;
			return r == colour.r && g == colour.g && b == colour.b;
		}
		
		return false;
	}

	@Override
	public String toString() {
		return "Colour: " + r + "," + g + "," + b;
	}

	public String toSavableString() {
		return this.r + " " + this.g + " " + this.b;
	}
	
	
}
```
###### src\dooyit\common\datatype\DeadlineTask.java
``` java
public class DeadlineTask extends Task {

	DateTime dateTimeDeadline;
	
	public DeadlineTask(String taskName, DateTime deadline){
		assert (deadline != null);

		taskType = TaskType.DEADLINE;
		this.taskName = taskName;
		this.dateTimeDeadline = deadline;
	}
	
	public DateTime getDateTimeDeadline() {
		return dateTimeDeadline;
	}
	
	@Override
	public String getDateString(){
		if(dateTimeDeadline.hasTime()){
			return dateTimeDeadline.getTime24hStr();
		}
		else{
			return "";
		}
	}
	
	@Override
	public String toString() {
		return taskName + ": deadline: " + dateTimeDeadline.toString();
	}
	
	@Override
	public boolean equals(Object o) {
		if (o instanceof DeadlineTask) {
			DeadlineTask deadlineTask = (DeadlineTask) o;
			return this.getName() == deadlineTask.getName() 
					&& this.getDateTimeDeadline().equals(deadlineTask.getDateTimeDeadline());
		}
		return false;
	}
}
```
###### src\dooyit\common\datatype\EventTask.java
``` java
public class EventTask extends Task {

	private DateTime dateTimeStart;
	private DateTime dateTimeEnd;

	public EventTask(String taskName, DateTime start, DateTime end) {
		assert (start != null && end != null);

		taskType = TaskType.EVENT;
		this.taskName = taskName;
		this.dateTimeStart = start;
		this.dateTimeEnd = end;
	}

	public DateTime getDateTimeStart() {
		return dateTimeStart;
	}

	public DateTime getDateTimeEnd() {
		return dateTimeEnd;
	}

	@Override
	public String getDateString() {
		return dateTimeStart.getTime24hStr() + " to " + dateTimeEnd.getTime24hStr();
	}

	@Override
	public String toString() {
		return taskName + ": event: " + dateTimeStart.toString() + "," + dateTimeEnd.toString();
	}

	@Override
	public boolean equals(Object o) {
		if (o instanceof EventTask) {
			EventTask eventTask = (EventTask) o;
			return this.getName() == eventTask.getName() 
					&& this.getDateTimeStart().equals(eventTask.getDateTimeStart())
					&& this.getDateTimeEnd().equals(eventTask.getDateTimeEnd());
		}
		return false;
	}
}
```
###### src\dooyit\common\datatype\FloatingTask.java
``` java
public class FloatingTask extends Task {

	public FloatingTask(String taskName){
		taskType = TaskType.FLOATING;
		this.taskName = taskName;
	}
	
	@Override
	public String getDateString(){
		return "";
	}
	
	@Override
	public String toString() {
		return taskName;
	}
	
	@Override
	public boolean equals(Object o){
		if(o instanceof FloatingTask){
			FloatingTask floatingTask = (FloatingTask)o;
			return this.getName() == floatingTask.getName();
		}
		return false;
	}
}
```
###### src\dooyit\common\datatype\Task.java
``` java
public abstract class Task {

	public enum TaskType {
		DEADLINE, EVENT, FLOATING
	};

	protected String taskName;
	protected int taskId;
	protected TaskType taskType;
	
	protected boolean isCompleted;
	protected Category category;

	public static int curTaskId = 1;

	public Task() {
		taskId = curTaskId++;
	}

	public void changeName(String taskName) {
		this.taskName = taskName;
	}

	public void mark() {
		isCompleted = true;
	}

	public void unMark() {
		isCompleted = false;
	}

	public boolean isCompleted() {
		return isCompleted;
	}
	
	public boolean isOverDue(DateTime dateTime){
		
		return true;
	}

	public boolean setCategory(Category category) {
		assert (category != null);

		if(hasCategory()){
			return false;
		}else{
			this.category = category;
			return true;
		}
	}
	
	public Category getCategory(){
		return category;
	}
	
	public boolean hasCategory(){
		return category != null;
	}

	public String getName() {
		return taskName;
	}

	public int getId() {
		return taskId;
	}

	public TaskType getTaskType() {
		return taskType;
	}

	@Override
	public boolean equals(Object o) {
		if (o instanceof Task) {
			Task task = (Task) o;
			return task.getId() == taskId;
		} else {
			return false;
		}
	}
	
	public abstract String getDateString();
}
```
###### src\dooyit\common\datatype\TaskGroup.java
``` java
public class TaskGroup {

	private String title;
	private ArrayList<Task> tasks;
	private DateTime dateTime;

	public TaskGroup(String title) {
		this.title = title;
		tasks = new ArrayList<Task>();
	}

	public TaskGroup(String title, ArrayList<Task> tasks) {
		this.tasks = new ArrayList<Task>();
		this.title = title;
		addTasks(tasks);
	}

	public TaskGroup(String title, ArrayList<Task> tasks, DateTime dateTime) {
		this.tasks = new ArrayList<Task>();
		this.title = title;
		this.dateTime = dateTime;
		addTasks(tasks);
	}

	public TaskGroup(String title, ArrayList<Task> tasks1, ArrayList<Task> tasks2, DateTime dateTime) {
		this.tasks = new ArrayList<Task>();
		this.title = title;
		this.dateTime = dateTime;
		addTasks(tasks1);
		addTasks(tasks2);
	}

	public void addTask(Task task) {
		this.tasks.add(task);
	}

	public void addTasks(ArrayList<Task> tasks) {
		for (Task task : tasks) {
			this.tasks.add(task);
		}
	}

	public DateTime getDateTime() {
		return dateTime;
	}

	public void setTitle(String title) {
		this.title = title;
	}
	
	public String getTitle() {
		if(hasDateTime()){
			String dateString = dateTime.getDate();
			dateString = dateString.substring(0, dateString.length() - 5);
			return title + ", " + dateString;
		}else{
			return title;
		}
	}

	public ArrayList<Task> getTasks() {

		return tasks;
	}

	public boolean hasDateTime() {
		return dateTime != null;
	}
}
```
###### src\dooyit\common\exception\IncorrectInputException.java
``` java
public class IncorrectInputException extends RuntimeException {

	public IncorrectInputException() {
		super();
	}

	public IncorrectInputException(String s) {
		super(s);
	}

	public IncorrectInputException(String s, Throwable throwable) {
		super(s, throwable);
	}

	public IncorrectInputException(Throwable throwable) {
		super(throwable);
	}
}
```
###### src\dooyit\logic\api\CategoryManager.java
``` java
public class CategoryManager {
	ArrayList<Category> categories;
	ColourManager colourManager;

	public CategoryManager() {
		colourManager = ColourManager.getInstance();
		categories = new ArrayList<Category>();
		setDefaultCategories();
	}

	private void setDefaultCategories() {
		if (categories.size() == 0) {
			addCategory("School");
			addCategory("Entertainment");
		}
	}

	public Category addCategory(String categoryName) {
		if (findCategory(categoryName) != null) {
			return null;
		}
		
		categoryName = capitalizeFirstCharacter(categoryName);
		Category category = new Category(categoryName, colourManager.pickRandomColour());
		categories.add(category);
		return category;
	}

	public Category addCategory(String categoryName, CustomColor colour) {
		if (findCategory(categoryName) != null) {
			return null;
		}
		
		categoryName = capitalizeFirstCharacter(categoryName);
		Category category = new Category(categoryName, colour);
		categories.add(category);
		return category;
	}

	public boolean contains(String categoryName) {
		for (int i = 0; i < categories.size(); i++) {
			if(categories.get(i).equals(categoryName)){
				return true;
			}
		}
		return false;
	}

	public boolean contains(Category category) {
		for (int i = 0; i < categories.size(); i++) {
			if(categories.get(i).equals(category)){
				return true;
			}
		}
		return false;
	}
	
	public Category findCategory(String categoryName) {
		for (int i = 0; i < categories.size(); i++) {
			if (categories.get(i).equals(categoryName)) {
				return categories.get(i);
			}
		}
		return null;
	}
	
	public Category findCategory(Category category) {
		for (int i = 0; i < categories.size(); i++) {
			if (categories.get(i).equals(category)) {
				return categories.get(i);
			}
		}
		return null;
	}

	public ArrayList<Category> getCategoryList() {
		return categories;
	}
	
	private String capitalizeFirstCharacter(String categoryName){
		assert(categoryName != null);
		
		if(categoryName == ""){
			return "";
		}
		
		categoryName = categoryName.toLowerCase();
		char capitalFirstLetter = Character.toUpperCase(categoryName.charAt(0));
		String string = capitalFirstLetter + categoryName.substring(1);
		
		return string;
	}
}
```
###### src\dooyit\logic\api\ColourManager.java
``` java
public class ColourManager {
	ArrayList<CustomColor> usedColours;
	Random random;
	ArrayList<CustomColor> recommendedColours;
	ArrayList<CustomColor> availableColours;
	ArrayList<CustomColor> colourPool;

	private static ColourManager colourManager = new ColourManager();
	
	public static ColourManager getInstance(){
		return colourManager;
	}
	
	private ColourManager() {
		random = new Random();
		availableColours = new ArrayList<CustomColor>();
		availableColours.add(CustomColor.BLACK);
		availableColours.add(CustomColor.BLUE);
		availableColours.add(CustomColor.CYAN);
		availableColours.add(CustomColor.GREY);
		availableColours.add(CustomColor.GREEN);
		availableColours.add(CustomColor.MAGENTA);
		availableColours.add(CustomColor.PINK);
		availableColours.add(CustomColor.RED);
		availableColours.add(CustomColor.YELLOW);
		availableColours.add(CustomColor.WHITE);
		
		recommendedColours = new ArrayList<CustomColor>();
		recommendedColours.add(CustomColor.BLUE);
		recommendedColours.add(CustomColor.CYAN);
		recommendedColours.add(CustomColor.GREEN);
		recommendedColours.add(CustomColor.MAGENTA);
		recommendedColours.add(CustomColor.PINK);
		recommendedColours.add(CustomColor.RED);
		recommendedColours.add(CustomColor.YELLOW);
		recommendedColours.add(CustomColor.GREY);

		colourPool = new ArrayList<CustomColor>(recommendedColours);
	}

	public CustomColor pickRandomColour() {
		if (colourPool.size() == 0) {
			colourPool = new ArrayList<CustomColor>(recommendedColours);
		}
		return colourPool.remove(random.nextInt(colourPool.size()));
	}
	
	public boolean contains(String name){
		for(CustomColor customColor : availableColours){
			if(customColor.equals(name)){
				return true;
			}
		}
		return false;
	}
	
	public boolean contains(CustomColor customColor){
		boolean hasCustomColor = availableColours.contains(customColor);
		return hasCustomColor;
	}
	
	
	
	public CustomColor find(String customColorString){
		for(CustomColor customColor : availableColours){
			if(customColor.equals(customColorString)){
				return customColor;
			}
		}
		return null;
	}
	
}
```
###### src\dooyit\logic\api\Constants.java
``` java
public class Constants {

}
```
###### src\dooyit\logic\api\LogicController.java
``` java
public class LogicController {

	private Parser parser;
	private TaskManager taskManager;
	private CategoryManager categoryManager;
	private StorageController storage;
	private Stack<ReversibleCommand> history;
	private UIController uiController;
	private static Logger logger = Logger.getLogger("Logic");

	private boolean isSaveOn;

	public LogicController() {
		logger.log(Level.INFO, "Initialising logic class");

		parser = new Parser();
		taskManager = new TaskManager();
		categoryManager = new CategoryManager();
		history = new Stack<ReversibleCommand>();
		isSaveOn = true;

		try {
			storage = new StorageController();
		} catch (IOException e) {
			logger.log(Level.SEVERE, "ERROR: Fail to create storage");
			uiController.displayMessage("ERROR: CREATING STORAGE");
		}

		// try {
		// categoryManager.categories = storage.loadCategory();
		// } catch (IOException e) {
		// System.out.println("ERROR: LOAD CATEGORY");
		// uiController.displayMessage("ERROR: LOAD CATEGORY");
		// }

		try {
			ArrayList<Task> tasks = storage.loadTasks();
			taskManager.loadTask(tasks);
		} catch (IOException e) {
			logger.log(Level.SEVERE, "ERROR: Fail to load task from storage");
			uiController.displayMessage("ERROR: LOAD TASK");
		}

		logger.log(Level.INFO, "End of initialising logic class");
	}

	/**
	 * process and execute command input from user
	 * 
	 * @param input
	 */
	public void processCommand(String input) {
		Command command = parser.getCommand(input);

		assert (command != null);

		try {
			command.execute(this);
		} catch (IncorrectInputException e) {
			uiController.displayMessage(e.getMessage());
		}

		if (command instanceof ReversibleCommand) {
			history.push((ReversibleCommand) command);
		}

		refreshUIController();

		save();

		// update UI - UI.update();
		taskManager.display();
	}

	private void save() {
		if (!isSaveOn) {
			return;
		}
		
		try {
			storage.saveTasks(taskManager.getAllTasks());
		} catch (IOException e) {
			logger.log(Level.SEVERE, "ERROR: Fail to save");
			uiController.displayMessage("ERROR: SAVING");
		}
	}

	public void enableSave() {
		isSaveOn = true;
	}

	public void disableSave() {
		isSaveOn = false;
	}

	public void clearTask() {
		taskManager.clear();
		save();
	}

	private void refreshUIController() {
		// uiController.refreshMainView(taskManager.getTaskGroupsToday());
		// if (uiController == null)
		// return;

		UIMainViewType uiMainViewType = uiController.getActiveViewType();

		switch (uiMainViewType) {

		case TODAY:
			uiController.refreshMainView(taskManager.getTaskGroupsToday());
			break;

		case EXTENDED:
			uiController.refreshMainView(taskManager.getTaskGroupsNext7Days());
			break;

		case ALL:
			uiController.refreshMainView(taskManager.getTaskGroupsAll());
			break;

		case COMPLETED:
			uiController.refreshMainView(taskManager.getTaskGroupsCompleted());
			break;

		case FLOAT:
			uiController.refreshMainView(taskManager.getTaskGroupsFloating());
			break;

		case CATEGORY:

			break;
		}

		uiController.refreshCategoryMenuView(categoryManager.getCategoryList());
	}

	/**
	 * pass the uicontroller references to this class
	 * 
	 * @param ui
	 */
	public void setUIController(UIController ui) {
		this.uiController = ui;
		refreshUIController();
	}

	/**
	 * Get the TaskManager object
	 * 
	 * @return TaskManager
	 */
	public TaskManager getTaskManager() {
		return taskManager;
	}

	/**
	 * Get UIController object
	 * 
	 * @return UIController
	 */
	public UIController getUIController() {
		return uiController;
	}

	/**
	 * Get Storage object
	 * 
	 * @return Storage
	 */
	public StorageController getStorage() {
		return storage;
	}

	/**
	 * Get CategoryManager object
	 * 
	 * @return CategoryManager
	 */
	public CategoryManager getCategoryManager() {
		return categoryManager;
	}

	public Stack<ReversibleCommand> getHistory() {
		return history;
	}
}
```
###### src\dooyit\logic\api\TaskManager.java
``` java
public class TaskManager {
	private ArrayList<Task> tasks;

	public TaskManager() {
		tasks = new ArrayList<Task>();
	}

	public Task addFloatingTask(String data) {
		return addFloatingTask(data, false);
	}

	public Task addDeadlineTask(String data, DateTime dateTime) {
		return addDeadlineTask(data, dateTime, false);
	}

	public Task addEventTask(String data, DateTime start, DateTime end) {
		return addEventTask(data, start, end, false);
	}

	public Task addFloatingTask(String data, boolean isCompleted) {
		FloatingTask floatingTask = new FloatingTask(data);
		if (isCompleted) {
			floatingTask.mark();
		}

		tasks.add(floatingTask);

		return floatingTask;
	}

	public Task addDeadlineTask(String data, DateTime dateTime, boolean isCompleted) {
		DeadlineTask deadlineTask = new DeadlineTask(data, dateTime);
		if (isCompleted) {
			deadlineTask.mark();
		}

		tasks.add(deadlineTask);
		return deadlineTask;
	}

	public Task addEventTask(String data, DateTime start, DateTime end, boolean isCompleted) {
		EventTask eventTask = new EventTask(data, start, end);

		if (isCompleted) {
			eventTask.mark();
		}

		tasks.add(eventTask);
		return eventTask;
	}

	public void add(Task task) {
		tasks.add(task);
	}
	
	public void loadTask(ArrayList<Task> tasks){
		this.tasks = new ArrayList<Task>(tasks);
	}
	
	public Task remove(int id) {
		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).getId() == id) {
				return tasks.remove(i);
			}
		}
		return null;
	}
	
	public boolean remove(Task task) {
		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).equals(task)) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Mark a task based on id
	 * 
	 * @param id
	 *            task id
	 * @return false if task is already marked
	 */
	public boolean markTask(int id) {
		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).getId() == id) {
				if (tasks.get(i).isCompleted()) {
					return false;
				} else {
					tasks.get(i).mark();
					return true;
				}
			}
		}
		// tell user if task is already marked.
		return false;
	}

	public boolean unMarkTask(int id) {
		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).getId() == id) {
				tasks.get(i).unMark();
				return true;
			}
		}
		// tell user if task is already marked.
		return false;
	}

	public boolean unMarkTask(Task task) {
		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).equals(task)) {
				tasks.get(i).unMark();
				return true;
			}
		}
		// tell user if task is already marked.
		return false;
	}
	
	public boolean contains(int id) {
		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).getId() == id) {
				return true;
			}
		}
		return false;
	}
	
	public boolean contains(Task task) {
		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).equals(task)) {
				return true;
			}
		}
		return false;
	}

	public Task find(int id) {
		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).getId() == id) {
				return tasks.get(i);
			}
		}
		return null;
	}
	
	public Task find(Task task) {
		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).equals(task)) {
				return tasks.get(i);
			}
		}
		return null;
	}
	
	public void clear(){
		tasks.clear();
	}
	
	public boolean changeTaskName(int taskId, String newName){
		if(!contains(taskId)){
			return false;
		}
		
		Task task = find(taskId);
		task.changeName(newName);
		return true;
	}
	
	public boolean changeTaskToDeadline(int taskId, DateTime dateTimeDeadline){
		if(!contains(taskId)){
			return false;
		}
		
		Task task = remove(taskId);
		addDeadlineTask(task.getName(), dateTimeDeadline);
		return true;
	}
	
	public boolean changeTaskToEvent(int taskId, DateTime dateTimeStart, DateTime dateTimeEnd){
		if(!contains(taskId)){
			return false;
		}
		
		Task task = remove(taskId);
		addEventTask(task.getName(), dateTimeStart, dateTimeEnd);
		return true;
	}

	public ArrayList<Task> getAllTasks() {
		return tasks;
	}

	public ArrayList<Task> getIncompletedTasks() {
		ArrayList<Task> allIncompleteTask = new ArrayList<Task>();

		for (Task task : tasks) {
			if (!task.isCompleted()) {
				allIncompleteTask.add(task);
			}
		}
		return allIncompleteTask;
	}

	public ArrayList<Task> getCompletedTasks() {
		ArrayList<Task> allCompletedTask = new ArrayList<Task>();

		for (Task task : tasks) {
			if (task.isCompleted()) {
				allCompletedTask.add(task);
			}
		}
		return allCompletedTask;
	}

	public ArrayList<Task> getFloatingTasks() {
		ArrayList<Task> floatingTasks = new ArrayList<Task>();

		for (Task task : tasks) {
			if (task.getTaskType() == TaskType.FLOATING) {
				floatingTasks.add(task);
			}
		}
		return floatingTasks;
	}

	public ArrayList<Task> getIncompleteFloatingTasks() {
		ArrayList<Task> floatingTasks = new ArrayList<Task>();

		for (Task task : tasks) {
			if (task.getTaskType() == TaskType.FLOATING && !task.isCompleted()) {
				floatingTasks.add(task);
			}
		}
		return floatingTasks;
	}

	public ArrayList<Task> getDeadlineTasks() {

		ArrayList<Task> deadlineTasks = new ArrayList<Task>();

		for (Task task : tasks) {
			if (task.getTaskType() == TaskType.DEADLINE) {
				deadlineTasks.add(task);
			}
		}
		return deadlineTasks;
	}

	public ArrayList<Task> getDeadlineTasks(DateTime dateTime) {

		ArrayList<Task> deadlineTasks = new ArrayList<Task>();

		for (Task task : tasks) {
			if (task.getTaskType() == TaskType.DEADLINE) {
				DeadlineTask deadlineTask = (DeadlineTask) task;
				if (deadlineTask.getDateTimeDeadline().isTheSameDateAs(dateTime)) {
					deadlineTasks.add(task);
				}
			}
		}
		return deadlineTasks;
	}

	public ArrayList<Task> getIncompleteDeadlineTasks(DateTime dateTime) {

		ArrayList<Task> deadlineTasks = new ArrayList<Task>();

		for (Task task : tasks) {
			if (task.getTaskType() == TaskType.DEADLINE) {
				DeadlineTask deadlineTask = (DeadlineTask) task;
				if(deadlineTask.getDateTimeDeadline().isTheSameDateAs(dateTime) && !task.isCompleted()){
					deadlineTasks.add(task);
				}
			}
		}
		return deadlineTasks;
	}

	public ArrayList<Task> getEventTasks() {

		ArrayList<Task> eventTasks = new ArrayList<Task>();

		for (Task task : tasks) {
			if (task.getTaskType() == TaskType.EVENT) {
				eventTasks.add(task);
			}
		}
		return eventTasks;
	}

	public ArrayList<Task> getEventTasks(DateTime dateTime) {

		ArrayList<Task> eventTasks = new ArrayList<Task>();

		for (Task task : tasks) {
			if (task.getTaskType() == TaskType.EVENT) {
				EventTask eventTask = (EventTask) task;
				if (eventTask.getDateTimeStart().isTheSameDateAs(dateTime)) {
					eventTasks.add(task);
				}
			}
		}
		return eventTasks;
	}

	public ArrayList<Task> getIncompleteEventTasks(DateTime dateTime) {

		ArrayList<Task> eventTasks = new ArrayList<Task>();

		for (Task task : tasks) {
			if (task.getTaskType() == TaskType.EVENT ) {
				EventTask eventTask = (EventTask)task;
				if(eventTask.getDateTimeStart().isTheSameDateAs(dateTime) && !task.isCompleted()){
					eventTasks.add(task);
				}
			}
		}
		return eventTasks;
	}

	public ArrayList<TaskGroup> getTaskGroupsAll() {
		ArrayList<TaskGroup> taskGroups = new ArrayList<TaskGroup>();
		taskGroups.add(new TaskGroup("All", getIncompletedTasks()));
		return taskGroups;
	}

	public ArrayList<TaskGroup> getTaskGroupsToday() {
		ArrayList<TaskGroup> taskGroups = new ArrayList<TaskGroup>();
		DateTime currDate = new DateTime();
		taskGroups.add(new TaskGroup("Today", getIncompleteDeadlineTasks(currDate), getIncompleteEventTasks(currDate),
				currDate));
		return taskGroups;
	}

	public ArrayList<TaskGroup> getTaskGroupsFloating() {
		ArrayList<TaskGroup> taskGroups = new ArrayList<TaskGroup>();
		taskGroups.add(new TaskGroup("Float", getIncompleteFloatingTasks()));
		return taskGroups;
	}

	public ArrayList<TaskGroup> getTaskGroupsCompleted() {
		ArrayList<TaskGroup> taskGroups = new ArrayList<TaskGroup>();
		taskGroups.add(new TaskGroup("Completed", getCompletedTasks()));
		return taskGroups;
	}

	public ArrayList<TaskGroup> getTaskGroupsNext7Days() {

		DateTime currDate = new DateTime();
		ArrayList<TaskGroup> taskGroups = new ArrayList<TaskGroup>();

		taskGroups.add(new TaskGroup("Today", getIncompleteDeadlineTasks(currDate), getIncompleteEventTasks(currDate),
				new DateTime(currDate)));
		currDate.increaseByOne();

		taskGroups.add(new TaskGroup("Tomorrow", getIncompleteDeadlineTasks(currDate),
				getIncompleteEventTasks(currDate), new DateTime(currDate)));
		currDate.increaseByOne();

		for (int i = 0; i < 5; i++) {
			taskGroups.add(new TaskGroup(currDate.getDayStr(), getIncompleteDeadlineTasks(currDate),
					getIncompleteEventTasks(currDate), new DateTime(currDate)));
			currDate.increaseByOne();

		}

		return taskGroups;
	}

	public void display() {
		System.out.println();
		System.out.println("Task List");

		for (Task task : tasks) {
			System.out.println(task.getId() + ": " + task);
			// System.out.println(task.convertToSavableString());
		}

		System.out.println();
	}
}
```
###### src\dooyit\logic\commands\AddCategoryCommand.java
``` java
public class AddCategoryCommand extends Command {

	private String categoryName;
	private String colorString;

	public AddCategoryCommand(String categoryName) {
		this.categoryName = categoryName;
	}

	public AddCategoryCommand(String categoryName, String colorString) {
		this.categoryName = categoryName;
		this.colorString = colorString;
	}
	
	private boolean hasColorString(){
		return colorString != null;
	}

	@Override
	public void execute(LogicController logic) throws IncorrectInputException {
		CategoryManager categoryManager = logic.getCategoryManager();
		
		@SuppressWarnings("unused")
		Category category = null;

		if(!categoryManager.contains(categoryName)){
			if(hasColorString()){
				if(colorManager.contains(colorString)){
					CustomColor customColor = colorManager.find(colorString);
					category = categoryManager.addCategory(categoryName, customColor);
				}else{
					throw new IncorrectInputException("Color: " + colorString + " is not available.");
				}
			}else{
				category = categoryManager.addCategory(categoryName);
			}
		}
		else{
			throw new IncorrectInputException("Category: " + categoryName + " already exists.");
		}
	}

}
```
###### src\dooyit\logic\commands\AddCommand.java
``` java
public class AddCommand extends ReversibleCommand {

	private String taskName;
	private Task.TaskType taskType;
	private DateTime dateTimeDeadline;
	private DateTime dateTimeStart;
	private DateTime dateTimeEnd;
	private Task addedTask;
	
	public AddCommand(String taskName) {
		this.taskName = taskName;
		taskType = Task.TaskType.FLOATING;
	}

	public AddCommand(String data, DateTime deadline) {
		this.taskName = data;
		this.dateTimeDeadline = deadline;
		taskType = Task.TaskType.DEADLINE;
	}
	
	public AddCommand(String data, DateTime start, DateTime end) {
		this.taskName = data;
		this.dateTimeStart = start;
		this.dateTimeEnd = end;
		taskType = Task.TaskType.EVENT;
	}

	@Override
	public void undo(LogicController logic){
		TaskManager taskManager = logic.getTaskManager();
		taskManager.remove(addedTask);
	}
	
	@Override
	public void execute(LogicController logic) throws IncorrectInputException {
		TaskManager taskManager = logic.getTaskManager();
		assert (taskManager != null);

		switch (taskType) {
		case FLOATING:
			addedTask = taskManager.addFloatingTask(taskName);
			break;

		case DEADLINE:
			addedTask = taskManager.addDeadlineTask(taskName, dateTimeDeadline);

			break;

		case EVENT:
			addedTask = taskManager.addEventTask(taskName, dateTimeStart, dateTimeEnd);
			break;
		}
	}
}
```
###### src\dooyit\logic\commands\ChangeThemeCommand.java
``` java
public class ChangeThemeCommand extends Command {

	String themeString;
	UITheme theme;
	
	public ChangeThemeCommand(String themeString){
		this.themeString = themeString;
	}
	
	@Override
	public void execute(LogicController logic) throws IncorrectInputException {
		UIController uicontroller = logic.getUIController();
		
		String lowerThemeString = themeString.toLowerCase();
		
		switch(lowerThemeString){
		case "light":
			theme = UITheme.LIGHT;
			break;
		
		case "dark":
			theme = UITheme.DARK;
			break;
			
		case "aqua":
			theme = UITheme.AQUA;
			break;	
		
		case "custom":
			theme = UITheme.CUSTOM;
			break;	
			
		default:
			throw new IncorrectInputException(themeString + " is not available, try LIGHT, DARK, AQUA or CUSTOM");
		}
		
		uicontroller.changeTheme(theme);
	}

}
```
###### src\dooyit\logic\commands\Command.java
``` java
public abstract class Command {

	public static enum CommandType {

	}
	
	ColourManager colorManager = ColourManager.getInstance();
	
	public Command() {

	}

	public abstract void execute(LogicController logic) throws IncorrectInputException;
}
```
###### src\dooyit\logic\commands\CommandUtils.java
``` java
public class CommandUtils {

	public static Command createAddCommandFloat(String data) {
		AddCommand addCommand = new AddCommand(data);
		return addCommand;
	}

	public static Command createAddCommandDeadline(String data, DateTime deadline) {
		AddCommand addCommand = new AddCommand(data, deadline);
		return addCommand;
	}

	public static Command createAddCommandEvent(String data, DateTime start, DateTime end) {
		AddCommand addCommand = new AddCommand(data, start, end);
		return addCommand;
	}

	public static Command createDeleteCommand(int deleteId) {
		DeleteCommand deleteCommand = new DeleteCommand(deleteId);
		return deleteCommand;
	}

	public static Command createDeleteCommand(ArrayList<Integer> deleteIds) {
		DeleteCommand deleteCommand = new DeleteCommand(deleteIds);
		return deleteCommand;
	}

	public static Command createMarkCommand(int markId) {
		MarkCommand deleteCommand = new MarkCommand(markId);
		return deleteCommand;
	}

	public static Command createMarkCommand(ArrayList<Integer> markIds) {
		MarkCommand deleteCommand = new MarkCommand(markIds);
		return deleteCommand;
	}

	public static Command createUnMarkCommand(int unMarkId) {
		UnMarkCommand deleteCommand = new UnMarkCommand(unMarkId);
		return deleteCommand;
	}

	public static Command createUnMarkCommand(ArrayList<Integer> unMarkIds) {
		UnMarkCommand deleteCommand = new UnMarkCommand(unMarkIds);
		return deleteCommand;
	}
	
	public static Command createAddCategoryCommand(String categoryName) {
		AddCategoryCommand addCategoryCommand = new AddCategoryCommand(categoryName);
		return addCategoryCommand;
	}

	public static Command createAddCategoryCommand(String categoryName, String colorString) {
		AddCategoryCommand addCategoryCommand = new AddCategoryCommand(categoryName, colorString);
		return addCategoryCommand;
	}

	public static Command createSetCategoryCommand(int taskID, String categoryName) {
		SetCategoryCommand addCategoryCommand = new SetCategoryCommand(taskID, categoryName);
		return addCategoryCommand;
	}
	
	public static Command createShowTodayCommand() {
		ShowCommand showCommand = new ShowCommand(UIMainViewType.TODAY);

		return showCommand;
	}

	public static Command createShowNext7DaysCommand() {
		ShowCommand showCommand = new ShowCommand(UIMainViewType.EXTENDED);

		return showCommand;
	}

	public static Command createShowFloatCommand() {
		ShowCommand showCommand = new ShowCommand(UIMainViewType.FLOAT);

		return showCommand;
	}
	
	public static Command createShowAllCommand() {
		ShowCommand showCommand = new ShowCommand(UIMainViewType.ALL);

		return showCommand;
	}

	public static Command createShowCompletedCommand() {
		ShowCommand showCommand = new ShowCommand(UIMainViewType.COMPLETED);

		return showCommand;
	}

	public static Command createShowCategoryCommand(String categoryName) {
		// temp
		ShowCommand showCommand = new ShowCommand(UIMainViewType.COMPLETED, categoryName);

		return showCommand;
	}

	public static Command createEditCommandName(int taskId, String taskName) {
		EditCommand editCommand = new EditCommand(taskId, taskName);
		return editCommand;
	}

	public static Command createEditCommandDeadline(int taskId, DateTime deadline) {
		EditCommand editCommand = new EditCommand(taskId, deadline);
		return editCommand;
	}

	public static Command createEditCommandEvent(int taskId, DateTime start, DateTime end) {
		EditCommand editCommand = new EditCommand(taskId, start, end);
		return editCommand;
	}

	public static Command createEditCommandNameAndDeadline(int taskId, String taskName, DateTime deadline) {
		EditCommand editCommand = new EditCommand(taskId, taskName, deadline);
		return editCommand;
	}

	public static Command createEditCommandNameAndEvent(int taskId, String taskName, DateTime start, DateTime end) {
		EditCommand editCommand = new EditCommand(taskId, taskName, start, end);
		return editCommand;
	}

	public static Command createStorageCommand(String path) {
		StorageCommand storageCommand = new StorageCommand(path);
		return storageCommand;
	}
	
	public static Command createChangeThemeCommand(String themeString){
		ChangeThemeCommand changeThemeCommand = new ChangeThemeCommand(themeString);		
		return changeThemeCommand;
	}

	public static Command createUndoCommand() {
		UndoCommand undoCommand = new UndoCommand();
		return undoCommand;
	}
	
	public static Command createHelpCommand() {
		HelpCommand undoCommand = new HelpCommand();
		return undoCommand;
	}
	
	public static Command createInvalidCommand(String errorMessage) {
		InvalidCommand invalidCommand = new InvalidCommand(errorMessage);
		return invalidCommand;
	}

	public static Command createExitCommand() {
		ExitCommand exitCommand = new ExitCommand();
		return exitCommand;
	}

	
	
}
```
###### src\dooyit\logic\commands\DeleteCommand.java
``` java
public class DeleteCommand extends ReversibleCommand {

	private ArrayList<Integer> deleteIds;
	private ArrayList<Task> deletedTasks;

	public DeleteCommand(int deleteId) {
		this.deleteIds = new ArrayList<Integer>();
		this.deletedTasks = new ArrayList<Task>();
		this.deleteIds.add(deleteId);
	}
	
	public DeleteCommand(ArrayList<Integer> deleteIds) {
		this.deleteIds = new ArrayList<Integer>();
		this.deletedTasks = new ArrayList<Task>();
		this.deleteIds.addAll(deleteIds);
	}
	
	@Override
	public void undo(LogicController logic){
		TaskManager taskManager = logic.getTaskManager();
		
		for(Task deletedTask : deletedTasks){
			taskManager.add(deletedTask);
		}
	}

	@Override
	public void execute(LogicController logic) throws IncorrectInputException {
		TaskManager taskManager = logic.getTaskManager();
		assert (taskManager != null);
		
		String errorMessageBody = "";

		for (Integer deleteId : deleteIds) {
			if (taskManager.contains(deleteId)) {
				Task deletedTask = taskManager.remove(deleteId);
				deletedTasks.add(deletedTask);
			} else {
				errorMessageBody += " " + "[" + deleteId + "]";
			}
		}

		if (errorMessageBody != "") {
			throw new IncorrectInputException("Index" + errorMessageBody + " doesn't exists");
		}
	}
}
```
###### src\dooyit\logic\commands\EditCommand.java
``` java
public class EditCommand extends Command {

	private enum EditCommandType {
		NAME, DEADLINE, EVENT, NAME_N_DEADLINE, NAME_N_EVENT
	};
	
	private EditCommandType editCommandType;
	private int taskId;
	public String taskName;
	private DateTime dateTimeDeadline;
	private DateTime dateTimeStart;
	private DateTime dateTimeEnd;

	public EditCommand(int taskId, String taskName) {
		editCommandType = EditCommandType.NAME;
		this.taskName = taskName;
		this.taskId = taskId;
	}

	public EditCommand(int taskId, DateTime deadline) {
		editCommandType = EditCommandType.DEADLINE;
		this.dateTimeDeadline = deadline;
		this.taskId = taskId;
	}

	public EditCommand(int taskId, DateTime start, DateTime end) {
		editCommandType = EditCommandType.EVENT;
		this.dateTimeStart = start;
		this.dateTimeEnd = end;
		this.taskId = taskId;
	}

	public EditCommand(int taskId, String taskName, DateTime deadline) {
		editCommandType = EditCommandType.NAME_N_DEADLINE;
		this.taskName = taskName;
		this.dateTimeDeadline = deadline;
		this.taskId = taskId;
	}

	public EditCommand(int taskId, String taskName, DateTime start, DateTime end) {
		editCommandType = EditCommandType.NAME_N_EVENT;
		this.taskName = taskName;
		this.dateTimeStart = start;
		this.dateTimeEnd = end;
		this.taskId = taskId;
	}

	@Override
	public void execute(LogicController logic) throws IncorrectInputException {
		TaskManager taskManager = logic.getTaskManager();
		assert (taskManager != null);
		
		if(!taskManager.contains(taskId)){
			throw new IncorrectInputException("Cant find task ID: " + taskId);
		}
		
		switch(editCommandType){
		case NAME:
			taskManager.changeTaskName(taskId, taskName);
			break;
			
		case DEADLINE:
			taskManager.changeTaskToDeadline(taskId, dateTimeDeadline);
			break;
			
			case EVENT:
				taskManager.changeTaskToEvent(taskId, dateTimeStart, dateTimeEnd);
			break;

		case NAME_N_DEADLINE:
			taskManager.changeTaskName(taskId, taskName);
			taskManager.changeTaskToDeadline(taskId, dateTimeDeadline);
			break;

		case NAME_N_EVENT:
			taskManager.changeTaskName(taskId, taskName);
			taskManager.changeTaskToEvent(taskId, dateTimeStart, dateTimeEnd);
			break;		
		}
	}

}
```
###### src\dooyit\logic\commands\ExitCommand.java
``` java
public class ExitCommand extends Command {

	public ExitCommand() {

	}

	@Override
	public void execute(LogicController logic) throws IncorrectInputException {
		System.exit(1);
	}
}
```
###### src\dooyit\logic\commands\HelpCommand.java
``` java
public class HelpCommand extends Command {

	public HelpCommand(){
		
	}
	
	@Override
	public void execute(LogicController logic) throws IncorrectInputException {
		UIController uiController = logic.getUIController();
		
		uiController.showHelp();
		
	}

}
```
###### src\dooyit\logic\commands\InvalidCommand.java
``` java
public class InvalidCommand extends Command {
	String errorMessage;

	public InvalidCommand(String errorMessage) {
		this.errorMessage = errorMessage;
	}

	@Override
	public void execute(LogicController logic) throws IncorrectInputException {
		throw new IncorrectInputException(errorMessage);
	}

}
```
###### src\dooyit\logic\commands\MarkCommand.java
``` java
public class MarkCommand extends ReversibleCommand {
	private ArrayList<Integer> markIds;
	private ArrayList<Task> markedTasks;
	
	public MarkCommand(int markId) {
		this.markIds = new ArrayList<Integer>();
		this.markedTasks = new ArrayList<Task>();
		this.markIds.add(markId);
	}

	public MarkCommand(ArrayList<Integer> markIds) {
		this.markIds = new ArrayList<Integer>();
		this.markedTasks = new ArrayList<Task>();
		this.markIds.addAll(markIds);
	}

	@Override
	public void undo(LogicController logic){
		TaskManager taskManager = logic.getTaskManager();
		
		for(Task markedTask : markedTasks){
			taskManager.unMarkTask(markedTask);
		}
	}
	
	@Override
	public void execute(LogicController logic) throws IncorrectInputException {
		TaskManager taskManager = logic.getTaskManager();
		assert (taskManager != null);

		String errorMessageBody = "";

		for (Integer markId : markIds) {
			if (taskManager.contains(markId)) {
				taskManager.markTask(markId);
				Task markedTask = taskManager.find(markId);
				markedTasks.add(markedTask);
			} else {
				errorMessageBody += " " + markId;
			}
		}

		if (errorMessageBody != "") {
			throw new IncorrectInputException("Index" + errorMessageBody + " doesn't exists");
		}

	}
}
```
###### src\dooyit\logic\commands\ReversibleCommand.java
``` java
public abstract class ReversibleCommand extends Command {
	
	public abstract void undo(LogicController logic);
}
```
###### src\dooyit\logic\commands\SetCategoryCommand.java
``` java
public class SetCategoryCommand extends Command {

	private String categoryName;
	private ArrayList<Integer> taskIds;

	public SetCategoryCommand(int taskId, String categoryName) {
		this.taskIds = new ArrayList<Integer>();
		this.taskIds.add(taskId);
		this.categoryName = categoryName;
	}

	// public SetCategoryCommand(ArrayList<Integer> taskIds, String
	// categoryName) {
	// this.taskIds = new ArrayList<Integer>();
	// this.taskIds.addAll(taskIds);
	// this.categoryName = categoryName;
	// }

	@Override
	public void execute(LogicController logic) throws IncorrectInputException {
		TaskManager taskManager = logic.getTaskManager();
		CategoryManager categoryManager = logic.getCategoryManager();

		for (Integer taskId : taskIds) {
			if (taskManager.contains(taskId)) {
				if (categoryManager.contains(categoryName)) {
					Category category = categoryManager.findCategory(categoryName);
					Task task = taskManager.find(taskId);
					task.setCategory(category);
				} else {
					Category category = categoryManager.addCategory(categoryName);
					Task task = taskManager.find(taskId);
					task.setCategory(category);
					throw new IncorrectInputException("Category: " + categoryName + " is created.");
				}
			} else {
				throw new IncorrectInputException("TaskID: " + taskId + " doesn't exist.");
			}
		}
	}

}
```
###### src\dooyit\logic\commands\ShowCommand.java
``` java
public class ShowCommand extends Command {

	String categoryName;
	UIMainViewType uiMainViewtype;

	public ShowCommand(UIMainViewType uiMainViewtype) {
		this.uiMainViewtype = uiMainViewtype;
	}

	public ShowCommand(UIMainViewType uiMainViewtype, String categoryName) {
		this.uiMainViewtype = uiMainViewtype;
		this.categoryName = categoryName;
	}

	@Override
	public void execute(LogicController logic) throws IncorrectInputException {
		UIController uiController = logic.getUIController();
		CategoryManager categoryManager = logic.getCategoryManager();
		TaskManager taskManager = logic.getTaskManager();
		
//		if(uiController == null)
//			return;
		
		if(uiMainViewtype == UIMainViewType.CATEGORY){
			if(categoryManager.contains(categoryName)){
				Category category = categoryManager.findCategory(categoryName);
				uiController.setActiveViewType(uiMainViewtype);
				uiController.refreshMainView(taskManager.getTaskGroupsCompleted(), category);
			}
		}

		uiController.setActiveViewType(uiMainViewtype);
	}

}
```
###### src\dooyit\logic\commands\StorageCommand.java
``` java
public class StorageCommand extends Command {

	private String path;

	public StorageCommand(String path) {
		this.path = path;
	}

	@Override
	public void execute(LogicController logic) throws IncorrectInputException {
		StorageController storage = logic.getStorage();

		try {
			storage.setFileDestination(path);
		} catch (IOException e) {
			throw new IncorrectInputException("Invalid path: " + path);
		}
	}

}
```
###### src\dooyit\logic\commands\UndoCommand.java
``` java
public class UndoCommand extends Command {

	@Override
	public void execute(LogicController logic) throws IncorrectInputException {
		Stack<ReversibleCommand> history = logic.getHistory();
		
		ReversibleCommand reversibleCommand;
		
		if(!history.isEmpty()){
			reversibleCommand = history.pop();
			reversibleCommand.undo(logic);
		}
	}

}
```
###### src\dooyit\logic\commands\UnMarkCommand.java
``` java
public class UnMarkCommand extends Command {

private ArrayList<Integer> unMarkIds;
	
	public UnMarkCommand(int unMarkId) {
		this.unMarkIds = new ArrayList<Integer>();
		this.unMarkIds.add(unMarkId);
	}

	public UnMarkCommand(ArrayList<Integer> unMarkIds) {
		this.unMarkIds = new ArrayList<Integer>();
		this.unMarkIds.addAll(unMarkIds);
	}

	@Override
	public void execute(LogicController logic) throws IncorrectInputException {
		TaskManager taskManager = logic.getTaskManager();
		assert (taskManager != null);

		String errorMessageBody = "";

		for (int i = 0; i < unMarkIds.size(); i++) {
			if (taskManager.contains(unMarkIds.get(i))) {
				taskManager.unMarkTask(unMarkIds.get(i));
			} else {
				errorMessageBody += " " + unMarkIds.get(i);
			}
		}

		if (errorMessageBody != "") {
			throw new IncorrectInputException("Index" + errorMessageBody + " doesn't exists");
		}

	}
}
```
###### src\dooyit\ui\Main.java
``` java
public class Main extends Application {
	public static final String MESSAGE_WELCOME = "Welcome to TextBuddy %1$s is ready for use.";
	public static final String MESSAGE_TEXT_NO = "%1$d. %2$s";
	public static final String MESSAGE_FILE_IS_EMPTY = "%1$s is empty";
	public static final String MESSAGE_INPUT_ADDED = "added to %1$s: \"%2$s\"";
	public static final String MESSAGE_INCORRECT_ADD_FORMAT = "Incorrect format -add <text>";
	public static final String MESSAGE_DELETED = "Deleted from %1$s: \"%2$s\"";
	public static final String MESSAGE_UNABLE_TO_DELETE = "Unable to delete text in line No. %1$d";
	public static final String MESSAGE_INCORRECT_DELETE_FORMAT = "Incorrect format -delete <number>, number starts from 1";
	public static final String MESSAGE_ALL_DELETED = "All content deleted from %1$s";
	public static final String MESSAGE_INVALID_COMMAND = "Invalid command: %1$s";
	public static final String MESAGE_EMPTY_COMMAND = "Empty command";
	public static final String MESAGE_COMMAND = "command: ";
	public static final String MESSAGE_INVALID_ARGUMENT = "Invalid Argument";
	public static final String ERROR_IO_EXCEPTION = "ERROR: IOException";
	public static final String ERROR_NUMBER_FORMAT_EXCEPTION = "ERROR: Number Format Exception";
	public static final int NO_OF_ARG = 1;

	private static final String APP_ICON = "icon.png";
	private static final String APP_TITLE = "Dooyit";
	private static final int MINWIDTH_STAGE = 720;
	private static final int MINHEIGHT_STAGE = 620;

	// scanner for receiving user input
	private Scanner sc;
	private UIController ui;
	LogicController logic;

	public Main() {
	}
	
	public void init(Scanner sc) throws IOException {
		this.sc = sc;
		logic = new LogicController();
		UI(logic);
	}

	@Override
	public void start(Stage primaryStage) throws IOException {

		logic = new LogicController();

		try {
			this.ui = new UIController(primaryStage, logic);
			Scene scene = this.ui.getScene();
			primaryStage.setScene(scene);
			primaryStage.getIcons().add(new Image(APP_ICON));
			primaryStage.setTitle(APP_TITLE);
			primaryStage.setMinWidth(MINWIDTH_STAGE);
			primaryStage.setMinHeight(MINHEIGHT_STAGE);
			primaryStage.show();
			logic.setUIController(this.ui);
			
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	private void UI(LogicController logic) throws IOException {
		while (true) {
			showToUser(MESAGE_COMMAND);
			String userInput = sc.nextLine();
			logic.processCommand(userInput);
		}
	}

	public static void main(String[] args) {
		launch(args);
	}

	/**
	 * Display message to user
	 * 
	 * @param message
	 */
	public static void showToUser(String message) {
		System.out.println(message);
	}
}
```
