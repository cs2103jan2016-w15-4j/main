# A0126356E
###### src\dooyit\common\Constants.java
``` java
package dooyit.common;

public class Constants {

	public static final String DISPLAY_TASK_EVENT = "%1$s, Event: %2$s to %3$s";
	public static final String DISPLAY_TASK_DEADLINE = "%1$s, Deadline: %2$s";
	public static final String DISPLAY_CATEGORY = ", Cat: %1$s - %2$s";

	public static final String ORANGE_COLOUR = "orange";
	public static final String WHITE_COLOUR = "white";
	public static final String YELLOW_COLOUR = "yellow";
	public static final String RED_COLOUR = "red";
	public static final String PINK_COLOUR = "pink";
	public static final String MAGENTA_COLOUR = "magenta";
	public static final String GREEN_COLOUR = "green";
	public static final String GREY_COLOUR = "grey";
	public static final String CYAN_COLOUR = "cyan";
	public static final String BLUE_COLOUR = "blue";
	public static final String BLACK_COLOUR = "black";
	public static final float MAX_RGB = 255.0f;
	
	public static final String EMPTY_STRING = "";
	public static final int UNINITIALISED = -1;
	public static final String SYMBOL_DASH = " - ";
	public static final String SPACE = " ";
	
}
```
###### src\dooyit\common\datatype\Category.java
``` java
package dooyit.common.datatype;

import dooyit.common.Constants;
import javafx.scene.paint.Color;
/**
 * Category has a name and a colour
 * @author limtaeu
 *
 */
public class Category {
	private String name;

	private CustomColour customColor;

	public Category(String name) {
		this.name = name;
	}

	public Category(String name, CustomColour customColour) {
		this.name = name;
		this.customColor = customColour;
	}

	public String getName() {
		return this.name;
	}

	public void setName(String newName) {
		this.name = newName;
	}

	public Color getColour() {
		return customColor.getColor();
	}

	public CustomColour getCustomColour() {
		return customColor;
	}

	public void setCustomColour(CustomColour customColour){
		this.customColor = customColour;
	}
	
	public String getCustomColourName() {
		return customColor.getName();
	}

	@Override
	public boolean equals(Object o) {
		if (o instanceof String) {
			String categoryName = (String) o;
			return getName().toLowerCase().equals(categoryName.toLowerCase());
		} else if (o instanceof Category) {
			Category category = (Category) o;
			return getName().toLowerCase().equals(category.getName().toLowerCase());
		}
		return false;
	}

	@Override
	public String toString() {
		return name + Constants.SPACE + customColor.toString();
	}

	public CategoryData convertToData() {
		CategoryData categoryData;
		categoryData = new CategoryData(name, getCustomColourName());
		return categoryData;
	}
}
```
###### src\dooyit\common\datatype\CustomColour.java
``` java
package dooyit.common.datatype;

import dooyit.common.Constants;
import javafx.scene.paint.Color;

public class CustomColour {
	
	private float r; // red
	private float g; // green
	private float b; // blue
	private String name; // colour name
	
	private static final String COLOUR_TO_STRING = "Colour: %1$s, %2$s, %3$s";
	
	public CustomColour(String name, float r, float g, float b) {
		this.name = name;
		this.r = r / Constants.MAX_RGB;
		this.g = g / Constants.MAX_RGB;
		this.b = b / Constants.MAX_RGB;
	}

	public static final CustomColour BLACK = new CustomColour(Constants.BLACK_COLOUR, 40, 40, 40);
	public static final CustomColour BLUE = new CustomColour(Constants.BLUE_COLOUR, 26, 214, 253);
	public static final CustomColour CYAN = new CustomColour(Constants.CYAN_COLOUR, 82, 237, 199);
	public static final CustomColour GREY = new CustomColour(Constants.GREY_COLOUR, 219, 221, 222);
	public static final CustomColour GREEN = new CustomColour(Constants.GREEN_COLOUR, 135, 252, 125);
	public static final CustomColour MAGENTA = new CustomColour(Constants.MAGENTA_COLOUR, 239, 77, 182);
	public static final CustomColour PINK = new CustomColour(Constants.PINK_COLOUR, 255, 73, 129);
	public static final CustomColour RED = new CustomColour(Constants.RED_COLOUR, 255, 58, 84);
	public static final CustomColour YELLOW = new CustomColour(Constants.YELLOW_COLOUR, 255, 204, 0);
	public static final CustomColour WHITE = new CustomColour(Constants.WHITE_COLOUR, 247, 247, 247);
	public static final CustomColour ORANGE = new CustomColour(Constants.ORANGE_COLOUR, 255, 69, 0);

	public Color getColor(){
		return Color.color(r, g, b);
	}
	
	public String getName(){
		return name;
	}
	
	@Override
	public boolean equals(Object o) {
		if(o instanceof String){
			String colourString = (String)o;
			return name.equals(colourString);
		}
		
		if (o instanceof CustomColour) {
			CustomColour colour = (CustomColour) o;
			return r == colour.r && g == colour.g && b == colour.b;
		}
		
		return false;
	}

	@Override
	public String toString() {
		return String.format(COLOUR_TO_STRING, r, g, g);
	}

}
```
###### src\dooyit\common\datatype\DeadlineTask.java
``` java
package dooyit.common.datatype;

import dooyit.common.Constants;
import dooyit.common.datatype.DateTime.Day;
import dooyit.common.datatype.DateTime.Month;

public class DeadlineTask extends Task {

	DateTime dateTimeDeadline;

	public DeadlineTask(String taskName, DateTime deadline) {
		assert (taskName != null && deadline != null);

		taskType = TaskType.DEADLINE;
		this.taskName = taskName;
		this.dateTimeDeadline = deadline;
	}

	public DeadlineTask(String taskName, DateTime deadline, Category category) {
		assert (taskName != null && deadline != null);

		taskType = TaskType.DEADLINE;
		this.taskName = taskName;
		this.dateTimeDeadline = deadline;
		this.category = category;
	}

	public DeadlineTask(Task task, DateTime dateTimeDeadline) {
		assert (task != null);

		this.taskType = TaskType.DEADLINE;
		this.displayId = task.displayId;
		this.uniqueId = task.uniqueId;
		this.taskName = task.taskName;
		this.category = task.category;
		this.isCompleted = task.isCompleted;
		this.dateTimeDeadline = dateTimeDeadline;
	}

	public DeadlineTask(DeadlineTask deadlineTask) {
		assert (deadlineTask != null);

		this.taskType = TaskType.DEADLINE;
		this.displayId = deadlineTask.displayId;
		this.uniqueId = deadlineTask.uniqueId;
		this.taskName = deadlineTask.taskName;
		this.dateTimeDeadline = deadlineTask.dateTimeDeadline;
		this.category = deadlineTask.category;
		this.isCompleted = deadlineTask.isCompleted;
	}

	public DateTime getDateTimeDeadline() {
		return dateTimeDeadline;
	}

	@Override
	public boolean hasOverlap(Task task) {
		return false;
	}

	@Override
	public DateTime getDateTime() {
		return dateTimeDeadline;
	}

	@Override
	public int compareDateTo(Task task) {
		if (task instanceof FloatingTask) {
			return -1;
		}

		return this.dateTimeDeadline.compareTo(task.getDateTime());
	}

	@Override
	public Task copy() {
		return new DeadlineTask(this);
	}

	@Override
	public boolean isSameDate(DateTime dateTime) {
		return dateTimeDeadline.isTheSameDateAs(dateTime);
	}

	@Override
	public boolean isOverDue(DateTime dateTime) {
		return !isSameDate(dateTime) && !isCompleted && dateTimeDeadline.compareTo(dateTime) == -1;
	}

	@Override
	public boolean isMonth(Month month) {
		return dateTimeDeadline.isMonth(month);
	}

	@Override
	public boolean isDay(Day day) {
		return dateTimeDeadline.isDay(day);
	}

	@Override
	public String getDateString() {
		if (dateTimeDeadline.hasTime()) {
			return dateTimeDeadline.getTime24hStr();
		} else {
			return Constants.EMPTY_STRING;
		}
	}

	@Override
	public String toString() {
		String taskString = String.format(Constants.DISPLAY_TASK_DEADLINE, taskName, dateTimeDeadline.toString());
		String categoryString = Constants.EMPTY_STRING;

		if (hasCategory()) {
			categoryString = String.format(Constants.DISPLAY_CATEGORY, category.getName(), category.getCustomColourName());
		}

		return taskString + categoryString;
	}

	@Override
	public boolean equals(Object o) {
		if (o instanceof DeadlineTask) {
			DeadlineTask deadlineTask = (DeadlineTask) o;
			return this.uniqueId == deadlineTask.uniqueId 
					&& this.getName().equals(deadlineTask.getName())
					&& this.getDateTimeDeadline().equals(deadlineTask.getDateTimeDeadline());
		}
		return false;
	}

	@Override
	public TaskData convertToData() {
		DeadlineTaskData deadlineTaskData;

		if (!hasCategory()) {
			deadlineTaskData = new DeadlineTaskData(taskName, dateTimeDeadline, isCompleted);
		} else {
			deadlineTaskData = new DeadlineTaskData(taskName, dateTimeDeadline, category.getName(), isCompleted);
		}

		return deadlineTaskData;
	}
}
```
###### src\dooyit\common\datatype\EventTask.java
``` java
package dooyit.common.datatype;

import java.util.ArrayList;

import dooyit.common.Constants;
import dooyit.common.datatype.DateTime.Day;
import dooyit.common.datatype.DateTime.Month;

public class EventTask extends Task {

	private DateTime dateTimeStart;
	private DateTime dateTimeEnd;
	private boolean hasMultiDay = false;
	private boolean isMultiDayOn = false;
	private int currentMultiDay = 0;
	private ArrayList<String> multiDayString;

	public EventTask(String taskName, DateTime start, DateTime end) {
		assert (taskName != null && start != null && end != null);

		taskType = TaskType.EVENT;
		this.taskName = taskName;
		this.dateTimeStart = start;
		this.dateTimeEnd = end;

		checkMultiDay(start, end);
	}

	public EventTask(String taskName, DateTime start, DateTime end, Category category) {
		assert (taskName != null && start != null && end != null);

		taskType = TaskType.EVENT;
		this.taskName = taskName;
		this.dateTimeStart = start;
		this.dateTimeEnd = end;
		this.category = category;

		checkMultiDay(start, end);
	}

	public EventTask(Task task, DateTime start, DateTime end) {
		assert (task != null);

		this.taskType = TaskType.EVENT;
		this.displayId = task.displayId;
		this.uniqueId = task.uniqueId;
		this.taskName = task.taskName;
		this.category = task.category;
		this.isCompleted = task.isCompleted;
		this.dateTimeStart = start;
		this.dateTimeEnd = end;

		checkMultiDay(start, end);
	}

	public EventTask(EventTask eventTask) {
		assert (eventTask != null);

		this.taskType = TaskType.EVENT;
		this.displayId = eventTask.displayId;
		this.uniqueId = eventTask.uniqueId;
		this.taskName = eventTask.taskName;
		this.dateTimeStart = eventTask.dateTimeStart;
		this.dateTimeEnd = eventTask.dateTimeEnd;
		this.category = eventTask.category;
		this.isCompleted = eventTask.isCompleted;

		checkMultiDay(dateTimeStart, dateTimeEnd);
	}

	public void checkMultiDay(DateTime start, DateTime end) {
		if (DateTime.hasMultiDay(start, end)) {
			multiDayString = DateTime.getMultiDayString(start, end);
			hasMultiDay = true;
		}
	}

	public void onMultiDay() {
		isMultiDayOn = true;
		currentMultiDay = 0;
		displayId = Constants.UNINITIALISED;
	}

	public void offMultiDay() {
		isMultiDayOn = false;
	}

	public int size() {
		if (hasMultiDay) {
			return multiDayString.size();
		}

		return 1;
	}

	@Override
	public DateTime getDateTime() {
		return dateTimeStart;
	}

	@Override
	public int compareDateTo(Task task) {
		if (task instanceof FloatingTask) {
			return -1;
		}

		return this.dateTimeStart.compareTo(task.getDateTime());
	}

	public DateTime getDateTimeStart() {
		return dateTimeStart;
	}

	public DateTime getDateTimeEnd() {
		return dateTimeEnd;
	}

	@Override
	public boolean hasOverlap(Task task) {

		if (task instanceof EventTask) {
			EventTask eventTask = (EventTask) task;

			return DateTime.isOverlap(dateTimeStart, dateTimeEnd, eventTask.dateTimeStart, eventTask.dateTimeEnd);
		}

		return false;
	}

	@Override
	public boolean isMonth(Month month) {
		return dateTimeStart.isMonth(month) || dateTimeEnd.isMonth(month);
	}

	@Override
	public boolean setDisplayId(int taskId) {

		if (hasMultiDay) {
			if (this.displayId == Constants.UNINITIALISED) {
				this.displayId = taskId;
				return true;
			} else {
				return false;
			}
		} else {
			this.displayId = taskId;
			return true;
		}
	}

	@Override
	public Task copy() {
		return new EventTask(this);
	}

	@Override
	public boolean isSameDate(DateTime dateTime) {
		if (hasMultiDay && isMultiDayOn) {
			return dateTimeStart.isTheSameDateAs(dateTime) 
					|| DateTime.isWithin(dateTime, dateTimeStart, dateTimeEnd) 
					|| dateTimeEnd.isTheSameDateAs(dateTime);
		} else {
			return dateTimeStart.isTheSameDateAs(dateTime);
		}
	}

	@Override
	public boolean isOverDue(DateTime dateTime) {
		boolean isOverDue = !dateTimeStart.isTheSameDateAs(dateTime) 
								&& dateTimeStart.compareTo(dateTime) == -1 
								&& !isCompleted;

		if (isOverDue) {
			hasMultiDay = false;
		}

		return isOverDue;
	}

	@Override
	public boolean isDay(Day day) {
		return DateTime.isWithinDay(day, dateTimeStart, dateTimeEnd);
	}

	@Override
	public String getDateString() {
		if (hasMultiDay && isMultiDayOn) {
			return multiDayString.get((currentMultiDay++) % multiDayString.size());
		}

		return dateTimeStart.getTime24hStr() + Constants.SYMBOL_DASH + dateTimeEnd.getTime24hStr();
	}

	@Override
	public String toString() {
		String taskString = String.format(Constants.DISPLAY_TASK_EVENT, taskName, dateTimeStart.toString(), dateTimeEnd.toString());
		String categoryString = Constants.EMPTY_STRING;

		if (hasCategory()) {
			categoryString = String.format(Constants.DISPLAY_CATEGORY, category.getName(), category.getCustomColourName());
		}

		return taskString + categoryString;
	}

	@Override
	public boolean equals(Object o) {
		if (o instanceof EventTask) {
			EventTask eventTask = (EventTask) o;
			return this.uniqueId == eventTask.uniqueId 
					&& this.getName().equals(eventTask.getName()) 
					&& this.getDateTimeStart().equals(eventTask.getDateTimeStart()) 
					&& this.getDateTimeEnd().equals(eventTask.getDateTimeEnd());
		}
		return false;
	}

	@Override
	public TaskData convertToData() {
		EventTaskData eventTaskData;

		if (!hasCategory()) {
			eventTaskData = new EventTaskData(taskName, dateTimeStart, dateTimeEnd, isCompleted);
		} else {
			eventTaskData = new EventTaskData(taskName, dateTimeStart, dateTimeEnd, category.getName(), isCompleted);
		}

		return eventTaskData;
	}
}
```
###### src\dooyit\common\datatype\FloatingTask.java
``` java
package dooyit.common.datatype;

import dooyit.common.Constants;
import dooyit.common.datatype.DateTime.Day;
import dooyit.common.datatype.DateTime.Month;

public class FloatingTask extends Task {

	public FloatingTask(String taskName) {
		assert (taskName != null);

		taskType = TaskType.FLOATING;
		this.taskName = taskName;
	}

	public FloatingTask(String taskName, Category category) {
		assert (taskName != null);

		taskType = TaskType.FLOATING;
		this.taskName = taskName;
		this.category = category;
	}

	public FloatingTask(FloatingTask floatingTask) {
		assert (floatingTask != null);

		this.taskType = TaskType.FLOATING;
		this.displayId = floatingTask.displayId;
		this.uniqueId = floatingTask.uniqueId;
		this.taskName = floatingTask.taskName;
		this.category = floatingTask.category;
		this.isCompleted = floatingTask.isCompleted;
	}

	public FloatingTask(Task task) {
		assert (task != null);

		this.taskType = TaskType.FLOATING;
		this.displayId = task.displayId;
		this.uniqueId = task.uniqueId;
		this.taskName = task.taskName;
		this.category = task.category;
		this.isCompleted = task.isCompleted;
	}

	@Override
	public boolean hasOverlap(Task task) {
		return false;
	}

	@Override
	public DateTime getDateTime() {
		return null;
	}

	@Override
	public int compareDateTo(Task task) {
		return 1;
	}

	@Override
	public Task copy() {
		return new FloatingTask(this);
	}

	@Override
	public boolean isSameDate(DateTime dateTime) {
		return false;
	}

	@Override
	public boolean isOverDue(DateTime dateTime) {
		return false;
	}

	@Override
	public boolean isMonth(Month month) {
		return false;
	}

	@Override
	public boolean isDay(Day day) {
		return false;
	}

	@Override
	public String getDateString() {
		return Constants.EMPTY_STRING;
	}

	@Override
	public String toString() {

		String taskString = taskName;
		String categoryString = Constants.EMPTY_STRING;

		if (hasCategory()) {
			categoryString = String.format(Constants.DISPLAY_CATEGORY, category.getName(), category.getCustomColourName());
		}

		return taskString + categoryString;
	}

	@Override
	public boolean equals(Object o) {
		if (o instanceof FloatingTask) {
			FloatingTask floatingTask = (FloatingTask) o;
			return this.uniqueId == floatingTask.uniqueId && this.getName().equals(floatingTask.getName());
		}
		return false;
	}

	@Override
	public TaskData convertToData() {
		FloatingTaskData floatingTaskData;

		if (!hasCategory()) {
			floatingTaskData = new FloatingTaskData(taskName, isCompleted);
		} else {
			floatingTaskData = new FloatingTaskData(taskName, category.getName(), isCompleted);
		}

		return floatingTaskData;
	}
}
```
###### src\dooyit\common\datatype\Task.java
``` java
package dooyit.common.datatype;

import dooyit.common.Constants;
import dooyit.common.datatype.DateTime.Day;
import dooyit.common.datatype.DateTime.Month;

public abstract class Task {

	public enum TaskType {
		DEADLINE, EVENT, FLOATING
	};

	protected String taskName;
	protected Category category;
	protected int displayId;
	protected TaskType taskType;
	protected boolean isCompleted;
	protected int uniqueId; // to determine which task is created first
	
	protected static int curUniqueTaskId = 1;
	
	public Task() {
		uniqueId = curUniqueTaskId;
		displayId = curUniqueTaskId;
		curUniqueTaskId++;
	}

	public void changeName(String taskName) {
		this.taskName = taskName;
	}

	public void mark() {
		isCompleted = true;
	}

	public void unMark() {
		isCompleted = false;
	}

	public boolean isCompleted() {
		return isCompleted;
	}

	public void setCategory(Category category) {
		this.category = category;
	}

	public Category getCategory() {
		return category;
	}

	public void removeCategory() {
		category = null;
	}

	public boolean hasCategory() {
		return category != null;
	}

	public String getName() {
		return taskName;
	}

	public int getDisplayId() {
		return displayId;
	}

	/**
	 * 
	 * @param taskId
	 * @return true if ID is successfully set
	 */
	public boolean setDisplayId(int taskId) {
		this.displayId = taskId;
		return true;
	}

	public void resetDisplayId() {
		this.displayId = Constants.UNINITIALISED;
	}

	public int getUniqueId() {
		return uniqueId;
	}

	public void setUniqueId(int uniqueId) {
		this.uniqueId = uniqueId;
	}

	public TaskType getTaskType() {
		return taskType;
	}

	@Override
	public abstract boolean equals(Object o);

	@Override
	public abstract String toString();
	
	public abstract boolean hasOverlap(Task task);
	
	public abstract DateTime getDateTime();

	public abstract int compareDateTo(Task task);

	public abstract Task copy();

	public abstract String getDateString();

	public abstract TaskData convertToData();

	public abstract boolean isOverDue(DateTime dateTime);

	public abstract boolean isSameDate(DateTime dateTime);
	
	public abstract boolean isMonth(Month month);
	
	public abstract boolean isDay(Day month);
}
```
###### src\dooyit\common\datatype\TaskGroup.java
``` java
package dooyit.common.datatype;

import java.util.ArrayList;

/**
 * TaskGroup is a class that wraps around arraylist of task and gives them a
 * title like Today, Overdue, Monday.
 * 
 * @author limtaeu
 *
 */
public class TaskGroup {

	private String title;
	private ArrayList<Task> tasks;
	private DateTime dateTime;

	public TaskGroup(String title) {
		this.title = title;
		tasks = new ArrayList<Task>();
	}

	public TaskGroup(String title, DateTime dateTime) {
		this.title = title;
		this.dateTime = dateTime;
		tasks = new ArrayList<Task>();
	}

	public void addTask(Task task) {
		this.tasks.add(task);
	}

	public void addTasks(ArrayList<Task> tasks) {
		this.tasks.addAll(tasks);
	}

	public DateTime getDateTime() {
		return dateTime;
	}

	public void setTitle(String title) {
		this.title = title;
	}

	public String getTitle() {
		if (hasDateTime()) {
			String dateString = dateTime.getDate();
			return title + ", " + dateString;
		} else {
			return title;
		}
	}

	public ArrayList<Task> getTasks() {

		return tasks;
	}

	public int size() {
		return tasks.size();
	}

	public boolean isEmpty() {
		return tasks.isEmpty();
	}

	public boolean hasDateTime() {
		return dateTime != null;
	}
}
```
###### src\dooyit\common\exception\IncorrectInputException.java
``` java

package dooyit.common.exception;

public class IncorrectInputException extends RuntimeException {

	private static final long serialVersionUID = 1L;

	public IncorrectInputException() {
		super();
	}

	public IncorrectInputException(String s) {
		super(s);
	}

	public IncorrectInputException(String s, Throwable throwable) {
		super(s, throwable);
	}

	public IncorrectInputException(Throwable throwable) {
		super(throwable);
	}
}
```
###### src\dooyit\common\utils\CommandUtils.java
``` java
package dooyit.common.utils;

import java.util.ArrayList;
import dooyit.common.datatype.DateTime;
import dooyit.common.datatype.DateTime.Day;
import dooyit.common.datatype.DateTime.Month;
import dooyit.logic.commands.AddCategoryCommand;
import dooyit.logic.commands.AddTaskCommand;
import dooyit.logic.commands.ChangeThemeCommand;
import dooyit.logic.commands.ClearTaskCommand;
import dooyit.logic.commands.Command;
import dooyit.logic.commands.DeleteCategoryCommand;
import dooyit.logic.commands.DeleteTaskCommand;
import dooyit.logic.commands.EditCategoryCommand;
import dooyit.logic.commands.EditTaskCommand;
import dooyit.logic.commands.ExitCommand;
import dooyit.logic.commands.HelpCommand;
import dooyit.logic.commands.InvalidCommand;
import dooyit.logic.commands.MarkTaskCommand;
import dooyit.logic.commands.MoveToCategory;
import dooyit.logic.commands.RedoCommand;
import dooyit.logic.commands.SearchCommand;
import dooyit.logic.commands.ShowCommand;
import dooyit.logic.commands.StorageCommand;
import dooyit.logic.commands.UnMoveCategory;
import dooyit.logic.commands.UndoCommand;
import dooyit.logic.commands.UnmarkTaskCommand;

/**
 * the command utils acts as a factory for command objects
 * 
 * @author limtaeu
 *
 */
public class CommandUtils {

	public static Command createAddCommandFloat(String data) {
		AddTaskCommand addCommand = new AddTaskCommand(data);
		return addCommand;
	}

	public static Command createAddCommandDeadline(String data, DateTime deadline) {
		AddTaskCommand addCommand = new AddTaskCommand(data, deadline);
		return addCommand;
	}

	public static Command createAddCommandEvent(String data, DateTime start, DateTime end) {
		AddTaskCommand addCommand = new AddTaskCommand(data, start, end);
		return addCommand;
	}

	public static Command createDeleteCommand(int deleteId) {
		DeleteTaskCommand deleteCommand = new DeleteTaskCommand(deleteId);
		return deleteCommand;
	}

	public static Command createDeleteCommand(ArrayList<Integer> deleteIds) {
		DeleteTaskCommand deleteCommand = new DeleteTaskCommand(deleteIds);
		return deleteCommand;
	}

	public static Command createMarkCommand(int markId) {
		MarkTaskCommand deleteCommand = new MarkTaskCommand(markId);
		return deleteCommand;
	}

	public static Command createMarkCommand(ArrayList<Integer> markIds) {
		MarkTaskCommand deleteCommand = new MarkTaskCommand(markIds);
		return deleteCommand;
	}

	public static Command createUnMarkCommand(int unMarkId) {
		UnmarkTaskCommand deleteCommand = new UnmarkTaskCommand(unMarkId);
		return deleteCommand;
	}

	public static Command createUnMarkCommand(ArrayList<Integer> unMarkIds) {
		UnmarkTaskCommand deleteCommand = new UnmarkTaskCommand(unMarkIds);
		return deleteCommand;
	}

	public static Command createAddCategoryCommand(String categoryName) {
		AddCategoryCommand addCategoryCommand = new AddCategoryCommand(categoryName);
		return addCategoryCommand;
	}

	public static Command createAddCategoryCommand(String categoryName, String colorString) {
		AddCategoryCommand addCategoryCommand = new AddCategoryCommand(categoryName, colorString);
		return addCategoryCommand;
	}

	public static Command createMoveToCategoryCommand(int taskID, String categoryName) {
		MoveToCategory addCategoryCommand = new MoveToCategory(taskID, categoryName);
		return addCategoryCommand;
	}

	public static Command createMoveToCategoryCommand(ArrayList<Integer> taskIDs, String categoryName) {
		MoveToCategory addCategoryCommand = new MoveToCategory(taskIDs, categoryName);
		return addCategoryCommand;
	}

	public static Command createDeleteCategoryCommand(String categoryName) {
		DeleteCategoryCommand deleteCategoryCommand = new DeleteCategoryCommand(categoryName);
		return deleteCategoryCommand;
	}

	public static Command createUnMoveCategoryCommand(int taskId) {
		UnMoveCategory removeCategoryFromTaskCommand = new UnMoveCategory(taskId);
		return removeCategoryFromTaskCommand;
	}

	public static Command createEditCategoryCommand(String categoryName, String newCategoryName) {
		EditCategoryCommand editCategoryCommand = new EditCategoryCommand(categoryName, newCategoryName);
		return editCategoryCommand;
	}

	public static Command createEditCategoryCommand(String categoryName, String newCategoryName, String newColourString) {
		EditCategoryCommand editCategoryCommand = new EditCategoryCommand(categoryName, newCategoryName, newColourString);
		return editCategoryCommand;
	}

	public static Command createShowTodayCommand() {
		ShowCommand showCommand = new ShowCommand(ShowCommand.ShowCommandType.TODAY);
		return showCommand;
	}

	public static Command createShowNext7DaysCommand() {
		ShowCommand showCommand = new ShowCommand(ShowCommand.ShowCommandType.NEXT7DAY);

		return showCommand;
	}

	public static Command createShowFloatCommand() {
		ShowCommand showCommand = new ShowCommand(ShowCommand.ShowCommandType.FLOAT);
		return showCommand;
	}

	public static Command createShowAllCommand() {
		ShowCommand showCommand = new ShowCommand(ShowCommand.ShowCommandType.ALL);
		return showCommand;
	}

	public static Command createShowCompletedCommand() {
		ShowCommand showCommand = new ShowCommand(ShowCommand.ShowCommandType.COMPLETED);
		return showCommand;
	}

	public static Command createShowCategoryCommand(String categoryName) {
		ShowCommand showCommand = new ShowCommand(ShowCommand.ShowCommandType.CATEGORY, categoryName);
		return showCommand;
	}

	public static Command createEditCommandToFloat(int taskId) {
		EditTaskCommand editCommand = new EditTaskCommand(taskId);
		return editCommand;
	}

	public static Command createEditCommandName(int taskId, String taskName) {
		EditTaskCommand editCommand = new EditTaskCommand(taskId, taskName);
		return editCommand;
	}

	public static Command createEditCommandDeadline(int taskId, DateTime deadline) {
		EditTaskCommand editCommand = new EditTaskCommand(taskId, deadline);
		return editCommand;
	}

	public static Command createEditCommandEvent(int taskId, DateTime start, DateTime end) {
		EditTaskCommand editCommand = new EditTaskCommand(taskId, start, end);
		return editCommand;
	}

	public static Command createEditCommandNameAndDeadline(int taskId, String taskName, DateTime deadline) {
		EditTaskCommand editCommand = new EditTaskCommand(taskId, taskName, deadline);
		return editCommand;
	}

	public static Command createEditCommandNameAndEvent(int taskId, String taskName, DateTime start, DateTime end) {
		EditTaskCommand editCommand = new EditTaskCommand(taskId, taskName, start, end);
		return editCommand;
	}

	public static Command createStorageCommand(String path) {
		StorageCommand storageCommand = new StorageCommand(path);
		return storageCommand;
	}

	public static Command createChangeThemeCommand(String themeString) {
		ChangeThemeCommand changeThemeCommand = new ChangeThemeCommand(themeString);
		return changeThemeCommand;
	}

	public static Command createUndoCommand() {
		UndoCommand undoCommand = new UndoCommand();
		return undoCommand;
	}

	public static Command createRedoCommand() {
		RedoCommand undoCommand = new RedoCommand();
		return undoCommand;
	}

	public static Command createSearchCommand(String searchString) {
		SearchCommand searchCommand = new SearchCommand(searchString);
		return searchCommand;
	}

	public static Command createSearchCommand(DateTime dateTime) {
		SearchCommand searchCommand = new SearchCommand(dateTime);
		return searchCommand;
	}

	public static Command createSearchCommand(String searchString, Month month) {
		SearchCommand searchCommand = new SearchCommand(searchString, month);
		return searchCommand;
	}

	public static Command createSearchCommand(String searchString, Day day) {
		SearchCommand searchCommand = new SearchCommand(searchString, day);
		return searchCommand;
	}

	public static Command createClearCommand() {
		ClearTaskCommand clearCommand = new ClearTaskCommand();
		return clearCommand;
	}

	public static Command createHelpCommand() {
		HelpCommand undoCommand = new HelpCommand();
		return undoCommand;
	}

	public static Command createInvalidCommand(String errorMessage) {
		InvalidCommand invalidCommand = new InvalidCommand(errorMessage);
		return invalidCommand;
	}

	public static Command createExitCommand() {
		ExitCommand exitCommand = new ExitCommand();
		return exitCommand;
	}

}
```
###### src\dooyit\common\utils\TaskDateComparator.java
``` java
package dooyit.common.utils;

import java.util.Comparator;

import dooyit.common.datatype.Task;

public class TaskDateComparator implements Comparator<Task> {

	public int compare(Task task1, Task task2) {
		return task1.compareDateTo(task2);
	}

	public boolean equals(Object obj) {
		return this == obj;
	}

}
```
###### src\dooyit\common\utils\TaskUniqueIdComparator.java
``` java
package dooyit.common.utils;

import java.util.Comparator;

import dooyit.common.datatype.Task;

public class TaskUniqueIdComparator implements Comparator<Task> {

	public int compare(Task task1, Task task2) {
		if (task1.getUniqueId() < task2.getUniqueId()) {
			return -1;
		} else if (task1.getUniqueId() > task2.getUniqueId()) {
			return 1;
		} else {
			return 0;
		}
	}

	public boolean equals(Object obj) {
		return this == obj;
	}
}
```
###### src\dooyit\logic\api\Action.java
``` java
package dooyit.logic.api;

/**
 * actions that the logic can perform
 * @author limtaeu
 *
 */
public enum Action {
	ADD_TODAY_TASK,
	ADD_NEXT7DAY_TASK,
	ADD_FLOATING_TASK,
	ADD_ALL_TASK,
	DELETE_TASK,
	ADD_CATEGORY,
	SET_CATEGORY,
	ADD_N_SET_CATEGORY,
	DELETE_CATEGORY,
	REMOVE_CAT_FROM_TASK,
	EDIT_CATEGORY,
	CLEAR_TASK,
	CLEAR_CATEGORY,
	MARK_TASK,
	UNMARK_TASK,
	EDIT_NAME,
	EDIT_TO_TODAY_TASK,
	EDIT_TO_NEXT7DAY_TASK,
	EDIT_TO_FLOATING_TASK,
	EDIT_TO_ALL_TASK,
	SHOW_TODAY_TASK,
	SHOW_NEXT7DAY_TASK,
	SHOW_FLOATING_TASK,
	SHOW_ALL_TASK,
	SHOW_COMPLETED,
	SHOW_CATEGORY,
	SEARCH,
	HELP,
	UNDO,
	REDO,
	CHANGE_THEME_DEFAULT,
	CHANGE_THEME_DARK,
	CHANGE_THEME_AQUA,
	CHANGE_THEME_CUSTOM,
	SET_STORAGE_PATH,
	ERROR,
	EXIT
}
```
###### src\dooyit\logic\api\CategoryManager.java
``` java
package dooyit.logic.api;

import java.util.ArrayList;
import dooyit.common.datatype.Category;
import dooyit.common.datatype.CustomColour;
import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.Constants;

/**
 * CategoryManager handles the creation and management of category and its
 * colour. Does not allow duplicated category name.
 * 
 * if a category is created without specifying a colour, a random suitable
 * colour will automatically picked
 * 
 * @author limtaeu
 *
 */
public class CategoryManager {
	ArrayList<Category> categories;
	ColourManager colourManager;
	private Category selectedCategory;

	public CategoryManager() {
		colourManager = new ColourManager();
		categories = new ArrayList<Category>();
	}

	public void setDefaultCategories() {
		if (categories.size() == 0) {
			addCategory(Constants.DEFAULT_CATEGORY_SCHOOL);
			addCategory(Constants.DEFAULT_CATEGORY_ENTERTAINMENT);
		}
	}

	public void addCategory(Category category) throws IncorrectInputException {
		if (contains(category)) {
			throw new IncorrectInputException(String.format(Constants.FEEDBACK_FAIL_CATEGORY_EXISTS, category.getName()));
		}

		categories.add(category);
	}

	/**
	 * creates a category with the categoryName and randomly pick a recommended
	 * colour for it
	 * 
	 * @param categoryName
	 * @return added category
	 * @throws IncorrectInputException
	 */
	public Category addCategory(String categoryName) throws IncorrectInputException {
		if (contains(categoryName)) {
			throw new IncorrectInputException(String.format(Constants.FEEDBACK_FAIL_CATEGORY_EXISTS, categoryName));
		}
		categoryName = capitalizeFirstCharacter(categoryName);
		Category category = new Category(categoryName, colourManager.pickRandomRecommendedCustomColour());
		categories.add(category);
		return category;
	}

	/**
	 * creates a category with specified categoryName and colour name. This
	 * method will check if the colour exists, if it doesnt a random suitable
	 * colour will be picked instead
	 * 
	 * @param categoryName
	 * @param customColourString
	 * @return added category
	 * @throws IncorrectInputException
	 */
	public Category addCategory(String categoryName, String customColourString) throws IncorrectInputException {
		if (contains(categoryName)) {
			throw new IncorrectInputException(String.format(Constants.FEEDBACK_FAIL_CATEGORY_EXISTS, categoryName));
		}

		if (!colourManager.contains(customColourString)) {
			addCategory(categoryName);
			throw new IncorrectInputException(String.format(Constants.FEEDBACK_INVALID_COLOUR_WITH_SUGGESTION, customColourString));
		}

		categoryName = capitalizeFirstCharacter(categoryName);
		CustomColour customColour = colourManager.find(customColourString);
		Category category = new Category(categoryName, customColour);
		categories.add(category);
		return category;
	}

	/**
	 * change the name of the category
	 * 
	 * @param category
	 * @param newCategoryName
	 */
	public void editCategoryName(Category category, String newCategoryName) {
		category.setName(capitalizeFirstCharacter(newCategoryName));
	}

	/**
	 * change the colour of the category
	 * 
	 * @param category
	 * @param newColourString
	 * @return true is successful
	 */
	public boolean editCategoryColour(Category category, String newColourString) {
		if (colourManager.contains(newColourString)) {
			CustomColour customColour = colourManager.find(newColourString);
			category.setCustomColour(customColour);
			return true;
		} else {
			return false;
		}
	}

	public boolean containsCustomColour(String customColourString) {
		return colourManager.contains(customColourString);
	}

	public void setSelectedCategory(Category category) {
		this.selectedCategory = category;
	}

	public Category getSelectedCategory() {
		return selectedCategory;
	}

	public Category remove(String categoryName) {
		for (Category category : categories) {
			if (category.equals(categoryName)) {
				categories.remove(category);
				return category;
			}
		}
		return null;
	}

	public boolean remove(Category inCategory) {
		for (Category category : categories) {
			if (category.equals(inCategory)) {
				categories.remove(category);
				return true;
			}
		}
		return false;
	}

	public boolean contains(String categoryName) {
		for (int i = 0; i < categories.size(); i++) {
			if (categories.get(i).equals(categoryName)) {
				return true;
			}
		}
		return false;
	}

	public boolean contains(Category category) {
		for (int i = 0; i < categories.size(); i++) {
			if (categories.get(i).equals(category)) {
				return true;
			}
		}
		return false;
	}

	public Category find(String categoryName) {
		for (int i = 0; i < categories.size(); i++) {
			if (categories.get(i).equals(categoryName)) {
				return categories.get(i);
			}
		}
		return null;
	}

	public Category find(Category category) {
		for (int i = 0; i < categories.size(); i++) {
			if (categories.get(i).equals(category)) {
				return categories.get(i);
			}
		}
		return null;
	}

	public ArrayList<Category> getAllCategories() {
		return categories;
	}

	public ArrayList<Category> clear() {
		ArrayList<Category> clearedCategories = new ArrayList<Category>(categories);
		this.categories.clear();
		return clearedCategories;
	}

	public void load(ArrayList<Category> categories) {
		this.categories.addAll(categories);
	}

	/**
	 * capitalize the first character and lower case the rest
	 * 
	 * @param categoryName
	 * @return
	 */
	private String capitalizeFirstCharacter(String categoryName) {
		assert (categoryName != null);

		if (categoryName == Constants.EMPTY_STRING) {
			return Constants.EMPTY_STRING;
		}

		categoryName = categoryName.toLowerCase();
		char capitalFirstLetter = Character.toUpperCase(categoryName.charAt(0));
		String string = capitalFirstLetter + categoryName.substring(1);

		return string;
	}
}
```
###### src\dooyit\logic\api\ColourManager.java
``` java
package dooyit.logic.api;

import java.util.ArrayList;
import java.util.Random;

import dooyit.common.datatype.CustomColour;

/**
 * The colour manager will store all the possible colours tha dooyit has. It
 * also has pickRecommendedColour to get a random colour that are more suitable
 * and visible for the UI
 * 
 * @author limtaeu
 *
 */
public class ColourManager {
	ArrayList<CustomColour> usedColours;
	Random random;
	ArrayList<CustomColour> recommendedColours;
	ArrayList<CustomColour> availableColours;
	ArrayList<CustomColour> colourPool;

	public ColourManager() {
		addAvailableColours();
		addRecommendedColours();
		init();
	}

	/**
	 * initialise the random generator and colourpool with recommendedColours
	 */
	public void init() {
		random = new Random();
		colourPool = new ArrayList<CustomColour>(recommendedColours);
	}

	/**
	 * add recommendedColours into recommendedColours arraylist
	 */
	public void addRecommendedColours() {
		recommendedColours = new ArrayList<CustomColour>();
		recommendedColours.add(CustomColour.BLUE);
		recommendedColours.add(CustomColour.CYAN);
		recommendedColours.add(CustomColour.GREEN);
		recommendedColours.add(CustomColour.PINK);
		recommendedColours.add(CustomColour.RED);
		recommendedColours.add(CustomColour.YELLOW);
		recommendedColours.add(CustomColour.ORANGE);
	}

	/**
	 * add all availableColours into availableColours arrayList
	 */
	public void addAvailableColours() {
		availableColours = new ArrayList<CustomColour>();
		availableColours.add(CustomColour.BLACK);
		availableColours.add(CustomColour.BLUE);
		availableColours.add(CustomColour.CYAN);
		availableColours.add(CustomColour.GREY);
		availableColours.add(CustomColour.GREEN);
		availableColours.add(CustomColour.MAGENTA);
		availableColours.add(CustomColour.PINK);
		availableColours.add(CustomColour.RED);
		availableColours.add(CustomColour.YELLOW);
		availableColours.add(CustomColour.WHITE);
		availableColours.add(CustomColour.ORANGE);
	}

	/**
	 * randomly pick a recommended colour colourpool and remove the colour for
	 * the colourpool
	 * 
	 * @return the colour that is picked
	 */
	public CustomColour pickRandomRecommendedCustomColour() {
		if (colourPool.size() == 0) {
			colourPool = new ArrayList<CustomColour>(recommendedColours);
		}
		return colourPool.remove(random.nextInt(colourPool.size()));
	}

	public boolean contains(String name) {
		for (CustomColour customColor : availableColours) {
			if (customColor.equals(name)) {
				return true;
			}
		}
		return false;
	}

	public boolean contains(CustomColour customColor) {
		boolean hasCustomColor = availableColours.contains(customColor);
		return hasCustomColor;
	}

	public CustomColour find(String customColorString) {
		for (CustomColour customColor : availableColours) {
			if (customColor.equals(customColorString)) {
				return customColor;
			}
		}
		return null;
	}

}
```
###### src\dooyit\logic\api\DataManager.java
``` java
package dooyit.logic.api;

import java.util.ArrayList;

import dooyit.common.datatype.Category;
import dooyit.common.datatype.CategoryData;
import dooyit.common.datatype.Task;
import dooyit.common.datatype.TaskData;
import dooyit.common.exception.IncorrectInputException;

/**
 * DataManager is responsible for converting all tasks into taskDatas and
 * loading task and category into logic from taskData
 * 
 * @author limtaeu
 *
 */
public class DataManager {

	public DataManager() {

	}

	public ArrayList<TaskData> convertTaskstoTaskDatas(ArrayList<Task> tasks) {
		ArrayList<TaskData> taskDatas = new ArrayList<TaskData>();

		for (Task task : tasks) {
			TaskData taskData = task.convertToData();
			taskDatas.add(taskData);
		}

		return taskDatas;
	}

	public ArrayList<CategoryData> convertCategorytoCategoryDatas(ArrayList<Category> categories) {
		ArrayList<CategoryData> categoryDatas = new ArrayList<CategoryData>();

		for (Category category : categories) {
			CategoryData categoryData = category.convertToData();
			categoryDatas.add(categoryData);
		}

		return categoryDatas;
	}

	public void loadCategoryData(LogicController logic, ArrayList<CategoryData> categoryDatas) {
		for (CategoryData categoryData : categoryDatas) {
			try {
				logic.addCategory(categoryData.getName(), categoryData.getColor());
			} catch (IncorrectInputException e) {

			}
		}
	}

	public void loadTaskData(LogicController logic, ArrayList<TaskData> taskDatas) {
		for (TaskData taskData : taskDatas) {
			Task task = taskData.convertToTask();

			if (taskData.hasCategory()) {
				Category category = logic.findCategory(taskData.getCategory());
				task.setCategory(category);
			}

			logic.addTask(task);
		}
	}

}
```
###### src\dooyit\logic\api\HistoryManager.java
``` java
package dooyit.logic.api;

import java.util.Stack;

import dooyit.logic.commands.Command;
import dooyit.logic.commands.ReversibleCommand;

/**
 * history manager is responsible for adding reversible commands into history
 * for undoing the command as well as redo
 * 
 * @author limtaeu
 *
 */
public class HistoryManager {

	private Stack<ReversibleCommand> undoHistory;
	private Stack<ReversibleCommand> redoHistory;

	public HistoryManager() {
		undoHistory = new Stack<ReversibleCommand>();
		redoHistory = new Stack<ReversibleCommand>();
	}

	/**
	 * add command into history stack, check if command is reversible and
	 * executed successfully without error before adding
	 * 
	 * @param command
	 */
	public void addCommand(Command command) {
		if (command.hasError()) {
			return;
		}

		if (command instanceof ReversibleCommand) {
			undoHistory.push((ReversibleCommand) command);
		}
	}

	/**
	 * undo latest command
	 * 
	 * @param logic
	 * @return true if successful
	 */
	public boolean undoCommand(LogicController logic) {
		ReversibleCommand reversibleCommand;
		if (!undoHistory.isEmpty()) {
			reversibleCommand = undoHistory.pop();
			reversibleCommand.undo(logic);
			redoHistory.push(reversibleCommand);
			return true;
		}
		return false;
	}

	/**
	 * redo latest command
	 * 
	 * @param logic
	 * @return true if successful
	 */
	public boolean redoCommand(LogicController logic) {
		ReversibleCommand reversibleCommand;
		if (!redoHistory.isEmpty()) {
			reversibleCommand = redoHistory.pop();
			reversibleCommand.redo(logic);
			undoHistory.push(reversibleCommand);
			return true;
		}
		return false;
	}
}
```
###### src\dooyit\logic\api\LogicAction.java
``` java
package dooyit.logic.api;

public class LogicAction {

	Action action;
	String message = "";

	public LogicAction(Action action) {
		this.action = action;
	}

	public LogicAction(Action action, String message) {
		this.action = action;
		this.message = message;
	}

	public Action getAction() {
		return this.action;
	}

	public String getMessage() {
		return this.message;
	}

	public void setMessage(String message) {
		this.message = message;
	}

	public boolean hasMessage() {
		return !message.equals("");
	}
}
```
###### src\dooyit\logic\api\LogicController.java
``` java
package dooyit.logic.api;

import dooyit.storage.StorageController;
import dooyit.parser.ParserController;
import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.Constants;
import dooyit.logic.commands.*;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import dooyit.common.datatype.Category;
import dooyit.common.datatype.CategoryData;
import dooyit.common.datatype.DateTime;
import dooyit.common.datatype.Task;
import dooyit.common.datatype.TaskData;
import dooyit.common.datatype.TaskGroup;
import dooyit.common.datatype.DateTime.Day;
import dooyit.common.datatype.DateTime.Month;

/**
 * The logicController process the input and perform the neccessary actions
 * @author limtaeu
 *
 */
public class LogicController {

	private ParserController parserController;
	private StorageController storageController;
	private TaskManager taskManager;
	private CategoryManager categoryManager;
	private HistoryManager historyManager;
	private DataManager dataManager;
	private static Logger logger = Logger.getLogger(Constants.LOG_LOGIC);
	private boolean isSaveOn = true;
	private boolean displayCommandline = false;

	public LogicController() {
		logger.log(Level.INFO, Constants.LOG_MSG_INITIALISING_LOGIC_CLASS);

		initParser();
		initTaskManager();
		initCategoryManager();
		initHistoryManager();
		initStorage();
		initDataManager();
		loadFromStorage();
		setDefaultCategories();
		save();

		logger.log(Level.INFO, Constants.LOG_MSG_END_OF_INITIALISING_LOGIC_CLASS);
	}

	public void initParser() {
		logger.log(Level.INFO, Constants.LOG_MSG_INITIALISING_PARSER);
		parserController = new ParserController();
	}

	public void initTaskManager() {
		logger.log(Level.INFO, Constants.LOG_MSG_INITIALISING_TASK_MANAGER);
		taskManager = new TaskManager();
	}

	public void initCategoryManager() {
		logger.log(Level.INFO, Constants.LOG_MSG_INITIALISING_CATEGORY_MANAGER);
		categoryManager = new CategoryManager();
	}

	public void initHistoryManager() {
		logger.log(Level.INFO, Constants.LOG_MSG_INITIALISING_HISTORY_MANAGER);
		historyManager = new HistoryManager();
	}

	private void initStorage() {
		logger.log(Level.INFO, Constants.LOG_MSG_INITIALISING_STORAGE);
		try {
			storageController = new StorageController();
		} catch (IOException e) {
			logger.log(Level.SEVERE, Constants.ERROR_FAIL_TO_CREATE_STORAGE);
		}
	}

	private void initDataManager() {
		logger.log(Level.INFO, Constants.LOG_MSG_INITIALISING_DATA_MANAGER);
		dataManager = new DataManager();
	}

	public void loadFromStorage() {
		logger.log(Level.INFO, Constants.LOG_MSG_LOADING_DATA_FROM_STORAGE);
		try {
			clearTasks();
			loadCategoryDataFromStorage();
			loadTaskDataFromStorage();
		} catch (IOException e) {
			logger.log(Level.SEVERE, Constants.ERROR_FAIL_TO_LOAD_TASK_FROM_STORAGE);
		}
	}

	/**
	 * set some default categories if there is category manager doesnt have any
	 * categories.
	 */
	public void setDefaultCategories() {
		categoryManager.setDefaultCategories();
	}

	/**
	 * process and execute command input from user
	 * 
	 * @param input
	 */
	public LogicAction processInput(String input) {
		Command command = parserController.getCommand(input);
		assert (command != null);
		LogicAction logicAction = processCommand(command);
		return logicAction;
	}

	public LogicAction processCommand(Command command) {
		LogicAction logicAction = executeCommand(command);
		addCommandToHistory(command);
		save();
		displayInCommandline();
		return logicAction;
	}

	private LogicAction executeCommand(Command command) {
		LogicAction logicAction = null;

		try {
			logicAction = command.execute(this);
		} catch (IncorrectInputException e) {
			logger.log(Level.SEVERE, Constants.ERROR_INCORRECT_INPUT);
			logicAction = new LogicAction(Action.ERROR, Constants.FEEDBACK_INCORRECT_INPUT);
		}
		return logicAction;
	}

	private void addCommandToHistory(Command command) {
		historyManager.addCommand(command);
	}

	public boolean undo() {
		return historyManager.undoCommand(this);
	}

	public boolean redo() {
		return historyManager.redoCommand(this);
	}

	private void save() {
		if (!isSaveOn) {
			return;
		}

		try {
			storageController.saveTasks(getTaskDatas());
			storageController.saveCategories(getCategoryDatas());
		} catch (IOException e) {
			logger.log(Level.SEVERE, Constants.ERROR_FAIL_TO_SAVE);
		}

	}

	private void displayInCommandline() {
		if (displayCommandline) {
			taskManager.display();
		}
	}

	public void enableSave() {
		isSaveOn = true;
	}

	public void disableSave() {
		isSaveOn = false;
	}

	public ArrayList<TaskData> getTaskDatas() {
		ArrayList<Task> tasks = taskManager.getAllTasks();
		return dataManager.convertTaskstoTaskDatas(tasks);
	}

	public ArrayList<CategoryData> getCategoryDatas() {
		ArrayList<Category> categories = categoryManager.getAllCategories();
		return dataManager.convertCategorytoCategoryDatas(categories);
	}

	public void loadCategoryDataFromStorage() throws IOException {
		ArrayList<CategoryData> categoryDatas = storageController.loadCategories();
		dataManager.loadCategoryData(this, categoryDatas);
	}

	public void loadTaskDataFromStorage() throws IOException {
		ArrayList<TaskData> taskDatas = storageController.loadTasks();
		dataManager.loadTaskData(this, taskDatas);
	}

	public void setSelectedCategory(Category category) {
		categoryManager.setSelectedCategory(category);
	}

	public Category getSelectedCategory() {
		return categoryManager.getSelectedCategory();
	}

	public void setSearchKey(String searchString) {
		taskManager.setSearchKey(searchString);
	}

	public void setSearchKey(String searchKey, Day day) {
		taskManager.setSearchKey(searchKey, day);
	}

	public void setSearchKey(String searchKey, Month month) {
		taskManager.setSearchKey(searchKey, month);
	}

	public void setSearchKey(DateTime dateTime) {
		taskManager.setSearchKey(dateTime);
	}

	public ArrayList<TaskGroup> getTaskGroupsToday() {
		return taskManager.getTaskGroupsToday();
	}

	public ArrayList<TaskGroup> getTaskGroupsNext7Days() {
		return taskManager.getTaskGroupsNext7Days();
	}

	public ArrayList<TaskGroup> getTaskGroupsAll() {
		return taskManager.getTaskGroupsAll();
	}

	public ArrayList<TaskGroup> getTaskGroupsCompleted() {
		return taskManager.getTaskGroupsCompleted();
	}

	public ArrayList<TaskGroup> getTaskGroupsFloating() {
		return taskManager.getTaskGroupsFloating();
	}

	public ArrayList<TaskGroup> getTaskGroupCategory() {
		return taskManager.getTaskGroupsCategory(categoryManager.getSelectedCategory());
	}

	public ArrayList<Category> getAllCategories() {
		return categoryManager.getAllCategories();
	}

	public ArrayList<TaskGroup> getSearchTaskGroup() {
		return taskManager.getTaskGroupSearched();
	}

	public void addTask(Task task) {
		taskManager.add(task);
	}

	public Task addFloatingTask(String taskName) {
		Task addedTask = taskManager.addFloatingTask(taskName);
		return addedTask;
	}

	public Task addDeadlineTask(String taskName, DateTime dateTimeDeadline) {
		Task addedTask = taskManager.addDeadlineTask(taskName, dateTimeDeadline);
		return addedTask;
	}

	public Task addEventTask(String taskName, DateTime dateTimeStart, DateTime dateTimeEnd) {
		Task addedTask = taskManager.addEventTask(taskName, dateTimeStart, dateTimeEnd);
		return addedTask;
	}

	public Task changeToFloatingTask(int taskId) {
		return taskManager.changeToFloatingTask(taskId);
	}

	public Task changeTaskName(int taskId, String newName) {
		return taskManager.changeTaskName(taskId, newName);
	}

	public Task changeTaskToDeadline(int taskId, DateTime dateTimeDeadline) {
		return taskManager.changeTaskToDeadline(taskId, dateTimeDeadline);
	}

	public Task changeTaskToEvent(int taskId, DateTime dateTimeStart, DateTime dateTimeEnd) {
		return taskManager.changeTaskToEvent(taskId, dateTimeStart, dateTimeEnd);
	}

	public boolean containsTask(int taskId) {
		return taskManager.contains(taskId);
	}

	public boolean containsTask(Task task) {
		return taskManager.contains(task);
	}

	public Task findTask(int taskId) {
		return taskManager.find(taskId);
	}

	public Task removeTask(int taskId) {
		Task removedTask = taskManager.remove(taskId);
		return removedTask;
	}

	public boolean removeTask(Task task) {
		boolean isRemoved = taskManager.remove(task);
		return isRemoved;
	}

	public void loadTasks(ArrayList<Task> tasks) {
		taskManager.load(tasks);
	}

	public void markTask(Task task) {
		taskManager.markTask(task);
	}

	public void markTask(int taskId) {
		taskManager.markTask(taskId);
	}

	public void unmarkTask(Task task) {
		taskManager.unmarkTask(task);
	}

	public boolean unmarkTask(int taskId) {
		return taskManager.unmarkTask(taskId);
	}

	public boolean isFloatingTask(Task task) {
		return taskManager.isFloatingTask(task);
	}

	public boolean isTodayTask(Task task) {
		return taskManager.isTodayTask(task);
	}

	public boolean isNext7daysTask(Task task) {
		return taskManager.isNext7DaysTask(task);
	}

	public int noOfTask() {
		return taskManager.size();
	}

	public boolean hasOverlapWithOverEventTask(Task task) {
		return taskManager.hasOverlapWithOverEventTask(task);
	}

	public ArrayList<Task> removeTasksWithCategory(Category category) {
		ArrayList<Task> tasksWithCategoty = taskManager.removeTasksWithCategory(category);
		return tasksWithCategoty;
	}

	public ArrayList<Task> clearTasks() {
		ArrayList<Task> clearedTasks = taskManager.clear();
		return clearedTasks;
	}

	public void addCategory(Category category) throws IncorrectInputException {
		categoryManager.addCategory(category);
	}

	public Category addCategory(String categoryName) throws IncorrectInputException {
		Category addedCategory = categoryManager.addCategory(categoryName);
		return addedCategory;
	}

	public Category addCategory(String categoryName, String colourString) throws IncorrectInputException {
		Category addedCategory = categoryManager.addCategory(categoryName, colourString);
		return addedCategory;
	}

	public Category removeCategory(String categoryName) {
		Category removedCategory = categoryManager.remove(categoryName);
		return removedCategory;
	}

	public boolean removeCategory(Category category) {
		return categoryManager.remove(category);
	}

	public boolean containsCategory(String categoryName) {
		return categoryManager.contains(categoryName);
	}

	public Category findCategory(String categoryName) {
		return categoryManager.find(categoryName);
	}

	public ArrayList<Category> clearCategory() {
		ArrayList<Category> clearedCategories = categoryManager.clear();
		return clearedCategories;
	}

	public boolean containsCustomColour(String customColourString) {
		return categoryManager.containsCustomColour(customColourString);
	}

	public void editCategoryName(Category category, String newCategoryName) {
		categoryManager.editCategoryName(category, newCategoryName);
	}

	public boolean editCategoryColour(Category category, String newClourString) {
		return categoryManager.editCategoryColour(category, newClourString);
	}

	public String getFilePath() {
		return storageController.getFilePath();
	}

	public boolean setFileDestinationPath(String path) throws IncorrectInputException {
		try {
			return storageController.setFileDestination(path);
		} catch (IOException e) {
			logger.log(Level.SEVERE, Constants.ERROR_SET_FILE_DESTINATION_PATH);
			throw new IncorrectInputException(String.format(Constants.FEEDBACK_INVALID_PATH, path));
		}
	}

	public void setDefaultCustomCss(URL path) {
		try {
			storageController.generateCss(path);
		} catch (IOException e) {
			e.printStackTrace();
			logger.log(Level.SEVERE, Constants.ERROR_FAIL_TO_GENERATE_CSS);
		}
	}

	public String getCssPath() {
		return storageController.getCssPath();
	}

	/**
	 * Get the TaskManager object
	 * 
	 * @return TaskManager
	 */
	public TaskManager getTaskManager() {
		return taskManager;
	}

	/**
	 * Get Storage object
	 * 
	 * @return Storage
	 */
	public StorageController getStorage() {
		return storageController;
	}

	/**
	 * Get CategoryManager object
	 * 
	 * @return CategoryManager
	 */
	public CategoryManager getCategoryManager() {
		return categoryManager;
	}

	public HistoryManager getHistoryManager() {
		return historyManager;
	}
}
```
###### src\dooyit\logic\api\TaskManager.java
``` java
package dooyit.logic.api;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;

import dooyit.common.datatype.Category;
import dooyit.common.datatype.DateTime;
import dooyit.common.datatype.DateTime.Day;
import dooyit.common.datatype.DateTime.Month;
import dooyit.common.datatype.DeadlineTask;
import dooyit.common.datatype.EventTask;
import dooyit.common.datatype.FloatingTask;
import dooyit.common.datatype.Task;
import dooyit.common.datatype.TaskGroup;
import dooyit.common.datatype.Task.TaskType;
import dooyit.common.utils.TaskDateComparator;
import dooyit.common.utils.TaskUniqueIdComparator;
import dooyit.logic.Constants;

/**
 * The task manager is class that manages all the task and provides various
 * functionalities: create floating task, create deadline task, create event
 * task, remove task, find task, check if task manager contains the task, mark
 * task, delete task, edit task, set task display id, grouping of task with
 * filtering and sorting, search for tasks by keyword, day and month
 * 
 * @author limtaeu
 *
 */
public class TaskManager {
	enum SearchType {
		NAME, DATE, DAY, MONTH
	}

	private static final int TASKGROUP_COUNT_LIMIT = 30;
	private ArrayList<Task> tasks;
	private SearchType searchType;
	private String searchKey;
	private DateTime searchDateTime;
	private Day searchDay;
	private Month searchMonth;

	public TaskManager() {
		tasks = new ArrayList<Task>();
	}

	/**
	 * creates a new floating task, task is not completed by default
	 * 
	 * @param data
	 *            name of the task
	 * @return the added floating task
	 */
	public Task addFloatingTask(String data) {
		return addFloatingTask(data, false);
	}

	/**
	 * creates a new deadline task, task is not completed by default
	 * 
	 * @param data
	 *            name of the task
	 * @param dateTime
	 *            deadline of the task
	 * @return the added deadlineTask
	 */
	public Task addDeadlineTask(String data, DateTime dateTime) {
		return addDeadlineTask(data, dateTime, false);
	}

	/**
	 * Creates a new event task, taks is not completed by default
	 * 
	 * @param data
	 *            name of the task
	 * @param start
	 *            start time of the task
	 * @param end
	 *            end time of the task
	 * @return the added event task
	 */
	public Task addEventTask(String data, DateTime start, DateTime end) {
		return addEventTask(data, start, end, false);
	}

	/**
	 * creates a new floating task
	 * 
	 * @param data
	 *            name of the task
	 * @param isCompleted
	 *            wheather the task is completed
	 * @return the added floating task
	 */
	public Task addFloatingTask(String data, boolean isCompleted) {
		FloatingTask floatingTask = new FloatingTask(data);
		if (isCompleted) {
			floatingTask.mark();
		}

		tasks.add(floatingTask);

		return floatingTask;
	}

	/**
	 * creates a new deadline task
	 * 
	 * @param data
	 *            name of the task
	 * @param isCompleted
	 *            wheather the task is completed
	 * @param dateTime
	 *            deadline of the task
	 * @return the added deadlineTask
	 */
	public Task addDeadlineTask(String data, DateTime dateTime, boolean isCompleted) {
		DeadlineTask deadlineTask = new DeadlineTask(data, dateTime);
		if (isCompleted) {
			deadlineTask.mark();
		}

		tasks.add(deadlineTask);
		return deadlineTask;
	}

	/**
	 * Creates a new event task, taks is not completed by default
	 * 
	 * @param data
	 *            name of the task
	 * @param isCompleted
	 *            wheather the task is completed
	 * @param start
	 *            start time of the task
	 * @param end
	 *            end time of the task
	 * @return the added event task
	 */
	public Task addEventTask(String data, DateTime start, DateTime end, boolean isCompleted) {
		EventTask eventTask = new EventTask(data, start, end);

		if (isCompleted) {
			eventTask.mark();
		}

		tasks.add(eventTask);
		return eventTask;
	}

	/**
	 * add a task into the task manager
	 * 
	 * @param task
	 */
	public void add(Task task) {
		tasks.add(task);
	}

	/**
	 * add all the task from tasks into the task manager
	 * 
	 * @param tasks
	 *            ArrayList containing the tasks to be added into the task
	 *            manager
	 */
	public void load(ArrayList<Task> tasks) {
		this.tasks.addAll(tasks);
	}

	/**
	 * Remove the task with the specified id
	 * 
	 * @param id
	 *            The ID of the task to be removed
	 * 
	 * @return the Task that has been removed
	 */
	public Task remove(int id) {
		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).getDisplayId() == id) {
				return tasks.remove(i);
			}
		}
		return null;
	}

	/**
	 * Remove the task
	 * 
	 * @param task
	 *            The Task to be removed
	 * @return true if successful
	 */
	public boolean remove(Task task) {
		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).equals(task)) {
				tasks.remove(i);
				return true;
			}
		}
		return false;
	}

	/**
	 * Mark a task with the specified id
	 * 
	 * @param id
	 *            the ID of the task to be marked
	 * @return false if task is already marked
	 */
	public boolean markTask(int id) {
		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).getDisplayId() == id) {
				if (tasks.get(i).isCompleted()) {
					return false;
				} else {
					tasks.get(i).mark();
					return true;
				}
			}
		}
		// tell user if task is already marked.
		return false;
	}

	/**
	 * Mark a task with the specified task
	 * 
	 * @param id
	 *            the ID of the task to be marked
	 * @return false if task is already marked
	 */
	public boolean markTask(Task task) {
		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).equals(task)) {
				if (tasks.get(i).isCompleted()) {
					return false;
				} else {
					tasks.get(i).mark();
					return true;
				}
			}
		}
		return false;
	}

	/**
	 * unmark a task with the specified id
	 * 
	 * @param id
	 *            the ID of the task to be marked
	 * @return false if task is already unmarked
	 */
	public boolean unmarkTask(int id) {
		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).getDisplayId() == id) {
				if (tasks.get(i).isCompleted()) {
					tasks.get(i).unMark();
					return true;
				} else {
					return false;
				}
			}
		}
		return false;
	}

	/**
	 * unmark a task with the specified task
	 * 
	 * @param id
	 *            the ID of the task to be marked
	 */
	public void unmarkTask(Task task) {
		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).equals(task)) {
				tasks.get(i).unMark();
			}
		}
	}

	/**
	 * check if the task manager contains the task with the specified id
	 * 
	 * @param id
	 *            the ID of the task to be checked
	 * @return true if the task manager contains the task with the specified id
	 */
	public boolean contains(int id) {
		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).getDisplayId() == id) {
				return true;
			}
		}
		return false;
	}

	/**
	 * check if the task manager contains the task
	 * 
	 * @param task
	 *            the task to be checked
	 * @return true if the task manager contains the task
	 */
	public boolean contains(Task task) {
		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).equals(task)) {
				return true;
			}
		}
		return false;
	}

	/**
	 * find the task based on the given ID
	 * 
	 * @param id
	 *            the ID of the task
	 * @return the task with the id, null if task with ID is not found
	 */
	public Task find(int id) {
		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).getDisplayId() == id) {
				return tasks.get(i);
			}
		}
		return null;
	}

	/**
	 * find the task based on the given task
	 * 
	 * @param task
	 *            the task
	 * @return the task, null if task with ID is not found
	 */
	public Task find(Task task) {
		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).equals(task)) {
				return tasks.get(i);
			}
		}
		return null;
	}

	/**
	 * 
	 * @return number of tasks in the task manager
	 */
	public int size() {
		return tasks.size();
	}

	/**
	 * removes the task that has the category
	 * 
	 * @param category
	 * @return the tasks that are removed
	 */
	public ArrayList<Task> removeTasksWithCategory(Category category) {
		ArrayList<Task> taskWithCat = new ArrayList<Task>();

		Iterator<Task> itr = tasks.iterator();
		while (itr.hasNext()) {
			Task task = itr.next();

			if (task.hasCategory() && task.getCategory().equals(category)) {
				itr.remove();
				taskWithCat.add(task);
			}
		}

		return taskWithCat;
	}

	/**
	 * clear all the task from the task manager
	 * 
	 * @return
	 */
	public ArrayList<Task> clear() {
		ArrayList<Task> clearedTasks = new ArrayList<Task>(tasks);
		tasks.clear();
		return clearedTasks;
	}

	/**
	 * 
	 * @return the most recently added task into the task manager
	 */
	public Task getMostRecentTask() {
		int latestId = Integer.MIN_VALUE;
		Task latestTask = null;

		for (Task task : tasks) {
			if (task.getUniqueId() > latestId) {
				latestId = task.getUniqueId();
				latestTask = task;
			}
		}
		return latestTask;
	}

	/**
	 * change the name of a task
	 * 
	 * @param taskId
	 *            ID of a task to be changed
	 * @param newName
	 *            new name of the task
	 * @return the changed task, null if cannot find the task with the id
	 */
	public Task changeTaskName(int taskId, String newName) {
		if (!contains(taskId)) {
			return null;
		}

		Task removedTask = remove(taskId);
		Task newTask = removedTask.copy();
		newTask.changeName(newName);
		add(newTask);
		return newTask;
	}

	/**
	 * change a task into a floating task
	 * 
	 * @param taskId
	 * @return the changed task, null if cannot find the task with the id
	 */
	public Task changeToFloatingTask(int taskId) {
		if (!contains(taskId)) {
			return null;
		}

		Task removedTask = remove(taskId);
		Task newTask = new FloatingTask(removedTask);
		newTask.setCategory(removedTask.getCategory());
		add(newTask);

		return newTask;
	}

	/**
	 * change a task into a deadline task
	 * 
	 * @param taskId
	 * @param dateTimeDeadline
	 * @return the changed task, null if cannot find the task with the id
	 */
	public Task changeTaskToDeadline(int taskId, DateTime dateTimeDeadline) {
		if (!contains(taskId)) {
			return null;
		}

		Task removedTask = remove(taskId);
		Task newTask = new DeadlineTask(removedTask, dateTimeDeadline);
		newTask.setCategory(removedTask.getCategory());
		add(newTask);

		return newTask;
	}

	/**
	 * change a task into a event task
	 * 
	 * @param taskId
	 * @param dateTimeStart
	 * @param dateTimeEnd
	 * @return the changed task, null if cannot find the task with the id
	 */
	public Task changeTaskToEvent(int taskId, DateTime dateTimeStart, DateTime dateTimeEnd) {
		if (!contains(taskId)) {
			return null;
		}

		Task removedTask = remove(taskId);
		Task newTask = new EventTask(removedTask, dateTimeStart, dateTimeEnd);
		newTask.setCategory(removedTask.getCategory());
		add(newTask);

		return newTask;
	}

	/**
	 * checks if the task is a floating task
	 * 
	 * @param task
	 * @return true if the task is a floating task
	 */
	public boolean isFloatingTask(Task task) {
		return (task instanceof FloatingTask);
	}

	/**
	 * checks if the task has a deadline or event by today
	 * 
	 * @param task
	 * @return true if the task has a deadline or event by today
	 */
	public boolean isTodayTask(Task task) {
		DateTime currDate = new DateTime();
		return task.isSameDate(currDate);
	}

	/**
	 * checks if the task has a deadline or event within the next 7 days
	 * 
	 * @param task
	 * @return true if the task has a deadline or event within the next 7 days
	 */
	public boolean isNext7DaysTask(Task task) {
		DateTime currDate = new DateTime();

		for (int i = 0; i < Constants.DAYS_PER_WEEK; i++) {
			if (task.isSameDate(currDate)) {
				return true;
			}
			currDate.increaseByOneDay();
		}

		return false;
	}

	/**
	 * checks if the task overlaps with other event task
	 * 
	 * @param inTask
	 * @return true if the task overlaps with other event task
	 */
	public boolean hasOverlapWithOverEventTask(Task inTask) {
		for (Task task : tasks) {
			if (!task.equals(inTask) && task.hasOverlap(inTask)) {
				return true;
			}
		}
		return false;
	}

	/**
	 * turn of on event task's multiple day string, to disable the ability of
	 * event task to display multiple day
	 */
	public void onAllEventTasksMultiDayString() {
		for (Task task : tasks) {
			if (task.getTaskType() == TaskType.EVENT) {
				EventTask eventTask = (EventTask) task;
				eventTask.onMultiDay();
			}
		}
	}

	/**
	 * turn of all event task's multiple day string, to enable the ability of
	 * event task to display multiple day
	 */
	public void offAllEventTasksMultiDayString() {
		for (Task task : tasks) {
			if (task.getTaskType() == TaskType.EVENT) {
				EventTask eventTask = (EventTask) task;
				eventTask.offMultiDay();
			}
		}
	}

	public int getNoOfIncompleteEventAndDeadlineTask() {
		int size = 0;

		size += getIncompleteDeadlineTasks().size();
		size += getIncompleteEventTasksSize();

		return size;
	}

	public ArrayList<Task> getAllTasks() {
		return tasks;
	}

	public ArrayList<Task> getIncompleteTasks() {
		ArrayList<Task> allIncompleteTask = new ArrayList<Task>();

		for (Task task : tasks) {
			if (!task.isCompleted()) {
				allIncompleteTask.add(task);
			}
		}
		return allIncompleteTask;
	}

	public ArrayList<Task> getIncompleteTasks(DateTime overdueTime) {
		ArrayList<Task> allIncompleteTask = new ArrayList<Task>();

		for (Task task : tasks) {
			if (!task.isCompleted() && !task.isOverDue(overdueTime)) {
				allIncompleteTask.add(task);
			}
		}
		return allIncompleteTask;
	}

	public ArrayList<Task> getCompletedTasks() {
		ArrayList<Task> allCompletedTask = new ArrayList<Task>();

		for (Task task : tasks) {
			if (task.isCompleted()) {
				allCompletedTask.add(task);
			}
		}
		return allCompletedTask;
	}

	public ArrayList<Task> getFloatingTasks() {
		ArrayList<Task> floatingTasks = new ArrayList<Task>();

		for (Task task : tasks) {
			if (task.getTaskType() == TaskType.FLOATING) {
				floatingTasks.add(task);
			}
		}
		return floatingTasks;
	}

	public ArrayList<Task> getIncompleteFloatingTasks() {
		ArrayList<Task> floatingTasks = new ArrayList<Task>();

		for (Task task : tasks) {
			if (task.getTaskType() == TaskType.FLOATING && !task.isCompleted()) {
				floatingTasks.add(task);
			}
		}
		return floatingTasks;
	}

	public ArrayList<Task> getDeadlineTasks() {

		ArrayList<Task> deadlineTasks = new ArrayList<Task>();

		for (Task task : tasks) {
			if (task.getTaskType() == TaskType.DEADLINE) {
				deadlineTasks.add(task);
			}
		}
		return deadlineTasks;
	}

	public ArrayList<Task> getDeadlineTasks(DateTime dateTime) {

		ArrayList<Task> deadlineTasks = new ArrayList<Task>();

		for (Task task : tasks) {
			if (task.getTaskType() == TaskType.DEADLINE) {
				if (task.isSameDate(dateTime)) {
					deadlineTasks.add(task);
				}
			}
		}
		return deadlineTasks;
	}

	public ArrayList<Task> getIncompleteDeadlineTasks() {

		ArrayList<Task> deadlineTasks = new ArrayList<Task>();

		for (Task task : tasks) {
			if (task.getTaskType() == TaskType.DEADLINE) {
				if (!task.isCompleted()) {
					deadlineTasks.add(task);
				}
			}
		}
		return deadlineTasks;
	}

	public ArrayList<Task> getIncompleteDeadlineTasks(DateTime dateTime) {

		ArrayList<Task> deadlineTasks = new ArrayList<Task>();

		for (Task task : tasks) {
			if (task.getTaskType() == TaskType.DEADLINE) {
				if (task.isSameDate(dateTime) && !task.isCompleted()) {
					deadlineTasks.add(task);
				}
			}
		}
		return deadlineTasks;
	}

	public ArrayList<Task> getEventTasks() {

		ArrayList<Task> eventTasks = new ArrayList<Task>();

		for (Task task : tasks) {
			if (task.getTaskType() == TaskType.EVENT) {
				eventTasks.add(task);
			}
		}
		return eventTasks;
	}

	public ArrayList<Task> getEventTasks(DateTime dateTime) {

		ArrayList<Task> eventTasks = new ArrayList<Task>();

		for (Task task : tasks) {
			if (task.getTaskType() == TaskType.EVENT) {
				if (task.isSameDate(dateTime)) {
					eventTasks.add(task);
				}
			}
		}
		return eventTasks;
	}

	public int getIncompleteEventTasksSize() {

		int size = 0;

		for (Task task : tasks) {
			if (task.getTaskType() == TaskType.EVENT) {
				EventTask eventTask = (EventTask) task;
				if (!eventTask.isCompleted()) {
					size += eventTask.size();
				}
			}
		}
		return size;
	}

	public ArrayList<Task> getIncompleteEventTasks() {

		ArrayList<Task> eventTasks = new ArrayList<Task>();

		for (Task task : tasks) {
			if (task.getTaskType() == TaskType.EVENT) {
				if (!task.isCompleted()) {
					eventTasks.add(task);
				}
			}
		}
		return eventTasks;
	}

	public ArrayList<Task> getIncompleteEventTasks(DateTime dateTime) {

		ArrayList<Task> eventTasks = new ArrayList<Task>();

		for (Task task : tasks) {
			if (task.getTaskType() == TaskType.EVENT) {
				if (task.isSameDate(dateTime) && !task.isCompleted()) {
					eventTasks.add(task);
				}
			}
		}
		return eventTasks;
	}

	/**
	 * get all overdue tasks based on the time input
	 * 
	 * @param dateTime
	 *            current time
	 * @return arraylist of overdue task
	 */
	public ArrayList<Task> getOverdueTasks(DateTime dateTime) {
		ArrayList<Task> overdueTasks = new ArrayList<Task>();

		for (Task task : tasks) {
			if (task.isOverDue(dateTime)) {
				overdueTasks.add(task);
			}
		}

		return overdueTasks;
	}

	/**
	 * get the number of overdue task
	 * 
	 * @param dateTime
	 *            current time
	 * @return
	 */
	public int getOverdueTasksSize(DateTime dateTime) {
		int size = 0;

		for (Task task : tasks) {

			if (task.isOverDue(dateTime)) {
				if (task.getTaskType() == TaskType.EVENT) {
					EventTask eventTask = (EventTask) task;
					size += eventTask.size();
				} else {
					size++;
				}
			}
		}

		return size;
	}

	public ArrayList<Task> getTasksWithCategory(Category category) {
		ArrayList<Task> tasksWithCat = new ArrayList<Task>();

		for (Task task : tasks) {
			if (task.hasCategory() && task.getCategory().equals(category)) {
				tasksWithCat.add(task);
			}
		}

		return tasksWithCat;
	}

	public ArrayList<Task> getIncompleteTasksWithCategory(Category category) {
		ArrayList<Task> tasksWithCat = new ArrayList<Task>();

		for (Task task : tasks) {
			if (task.hasCategory() && task.getCategory().equals(category) && !task.isCompleted()) {
				tasksWithCat.add(task);
			}
		}

		return tasksWithCat;
	}

	/**
	 * get arraylist of taskgroup that contains all the task
	 * 
	 * @return arraylist of taskgroup
	 */
	public ArrayList<TaskGroup> getTaskGroupsAll() {
		onAllEventTasksMultiDayString();
		ArrayList<TaskGroup> taskGroups = new ArrayList<TaskGroup>();
		TaskGroup taskGroup;
		DateTime currDate = new DateTime();

		int numOverdueTask = getOverdueTasksSize(currDate);
		int totalSize = getNoOfIncompleteEventAndDeadlineTask() - numOverdueTask;

		addOverDueTaskGroup(taskGroups, currDate);

		taskGroup = createFloatTaskGroup();
		if (!taskGroup.isEmpty()) {
			taskGroups.add(taskGroup);
		}

		taskGroup = createDayTaskGroup(Constants.TITLE_TODAY, currDate);
		if (!taskGroup.isEmpty()) {
			taskGroups.add(taskGroup);
			totalSize -= taskGroup.size();
		}

		currDate.increaseByOneDay();
		taskGroup = createDayTaskGroup(Constants.TITLE_TOMORROW, currDate);
		if (!taskGroup.isEmpty()) {
			taskGroups.add(taskGroup);
			totalSize -= taskGroup.size();
		}

		currDate.increaseByOneDay();
		int taskGroupCount = 0;
		while (totalSize > 0 && taskGroupCount < TASKGROUP_COUNT_LIMIT) {
			taskGroup = createDayTaskGroup(currDate.getDayStr(), currDate);
			if (!taskGroup.isEmpty()) {
				taskGroups.add(taskGroup);
				totalSize -= taskGroup.size();
				taskGroupCount++;
			}
			currDate.increaseByOneDay();
		}

		if (taskGroups.isEmpty()) {
			taskGroups.add(createEmptyTaskGroup(Constants.TITLE_ALL));
		}

		resetTasksDisplayId(taskGroups);
		return taskGroups;

	}

	/**
	 * get arraylist of taskgroup that contains deadline and event task that are
	 * within next 7 days
	 * 
	 * @return arraylist of taskgroup
	 */
	public ArrayList<TaskGroup> getTaskGroupsNext7Days() {
		onAllEventTasksMultiDayString();
		DateTime currDate = new DateTime();
		ArrayList<TaskGroup> taskGroups = new ArrayList<TaskGroup>();
		TaskGroup taskGroup;

		addOverDueTaskGroup(taskGroups, currDate);

		String title;
		for (int i = 1; i <= Constants.DAYS_PER_WEEK; i++) {
			if (i == Constants.FIRST_DAY) {
				title = Constants.TITLE_TODAY;
			} else if (i == Constants.SECOND_DAY) {
				title = Constants.TITLE_TOMORROW;
			} else {
				title = currDate.getDayStr();
			}

			taskGroup = createDayTaskGroup(title, currDate);
			taskGroups.add(taskGroup);
			currDate.increaseByOneDay();
		}

		resetTasksDisplayId(taskGroups);
		return taskGroups;
	}

	/**
	 * get arraylist of taskgroup
	 * 
	 * @return arraylist of taskgroup
	 */
	public ArrayList<TaskGroup> getTaskGroupsFloating() {
		ArrayList<TaskGroup> taskGroups = new ArrayList<TaskGroup>();

		TaskGroup taskGroup = createFloatTaskGroup();
		taskGroups.add(taskGroup);

		resetTasksDisplayId(taskGroups);
		return taskGroups;
	}

	/**
	 * get arraylist of taskgroup that contains task that have deadline or event
	 * by today
	 * 
	 * @return arraylist of taskgroup
	 */
	public ArrayList<TaskGroup> getTaskGroupsToday() {
		onAllEventTasksMultiDayString();
		ArrayList<TaskGroup> taskGroups = new ArrayList<TaskGroup>();
		TaskGroup taskGroup;
		DateTime currDate = new DateTime();

		addOverDueTaskGroup(taskGroups, currDate);

		taskGroup = createDayTaskGroup(Constants.TITLE_TODAY, currDate);
		taskGroups.add(taskGroup);

		resetTasksDisplayId(taskGroups);
		return taskGroups;
	}

	/**
	 * get arraylist of task group that contains task that are completed
	 * 
	 * @return arraylist of taskgroup
	 */
	public ArrayList<TaskGroup> getTaskGroupsCompleted() {
		offAllEventTasksMultiDayString();
		ArrayList<TaskGroup> taskGroups = new ArrayList<TaskGroup>();

		TaskGroup taskGroup = createCompletedTaskGroup();
		taskGroups.add(taskGroup);

		resetTasksDisplayId(taskGroups);
		return taskGroups;
	}

	/**
	 * get arraylist of taskgroup that contains only task with a specific
	 * category
	 * 
	 * @param category
	 * @return arraylist of taskgroup
	 */
	public ArrayList<TaskGroup> getTaskGroupsCategory(Category category) {
		ArrayList<TaskGroup> taskGroups = getTaskGroupsAll();
		filterTaskGroupsByCategory(taskGroups, category);

		if (taskGroups.isEmpty()) {
			taskGroups.add(createEmptyTaskGroup(category.getName()));
		}

		resetTasksDisplayId(taskGroups);
		return taskGroups;
	}

	/**
	 * get arraylist of taskgroup with the searchKeyword that has been set by
	 * filtering unwanted task
	 * 
	 * @return arraylist of taskgroup
	 */
	public ArrayList<TaskGroup> getTaskGroupSearched() {
		ArrayList<TaskGroup> taskGroups = getTaskGroupsAll();

		switch (searchType) {
		case NAME:
			filterTaskGroupsByName(taskGroups, searchKey);
			break;

		case DAY:
			filterTaskGroupsByDay(taskGroups, searchKey, searchDay);
			break;

		case MONTH:
			filterTaskGroupsByMonth(taskGroups, searchKey, searchMonth);
			break;

		case DATE:
			filterTaskGroupsByDate(taskGroups, searchDateTime);
			break;

		}

		if (taskGroups.isEmpty()) {
			taskGroups.add(createEmptyTaskGroup(Constants.TITLE_SEARCH_LIST));
		}

		resetTasksDisplayId(taskGroups);
		return taskGroups;
	}

	private void addOverDueTaskGroup(ArrayList<TaskGroup> taskGroups, DateTime currDate) {
		ArrayList<Task> overdueTasks = getOverdueTasks(currDate);
		if (!overdueTasks.isEmpty()) {
			TaskGroup taskGroup = new TaskGroup(Constants.TITLE_OVERDUE);
			taskGroup.addTasks(getOverdueTasks(currDate));
			sortTasks(taskGroup.getTasks());
			taskGroups.add(taskGroup);
		}
	}

	/**
	 * create an empty taskgroup that can be used as title
	 * 
	 * @param title
	 * @return TaskGroup
	 */
	private TaskGroup createEmptyTaskGroup(String title) {
		TaskGroup taskGroup = new TaskGroup(title);
		return taskGroup;
	}

	/**
	 * create a task group with only floating task n sort the tasks
	 * 
	 * @return TaskGroup
	 */
	private TaskGroup createFloatTaskGroup() {
		TaskGroup taskGroup;
		taskGroup = new TaskGroup(Constants.TITLE_FLOAT);
		taskGroup.addTasks(getIncompleteFloatingTasks());
		sortTasks(taskGroup.getTasks());
		return taskGroup;
	}

	/**
	 * create a task group with only a particular day's task n sort the tasks
	 * 
	 * @param title
	 * @param currDate
	 * @return TaskGroup
	 */
	private TaskGroup createDayTaskGroup(String title, DateTime currDate) {
		currDate = new DateTime(currDate);

		TaskGroup taskGroup;
		taskGroup = new TaskGroup(title, new DateTime(currDate));
		taskGroup.addTasks(getIncompleteDeadlineTasks(currDate));
		taskGroup.addTasks(getIncompleteEventTasks(currDate));
		sortTasks(taskGroup.getTasks());
		return taskGroup;
	}

	/**
	 * create a task group with only completed task n sort the tasks
	 * 
	 * @return TaskGroup
	 */
	public TaskGroup createCompletedTaskGroup() {
		TaskGroup taskGroup;
		taskGroup = new TaskGroup(Constants.TITLE_COMPLETED);
		taskGroup.addTasks(getCompletedTasks());
		sortTasks(taskGroup.getTasks());
		return taskGroup;
	}

	/**
	 * filter the task group by category by removing all task that doesnt have
	 * the category.
	 * 
	 * @param taskGroups
	 * @param category
	 */
	public void filterTaskGroupsByCategory(ArrayList<TaskGroup> taskGroups, Category category) {
		Iterator<TaskGroup> taskGroupsItr = taskGroups.iterator();
		while (taskGroupsItr.hasNext()) {
			TaskGroup taskGroup = taskGroupsItr.next();

			filterTasksByCategory(taskGroup.getTasks(), category);

			if (taskGroup.size() == 0) {
				taskGroupsItr.remove();
			}
		}
	}

	/**
	 * filter the task groups by keyword by removing all task that doesnt match
	 * the keyword
	 * 
	 * @param taskGroups
	 * @param searchKey
	 */
	public void filterTaskGroupsByName(ArrayList<TaskGroup> taskGroups, String searchKey) {
		Iterator<TaskGroup> taskGroupsItr = taskGroups.iterator();
		while (taskGroupsItr.hasNext()) {
			TaskGroup taskGroup = taskGroupsItr.next();

			filterTasksByName(taskGroup.getTasks(), searchKey);

			if (taskGroup.size() == 0) {
				taskGroupsItr.remove();
			}
		}
	}

	/**
	 * filter the task groups by date by removing all task that doesnt match the
	 * datetime
	 * 
	 * @param taskGroups
	 * @param dateTime
	 */
	public void filterTaskGroupsByDate(ArrayList<TaskGroup> taskGroups, DateTime dateTime) {
		Iterator<TaskGroup> taskGroupsItr = taskGroups.iterator();
		while (taskGroupsItr.hasNext()) {
			TaskGroup taskGroup = taskGroupsItr.next();

			filterTasksByDate(taskGroup.getTasks(), dateTime);

			if (taskGroup.size() == 0) {
				taskGroupsItr.remove();
			}
		}
	}

	/**
	 * filter the task groups by day by removing all task that doesnt match the
	 * day
	 * 
	 * @param taskGroups
	 * @param searchKey
	 * @param day
	 */
	public void filterTaskGroupsByDay(ArrayList<TaskGroup> taskGroups, String searchKey, Day day) {
		Iterator<TaskGroup> taskGroupsItr = taskGroups.iterator();
		while (taskGroupsItr.hasNext()) {
			TaskGroup taskGroup = taskGroupsItr.next();

			filterTasksByDay(taskGroup.getTasks(), searchKey, day);

			if (taskGroup.size() == 0) {
				taskGroupsItr.remove();
			}
		}
	}

	/**
	 * filter the task groups by month by removing all task that doesnt match
	 * the month
	 * 
	 * @param taskGroups
	 * @param searchKey
	 * @param month
	 */
	public void filterTaskGroupsByMonth(ArrayList<TaskGroup> taskGroups, String searchKey, Month month) {
		Iterator<TaskGroup> taskGroupsItr = taskGroups.iterator();
		while (taskGroupsItr.hasNext()) {
			TaskGroup taskGroup = taskGroupsItr.next();

			filterTasksByMonth(taskGroup.getTasks(), searchKey, month);

			if (taskGroup.size() == 0) {
				taskGroupsItr.remove();
			}
		}
	}

	/**
	 * filter tasks by keyword
	 * 
	 * @param inTasks
	 * @param searchKey
	 */
	public void filterTasksByName(ArrayList<Task> inTasks, String searchKey) {
		searchKey = searchKey.toLowerCase();
		Iterator<Task> taskItr = inTasks.iterator();

		while (taskItr.hasNext()) {
			Task task = taskItr.next();

			String taskName = task.getName();
			taskName = taskName.toLowerCase();

			if (!taskName.contains(searchKey)) {
				taskItr.remove();
			}
		}
	}

	/**
	 * filter task by dateTime
	 * 
	 * @param inTasks
	 * @param dateTime
	 */
	public void filterTasksByDate(ArrayList<Task> inTasks, DateTime dateTime) {
		Iterator<Task> taskItr = inTasks.iterator();

		while (taskItr.hasNext()) {
			Task task = taskItr.next();

			if (!task.isSameDate(dateTime)) {
				taskItr.remove();
			}
		}
	}

	/**
	 * filter tasks by month and the month as keyword
	 * 
	 * @param inTasks
	 * @param searchKey
	 * @param month
	 */
	public void filterTasksByMonth(ArrayList<Task> inTasks, String searchKey, Month month) {
		searchKey = searchKey.toLowerCase();
		Iterator<Task> taskItr = inTasks.iterator();

		while (taskItr.hasNext()) {
			Task task = taskItr.next();

			String taskName = task.getName();
			taskName = taskName.toLowerCase();

			if (!taskName.contains(searchKey) && !task.isMonth(month)) {
				taskItr.remove();
			}
		}
	}

	/**
	 * filter tasks by day and the day as keyword
	 * 
	 * @param inTasks
	 * @param searchKey
	 * @param day
	 */
	public void filterTasksByDay(ArrayList<Task> inTasks, String searchKey, Day day) {
		searchKey = searchKey.toLowerCase();
		Iterator<Task> taskItr = inTasks.iterator();

		while (taskItr.hasNext()) {
			Task task = taskItr.next();

			String taskName = task.getName();
			taskName = taskName.toLowerCase();

			if (!taskName.contains(searchKey) && !task.isDay(day)) {
				taskItr.remove();
			}
		}
	}

	/**
	 * filter tasks by category
	 * 
	 * @param inTasks
	 * @param category
	 */
	public void filterTasksByCategory(ArrayList<Task> inTasks, Category category) {
		Iterator<Task> taskItr = inTasks.iterator();

		while (taskItr.hasNext()) {
			Task task = taskItr.next();

			if (!task.hasCategory() || !task.getCategory().equals(category)) {
				taskItr.remove();
			}
		}
	}

	/**
	 * sort tasks by their unique id first to maintain the order when a task is
	 * edited. Then sort by date.
	 * 
	 * @param inTasks
	 */
	public void sortTasks(ArrayList<Task> inTasks) {
		sortTasksByUniqueId(inTasks);
		sortTasksByDate(inTasks);
	}

	public void sortTasksByDate(ArrayList<Task> inTasks) {
		TaskDateComparator dateComparator = new TaskDateComparator();
		Collections.sort(inTasks, dateComparator);
	}

	public void sortTasksByUniqueId(ArrayList<Task> inTasks) {
		TaskUniqueIdComparator uniqueIdComparator = new TaskUniqueIdComparator();
		Collections.sort(inTasks, uniqueIdComparator);
	}

	/**
	 * reset all the task's display id by clearing the old IDs and giving them a
	 * new id
	 * 
	 * @param taskGroups
	 */
	public void resetTasksDisplayId(ArrayList<TaskGroup> taskGroups) {
		clearOldId();
		assignNewDisplayId(taskGroups);
	}

	/**
	 * assign new diplay id for each task, setting display id of a multi event
	 * task that has been set will fail
	 * 
	 * @param taskGroups
	 */
	public void assignNewDisplayId(ArrayList<TaskGroup> taskGroups) {
		int taskId = 1;

		for (TaskGroup taskGroup : taskGroups) {
			ArrayList<Task> tasks = taskGroup.getTasks();
			for (Task task : tasks) {
				boolean isSuccess = task.setDisplayId(taskId);

				if (isSuccess) {
					taskId++;
				}
			}
		}
	}

	/**
	 * reset all task's display id
	 */
	public void clearOldId() {
		for (Task task : tasks) {
			task.resetDisplayId();
		}
	}

	/**
	 * set the search key to enable searching of keywords from tasks
	 * 
	 * @param searchKey
	 *            the keyword
	 */
	public void setSearchKey(String searchKey) {
		searchType = SearchType.NAME;
		this.searchKey = searchKey;
	}

	/**
	 * set the search to enable searching of particular day from tasks, and also
	 * search for the day as keyword
	 * 
	 * @param searchKey
	 *            the key word
	 * @param day
	 */
	public void setSearchKey(String searchKey, Day day) {
		searchType = SearchType.DAY;
		this.searchKey = searchKey;
		this.searchDay = day;
	}

	/**
	 * set the search key to enable searching of particular month from tasks,
	 * and also search for the month as keyword
	 * 
	 * @param searchKey
	 * @param month
	 */
	public void setSearchKey(String searchKey, Month month) {
		searchType = SearchType.MONTH;
		this.searchKey = searchKey;
		this.searchMonth = month;
	}

	/**
	 * set the search key to enable searching of a particular date from tasks
	 * 
	 * @param dateTime
	 */
	public void setSearchKey(DateTime dateTime) {
		searchType = SearchType.DATE;
		this.searchDateTime = dateTime;
	}

	public void display() {
		System.out.println();
		System.out.println(Constants.TITLE_TASK_LIST);

		for (Task task : tasks) {
			System.out.println(task.getDisplayId() + Constants.SYMBOL_COLON + task);
		}

		System.out.println();
	}
}
```
###### src\dooyit\logic\commands\AddCategoryCommand.java
``` java
package dooyit.logic.commands;

import dooyit.common.datatype.Category;
import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.Constants;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class AddCategoryCommand implements ReversibleCommand {

	private String categoryName;
	private String colourString;
	private Category addedCategory;
	private boolean hasError = false;

	public AddCategoryCommand(String categoryName) {
		this.categoryName = categoryName;
	}

	public AddCategoryCommand(String categoryName, String colorString) {
		this.categoryName = categoryName;
		this.colourString = colorString;
	}

	private boolean addCategoryWithColour() {
		return colourString != null;
	}

	public boolean hasError() {
		return hasError;
	}

	public void undo(LogicController logic) {
		logic.removeCategory(addedCategory);
	}

	public void redo(LogicController logic) {
		logic.addCategory(addedCategory);
	}

	public LogicAction execute(LogicController logic) throws IncorrectInputException {
		assert (logic != null);
		LogicAction logicAction;

		String feedbackMsgColor = Constants.EMPTY_STRING;

		// return error if category already exits
		if (logic.containsCategory(categoryName)) {
			logicAction = categoryAleadyExists();
			return logicAction;
		}

		if (addCategoryWithColour()) {
			if (isColourAvailable(logic, colourString)) {
				addCategoryWithColour(logic);
			} else {
				addCategoryWithoutColour(logic);
				feedbackMsgColor += String.format(Constants.FEEDBACK_INVALID_COLOUR_WITH_SUGGESTION, colourString);
			}
		} else {
			addCategoryWithoutColour(logic);
		}

		logicAction = categoryAdded(feedbackMsgColor);

		return logicAction;
	}

	public LogicAction categoryAdded(String feedbackMsgColor) {
		return new LogicAction(Action.ADD_CATEGORY, String.format(Constants.FEEDBACK_CATEGORY_ADDED, categoryName, feedbackMsgColor));
	}

	public LogicAction categoryAleadyExists() {
		LogicAction logicAction;
		logicAction = new LogicAction(Action.ERROR, String.format(Constants.FEEDBACK_FAIL_CATEGORY_EXISTS, categoryName));
		hasError = true;
		return logicAction;
	}

	public void addCategoryWithoutColour(LogicController logic) {
		addedCategory = logic.addCategory(categoryName);
	}

	public void addCategoryWithColour(LogicController logic) {
		addedCategory = logic.addCategory(categoryName, colourString);
	}

	public boolean isColourAvailable(LogicController logic, String colourString) {
		return logic.containsCustomColour(colourString);
	}

}
```
###### src\dooyit\logic\commands\AddTaskCommand.java
``` java
package dooyit.logic.commands;

import dooyit.common.datatype.DateTime;
import dooyit.common.datatype.Task;
import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.Constants;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class AddTaskCommand implements ReversibleCommand {

	private String taskName;
	private Task.TaskType taskType;
	private DateTime dateTimeDeadline;
	private DateTime dateTimeStart;
	private DateTime dateTimeEnd;
	private Task addedTask;
	private boolean hasError = false;

	public AddTaskCommand(String taskName) {
		this.taskName = taskName;
		taskType = Task.TaskType.FLOATING;
	}

	public AddTaskCommand(String data, DateTime deadline) {
		this.taskName = data;
		this.dateTimeDeadline = deadline;
		taskType = Task.TaskType.DEADLINE;
	}

	public AddTaskCommand(String data, DateTime start, DateTime end) {
		this.taskName = data;
		this.dateTimeStart = start;
		this.dateTimeEnd = end;
		taskType = Task.TaskType.EVENT;
	}

	public boolean hasError() {
		return hasError;
	}

	public void undo(LogicController logic) {
		logic.removeTask(addedTask);
	}

	public void redo(LogicController logic) {
		logic.addTask(addedTask);
	}

	public LogicAction execute(LogicController logic) throws IncorrectInputException {
		assert (logic != null);
		LogicAction logicAction = null;

		switch (taskType) {
		case FLOATING:
			addedTask = logic.addFloatingTask(taskName);
			break;

		case DEADLINE:
			addedTask = logic.addDeadlineTask(taskName, dateTimeDeadline);
			break;

		case EVENT:
			addedTask = logic.addEventTask(taskName, dateTimeStart, dateTimeEnd);
			break;
		}

		logicAction = getActionBasedOnAddedTask(logic, addedTask);
		return logicAction;
	}

	public LogicAction getActionBasedOnAddedTask(LogicController logic, Task addedTask) {
		LogicAction logicAction;

		String taskAddedMsg = Constants.FEEDBACK_TASK_ADDED;
		String feedbackMsg = taskAddedMsg;

		if (logic.hasOverlapWithOverEventTask(addedTask)) {
			String conflictMsg = Constants.FEEDBACK_CONFLICTING_EVENT;
			feedbackMsg = conflictMsg + taskAddedMsg;
		}

		if (logic.isFloatingTask(addedTask)) {
			logicAction = new LogicAction(Action.ADD_FLOATING_TASK, feedbackMsg);

		} else if (logic.isTodayTask(addedTask)) {
			logicAction = new LogicAction(Action.ADD_TODAY_TASK, feedbackMsg);

		} else if (logic.isNext7daysTask(addedTask)) {
			logicAction = new LogicAction(Action.ADD_NEXT7DAY_TASK, feedbackMsg);

		} else {
			logicAction = new LogicAction(Action.ADD_ALL_TASK, feedbackMsg);
		}

		return logicAction;
	}

}
```
###### src\dooyit\logic\commands\ChangeThemeCommand.java
``` java
package dooyit.logic.commands;

import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.Constants;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class ChangeThemeCommand implements Command {

	
	private String themeString;
	private boolean hasError = false;

	public ChangeThemeCommand(String themeString) {
		this.themeString = themeString;
	}

	public boolean hasError() {
		return hasError;
	}

	public LogicAction execute(LogicController logic) throws IncorrectInputException {
		LogicAction logicAction = null;

		String lowerThemeString = themeString.toLowerCase();

		switch (lowerThemeString) {
		case Constants.THEME_DEFAULT:
			logicAction = changeToDefaultTheme();
			break;

		case Constants.THEME_LIGHT:
			logicAction = changeToDefaultTheme();
			break;

		case Constants.THEME_DARK:
			logicAction = changeToDarkTheme();
			break;

		case Constants.THEME_AQUA:
			logicAction = changeToAquaTheme();
			break;

		case Constants.THEME_CUSTOM:
			logicAction = changeToCustomTheme();
			break;

		default:
			logicAction = showError();
		}

		return logicAction;
	}

	public LogicAction showError() {
		return new LogicAction(Action.ERROR, String.format(Constants.FEEDBACK_INVALID_THEME, themeString));
	}

	public LogicAction changeToCustomTheme() {
		return new LogicAction(Action.CHANGE_THEME_CUSTOM, String.format(Constants.FEEDBACK_SUCCESS_CHANGE_THEME, themeString));
	}

	public LogicAction changeToAquaTheme() {
		return new LogicAction(Action.CHANGE_THEME_AQUA, String.format(Constants.FEEDBACK_SUCCESS_CHANGE_THEME, themeString));
	}

	public LogicAction changeToDarkTheme() {
		return new LogicAction(Action.CHANGE_THEME_DARK, String.format(Constants.FEEDBACK_SUCCESS_CHANGE_THEME, themeString));
	}

	public LogicAction changeToDefaultTheme() {
		return new LogicAction(Action.CHANGE_THEME_DEFAULT, String.format(Constants.FEEDBACK_SUCCESS_CHANGE_THEME, themeString));
	}

}
```
###### src\dooyit\logic\commands\ClearTaskCommand.java
``` java
package dooyit.logic.commands;

import java.util.ArrayList;

import dooyit.common.datatype.Task;
import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.Constants;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class ClearTaskCommand implements ReversibleCommand {

	ArrayList<Task> clearedTasks;
	private boolean hasError = false;

	public ClearTaskCommand() {

	}

	public boolean hasError() {
		return hasError;
	}

	public void undo(LogicController logic) {
		logic.loadTasks(clearedTasks);
	}

	public void redo(LogicController logic) {
		clearedTasks = logic.clearTasks();
	}

	public LogicAction execute(LogicController logic) throws IncorrectInputException {
		assert (logic != null);
		LogicAction logicAction;

		clearedTasks = logic.clearTasks();

		logicAction = new LogicAction(Action.CLEAR_TASK, Constants.FEEDBACK_TASK_CLEARED);
		return logicAction;
	}

}
```
###### src\dooyit\logic\commands\Command.java
``` java
package dooyit.logic.commands;

import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public interface Command {

	public LogicAction execute(LogicController logic) throws IncorrectInputException;

	public boolean hasError();
}
```
###### src\dooyit\logic\commands\DeleteCategoryCommand.java
``` java
package dooyit.logic.commands;

import java.util.ArrayList;

import dooyit.common.datatype.Category;
import dooyit.common.datatype.Task;
import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.Constants;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class DeleteCategoryCommand implements ReversibleCommand {

	private String categoryName;
	private Category removedCategory;
	private ArrayList<Task> removedTask;
	private boolean hasError = false;

	public DeleteCategoryCommand(String categoryName) {
		this.categoryName = categoryName;
	}

	public boolean hasError() {
		return hasError;
	}

	public void undo(LogicController logic) {
		logic.loadTasks(removedTask);
		logic.addCategory(removedCategory);
	}

	public void redo(LogicController logic) {
		logic.removeCategory(removedCategory);
		for (Task task : removedTask) {
			logic.removeTask(task);
		}
	}

	public LogicAction execute(LogicController logic) throws IncorrectInputException {
		assert (logic != null);
		LogicAction logicAction;

		if (logic.containsCategory(categoryName)) {
			logicAction = deleteCategoryAndAllTaskWithTheCategory(logic);
		} else {
			logicAction = cantFindCategory();
		}
		return logicAction;
	}

	public LogicAction cantFindCategory() {
		LogicAction logicAction;
		logicAction = new LogicAction(Action.ERROR, String.format(Constants.FEEDBACK_CATEGORY_NOT_FOUND, categoryName));
		hasError = true;
		return logicAction;
	}

	public LogicAction deleteCategoryAndAllTaskWithTheCategory(LogicController logic) {
		LogicAction logicAction;
		removedCategory = logic.removeCategory(categoryName);
		removedTask = logic.removeTasksWithCategory(removedCategory);
		logicAction = new LogicAction(Action.DELETE_CATEGORY, String.format(Constants.FEEDBACK_DELETE_CATEGORY, categoryName));
		return logicAction;
	}

}
```
###### src\dooyit\logic\commands\DeleteTaskCommand.java
``` java
package dooyit.logic.commands;

import java.util.ArrayList;

import dooyit.common.datatype.Task;
import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.Constants;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class DeleteTaskCommand implements ReversibleCommand {

	private ArrayList<Integer> deleteIds;
	private ArrayList<Task> deletedTasks;
	private boolean hasError = false;

	public DeleteTaskCommand(int deleteId) {
		this.deleteIds = new ArrayList<Integer>();
		this.deletedTasks = new ArrayList<Task>();
		this.deleteIds.add(deleteId);
	}

	public DeleteTaskCommand(ArrayList<Integer> deleteIds) {
		this.deleteIds = new ArrayList<Integer>();
		this.deletedTasks = new ArrayList<Task>();
		this.deleteIds.addAll(deleteIds);
	}

	public boolean hasError() {
		return hasError;
	}

	public void undo(LogicController logic) {
		for (Task deletedTask : deletedTasks) {
			logic.addTask(deletedTask);
		}
	}

	public void redo(LogicController logic) {
		for (Task deletedTask : deletedTasks) {
			logic.removeTask(deletedTask);
		}
	}

	public LogicAction execute(LogicController logic) throws IncorrectInputException {
		assert (logic != null);
		LogicAction logicAction = null;

		String errorMsgBody = Constants.EMPTY_STRING;
		String deletedTaskMsg = Constants.EMPTY_STRING;

		for (Integer deleteId : deleteIds) {
			if (logic.containsTask(deleteId)) {
				deleteTaskWithTaskId(logic, deleteId);
				deletedTaskMsg += Constants.SPACE + deleteId;
			} else {
				errorMsgBody += Constants.SPACE + deleteId;
			}
		}

		logicAction = createLogicAction(logicAction, errorMsgBody, deletedTaskMsg);

		return logicAction;
	}

	public void deleteTaskWithTaskId(LogicController logic, Integer deleteId) {
		Task deletedTask = logic.removeTask(deleteId);
		deletedTasks.add(deletedTask);
	}

	public LogicAction createLogicAction(LogicAction logicAction, String errorMsgBody, String deletedTaskMsg) {
		if (!deletedTasks.isEmpty()) {
			if (deletedTasks.size() == 1) {
				logicAction = new LogicAction(Action.DELETE_TASK, String.format(Constants.FEEDBACK_TASK_DELETED, deletedTaskMsg));
			} else {
				logicAction = new LogicAction(Action.DELETE_TASK, String.format(Constants.FEEDBACK_TASKS_DELETED, deletedTaskMsg));
			}

		} else {
			hasError = true;
			if (errorMsgBody != Constants.EMPTY_STRING) {
				logicAction = new LogicAction(Action.ERROR, String.format(Constants.FEEDBACK_INVALID_IDS, errorMsgBody));
			}
		}
		return logicAction;
	}
}
```
###### src\dooyit\logic\commands\EditCategoryCommand.java
``` java
package dooyit.logic.commands;

import dooyit.common.datatype.Category;
import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.Constants;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class EditCategoryCommand implements ReversibleCommand {

	private String categoryName;
	private String newCategoryName;
	private String originalCategoryName;
	private String newColourName;
	private String originalColourString;
	private boolean hasError;
	private Category originalCategory;

	public EditCategoryCommand(String categoryName, String newCategoryName) {
		this.categoryName = categoryName;
		this.newCategoryName = newCategoryName;
	}

	public EditCategoryCommand(String categoryName, String newCategoryName, String colourName) {
		this(categoryName, newCategoryName);
		this.newColourName = colourName;
	}

	private boolean editCategoryWithColour() {
		return newColourName != null;
	}

	@Override
	public void undo(LogicController logic) {
		assert (logic != null);

		if (editCategoryWithColour()) {
			logic.editCategoryColour(originalCategory, originalColourString);
			logic.editCategoryName(originalCategory, originalCategoryName);
		} else {
			logic.editCategoryName(originalCategory, originalCategoryName);
		}
	}

	@Override
	public void redo(LogicController logic) {
		assert (logic != null);
		if (editCategoryWithColour()) {
			logic.editCategoryColour(originalCategory, newColourName);
			logic.editCategoryName(originalCategory, newCategoryName);
		} else {
			logic.editCategoryName(originalCategory, newCategoryName);
		}
	}

	@Override
	public boolean hasError() {
		return hasError;
	}

	@Override
	public LogicAction execute(LogicController logic) throws IncorrectInputException {
		assert (logic != null);
		LogicAction logicAction;

		// error if cannot find category
		if (!logic.containsCategory(categoryName)) {
			logicAction = cantFindCategory();
			return logicAction;
		}

		saveOriginalCategory(logic);

		if (editCategoryWithColour()) {
			if (logic.containsCustomColour(newColourName)) {
				logicAction = editCategoryNameAndColour(logic);
			} else {
				logicAction = invalidColour();
			}
		} else {
			logicAction = editCategoryName(logic);
			
		}

		return logicAction;
	}

	public LogicAction invalidColour() {
		return new LogicAction(Action.ERROR, String.format(Constants.FEEDBACK_INVALID_COLOUR, newColourName));
	}

	public LogicAction cantFindCategory() {
		hasError = true;
		return new LogicAction(Action.ERROR, String.format(Constants.FEEDBACK_CATEGORY_NOT_FOUND, categoryName));
	}

	public LogicAction editCategoryNameAndColour(LogicController logic) {
		LogicAction logicAction;
		originalColourString = originalCategory.getCustomColourName();
		logic.editCategoryColour(originalCategory, newColourName);
		editCategoryName(logic);
		logicAction = new LogicAction(Action.EDIT_CATEGORY, Constants.FEEDBACK_CATEGORY_EDITED);
		return logicAction;
	}

	public void saveOriginalCategory(LogicController logic) {
		originalCategory = logic.findCategory(categoryName);
		originalCategoryName = originalCategory.getName();
	}

	public LogicAction editCategoryName(LogicController logic) {
		logic.editCategoryName(originalCategory, newCategoryName);
		LogicAction logicAction = new LogicAction(Action.EDIT_CATEGORY, Constants.FEEDBACK_CATEGORY_EDITED);
		return logicAction;
	}

}
```
###### src\dooyit\logic\commands\EditTaskCommand.java
``` java
package dooyit.logic.commands;

import dooyit.common.datatype.DateTime;
import dooyit.common.datatype.Task;
import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.Constants;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class EditTaskCommand implements ReversibleCommand {

	private static final String FEEDBACK_TASK_EDITED = "Task has been edited.";

	private enum EditCommandType {
		TO_FLOAT, NAME, DEADLINE, EVENT, NAME_N_DEADLINE, NAME_N_EVENT
	};

	private EditCommandType editCommandType;
	private int taskId;
	private String taskName;
	private Task originalTask;
	private Task newTask;
	private DateTime dateTimeDeadline;
	private DateTime dateTimeStart;
	private DateTime dateTimeEnd;
	private boolean hasError = false;

	public EditTaskCommand(int taskId) {
		this.taskId = taskId;
		editCommandType = EditCommandType.TO_FLOAT;
	}

	public EditTaskCommand(int taskId, String taskName) {
		editCommandType = EditCommandType.NAME;
		this.taskName = taskName;
		this.taskId = taskId;
	}

	public EditTaskCommand(int taskId, DateTime deadline) {
		editCommandType = EditCommandType.DEADLINE;
		this.dateTimeDeadline = deadline;
		this.taskId = taskId;
	}

	public EditTaskCommand(int taskId, DateTime start, DateTime end) {
		editCommandType = EditCommandType.EVENT;
		this.dateTimeStart = start;
		this.dateTimeEnd = end;
		this.taskId = taskId;
	}

	public EditTaskCommand(int taskId, String taskName, DateTime deadline) {
		editCommandType = EditCommandType.NAME_N_DEADLINE;
		this.taskName = taskName;
		this.dateTimeDeadline = deadline;
		this.taskId = taskId;
	}

	public EditTaskCommand(int taskId, String taskName, DateTime start, DateTime end) {
		assert (start != null && end != null);

		editCommandType = EditCommandType.NAME_N_EVENT;
		this.taskName = taskName;
		this.dateTimeStart = start;
		this.dateTimeEnd = end;
		this.taskId = taskId;
	}

	public boolean hasError() {
		return hasError;
	}

	public void undo(LogicController logic) {
		assert (logic != null);

		logic.removeTask(newTask);
		logic.addTask(originalTask);
	}

	public void redo(LogicController logic) {
		logic.addTask(newTask);
		logic.removeTask(originalTask);
	}

	public LogicAction execute(LogicController logic) throws IncorrectInputException {
		assert (logic != null);
		LogicAction logicAction = null;

		if (!logic.containsTask(taskId)) {
			logicAction = cantFindTaskId();
			return logicAction;
		}

		// save original task for undo
		saveOriginalTask(logic);

		switch (editCommandType) {
		case NAME:
			newTask = logic.changeTaskName(taskId, taskName);
			logicAction = changeTaskName();
			break;

		case TO_FLOAT:
			newTask = logic.changeToFloatingTask(taskId);
			logicAction = getActionBasedOnEditedTask(logic, newTask);
			break;

		case DEADLINE:
			newTask = logic.changeTaskToDeadline(taskId, dateTimeDeadline);
			logicAction = getActionBasedOnEditedTask(logic, newTask);
			break;

		case EVENT:
			newTask = logic.changeTaskToEvent(taskId, dateTimeStart, dateTimeEnd);
			logicAction = getActionBasedOnEditedTask(logic, newTask);
			break;

		case NAME_N_DEADLINE:
			logic.changeTaskName(taskId, taskName);
			newTask = logic.changeTaskToDeadline(taskId, dateTimeDeadline);
			logicAction = getActionBasedOnEditedTask(logic, newTask);
			break;

		case NAME_N_EVENT:
			logic.changeTaskName(taskId, taskName);
			newTask = logic.changeTaskToEvent(taskId, dateTimeStart, dateTimeEnd);
			logicAction = getActionBasedOnEditedTask(logic, newTask);
			break;
		}

		return logicAction;
	}

	public LogicAction changeTaskName() {
		return new LogicAction(Action.EDIT_NAME, FEEDBACK_TASK_EDITED);
	}

	public void saveOriginalTask(LogicController logic) {
		originalTask = logic.findTask(taskId);
	}

	public LogicAction cantFindTaskId() {
		LogicAction logicAction;
		hasError = true;
		logicAction = new LogicAction(Action.ERROR, String.format(Constants.FEEDBACK_INVALID_ID, taskId));
		return logicAction;
	}

	public LogicAction getActionBasedOnEditedTask(LogicController logic, Task newTask) {
		LogicAction logicAction;

		if (logic.isFloatingTask(newTask)) {
			logicAction = new LogicAction(Action.EDIT_TO_FLOATING_TASK, FEEDBACK_TASK_EDITED);
		} else if (logic.isTodayTask(newTask)) {
			logicAction = new LogicAction(Action.EDIT_TO_TODAY_TASK, FEEDBACK_TASK_EDITED);

		} else if (logic.isNext7daysTask(newTask)) {
			logicAction = new LogicAction(Action.EDIT_TO_NEXT7DAY_TASK, FEEDBACK_TASK_EDITED);

		} else {
			logicAction = new LogicAction(Action.EDIT_TO_ALL_TASK, FEEDBACK_TASK_EDITED);
		}

		return logicAction;
	}

}
```
###### src\dooyit\logic\commands\ExitCommand.java
``` java
package dooyit.logic.commands;

import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class ExitCommand implements Command {

	private boolean hasError = false;

	public ExitCommand() {

	}

	public boolean hasError() {
		return hasError;
	}

	public LogicAction execute(LogicController logic) throws IncorrectInputException {
		LogicAction logicAction = new LogicAction(Action.EXIT);
		System.exit(1);
		return logicAction;
	}
}
```
###### src\dooyit\logic\commands\HelpCommand.java
``` java
package dooyit.logic.commands;

import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class HelpCommand implements Command {

	private boolean hasError = false;

	public HelpCommand() {

	}

	public boolean hasError() {
		return hasError;
	}

	public LogicAction execute(LogicController logic) throws IncorrectInputException {
		LogicAction logicAction = new LogicAction(Action.HELP);
		return logicAction;
	}

}
```
###### src\dooyit\logic\commands\InvalidCommand.java
``` java
package dooyit.logic.commands;

import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class InvalidCommand implements Command {
	String errorMessage;
	private boolean hasError = false;

	public InvalidCommand(String errorMessage) {
		this.errorMessage = errorMessage;
	}

	public boolean hasError() {
		return hasError;
	}

	public LogicAction execute(LogicController logic) throws IncorrectInputException {
		LogicAction logicAction = new LogicAction(Action.ERROR, errorMessage);
		hasError = true;
		return logicAction;
	}

}
```
###### src\dooyit\logic\commands\MarkTaskCommand.java
``` java
package dooyit.logic.commands;

import java.util.ArrayList;

import dooyit.common.datatype.Task;
import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.Constants;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class MarkTaskCommand implements ReversibleCommand {
	private ArrayList<Integer> markIds;
	private ArrayList<Task> markedTasks;
	private boolean hasError = false;

	public MarkTaskCommand(int markId) {
		this.markIds = new ArrayList<Integer>();
		this.markedTasks = new ArrayList<Task>();
		this.markIds.add(markId);
	}

	public MarkTaskCommand(ArrayList<Integer> markIds) {
		this.markIds = new ArrayList<Integer>();
		this.markedTasks = new ArrayList<Task>();
		this.markIds.addAll(markIds);
	}

	public boolean hasError() {
		return hasError;
	}

	public void undo(LogicController logic) {
		for (Task markedTask : markedTasks) {
			logic.unmarkTask(markedTask);
		}
	}

	public void redo(LogicController logic) {
		for (Task markedTask : markedTasks) {
			logic.markTask(markedTask);
		}
	}

	public LogicAction execute(LogicController logic) throws IncorrectInputException {
		assert (logic != null);
		LogicAction logicAction = null;

		String markedTaskMsg = Constants.EMPTY_STRING;
		String errorMessageBody = Constants.EMPTY_STRING;

		for (int markId : markIds) {
			if (logic.containsTask(markId)) {
				markTaskWithTaskId(logic, markId);
				markedTaskMsg += Constants.SPACE + markId;
			} else {
				errorMessageBody += Constants.SPACE + markId;
			}
		}

		logicAction = createLogicAction(logicAction, markedTaskMsg, errorMessageBody);

		return logicAction;
	}

	public void markTaskWithTaskId(LogicController logic, int markId) {
		logic.markTask(markId);
		Task markedTask = logic.findTask(markId);
		markedTasks.add(markedTask);
	}

	public LogicAction createLogicAction(LogicAction logicAction, String markedTaskMsg, String errorMessageBody) {
		if (!markedTasks.isEmpty()) {
			if (markedTasks.size() == 1) {
				logicAction = new LogicAction(Action.MARK_TASK, String.format(Constants.FEEDBACK_TASK_MARKED, markedTaskMsg));
			} else {
				logicAction = new LogicAction(Action.MARK_TASK, String.format(Constants.FEEDBACK_TASKS_MARKED, markedTaskMsg));
			}

		} else {
			hasError = true;
			if (errorMessageBody != Constants.EMPTY_STRING) {
				logicAction = new LogicAction(Action.ERROR, String.format(Constants.FEEDBACK_INVALID_IDS, errorMessageBody));
			}
		}
		return logicAction;
	}
}
```
###### src\dooyit\logic\commands\MoveToCategory.java
``` java
package dooyit.logic.commands;

import java.util.ArrayList;

import dooyit.common.datatype.Category;
import dooyit.common.datatype.Task;
import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.Constants;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class MoveToCategory implements ReversibleCommand {

	private String categoryName;
	private ArrayList<Integer> taskIds;
	private ArrayList<Task> tasksWithCategory;
	private Category settedCategory;
	private Category prevCategory;
	private boolean isNewCatCreated;
	private boolean hasError = false;

	public MoveToCategory(int taskId, String categoryName) {
		this.taskIds = new ArrayList<Integer>();
		this.taskIds.add(taskId);
		this.categoryName = categoryName;
	}

	public MoveToCategory(ArrayList<Integer> taskIds, String categoryName) {
		this.taskIds = new ArrayList<Integer>();
		this.taskIds.addAll(taskIds);
		this.categoryName = categoryName;
	}

	public boolean hasError() {
		return hasError;
	}

	public void undo(LogicController logic) {
		for (Task task : tasksWithCategory) {
			task.setCategory(prevCategory);
		}

		if (isNewCatCreated) {
			logic.removeCategory(settedCategory);
		}
	}

	public void redo(LogicController logic) {
		for (Task task : tasksWithCategory) {
			task.setCategory(settedCategory);
		}

		if (isNewCatCreated) {
			logic.addCategory(settedCategory);
		}
	}

	public LogicAction execute(LogicController logic) throws IncorrectInputException {
		assert (logic != null);
		LogicAction logicAction = null;
		tasksWithCategory = new ArrayList<Task>();

		String movedTaskIdMsg = Constants.EMPTY_STRING;
		String errorMsgBody = Constants.EMPTY_STRING;

		for (int taskId : taskIds) {
			if (logic.containsTask(taskId)) {
				if (logic.containsCategory(categoryName)) {
					moveTaskToExistingCategory(logic, taskId);
				} else {
					moveTaskToNewCategory(logic, taskId);
				}
				movedTaskIdMsg += Constants.SPACE + taskId;
			} else {
				errorMsgBody += Constants.SPACE + taskId;
			}
		}

		logicAction = createLogicAction(logicAction, movedTaskIdMsg, errorMsgBody);

		return logicAction;
	}

	/**
	 * @param logic
	 * @param taskId
	 */
	public void moveTaskToNewCategory(LogicController logic, int taskId) {
		isNewCatCreated = true;
		settedCategory = logic.addCategory(categoryName);
		Task task = logic.findTask(taskId);
		prevCategory = task.getCategory();
		task.setCategory(settedCategory);
		tasksWithCategory.add(task);
	}

	/**
	 * @param logic
	 * @param taskId
	 */
	public void moveTaskToExistingCategory(LogicController logic, int taskId) {
		isNewCatCreated = false;
		settedCategory = logic.findCategory(categoryName);
		Task task = logic.findTask(taskId);
		prevCategory = task.getCategory();
		task.setCategory(settedCategory);
		tasksWithCategory.add(task);
	}

	/**
	 * @param logicAction
	 * @param movedTaskIdMsg
	 * @param errorMsgBody
	 * @return
	 */
	public LogicAction createLogicAction(LogicAction logicAction, String movedTaskIdMsg, String errorMsgBody) {
		if (!tasksWithCategory.isEmpty()) {
			if (tasksWithCategory.size() == 1) {
				logicAction = new LogicAction(Action.ADD_N_SET_CATEGORY, String.format(Constants.FEEDBACK_TASK_MOVED, movedTaskIdMsg, settedCategory.getName()));
			} else {
				logicAction = new LogicAction(Action.ADD_N_SET_CATEGORY, String.format(Constants.FEEDBACK_TASKS_MOVED, movedTaskIdMsg, settedCategory.getName()));
			}
		} else {
			hasError = true;
			if (errorMsgBody != Constants.EMPTY_STRING) {
				logicAction = new LogicAction(Action.ERROR, String.format(Constants.FEEDBACK_INVALID_IDS, errorMsgBody));
			}
		}
		return logicAction;
	}

}
```
###### src\dooyit\logic\commands\RedoCommand.java
``` java
package dooyit.logic.commands;

import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.Constants;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class RedoCommand implements Command {

	private boolean hasError = false;

	public RedoCommand() {

	}

	public boolean hasError() {
		return hasError;
	}

	public LogicAction execute(LogicController logic) throws IncorrectInputException {
		assert (logic != null);
		LogicAction logicAction;

		boolean isSuccuss = logic.redo();

		if (isSuccuss) {
			logicAction = new LogicAction(Action.REDO, Constants.FEEDBACK_SUCCESS_REDO);
		} else {
			logicAction = new LogicAction(Action.REDO, Constants.FEEDBACK_FAIL_REDO);
		}
		
		return logicAction;
	}

}
```
###### src\dooyit\logic\commands\ReversibleCommand.java
``` java
package dooyit.logic.commands;

import dooyit.logic.api.LogicController;

public interface ReversibleCommand extends Command{

	public void undo(LogicController logic);

	public void redo(LogicController logic);
}
```
###### src\dooyit\logic\commands\SearchCommand.java
``` java
package dooyit.logic.commands;

import dooyit.common.datatype.DateTime;
import dooyit.common.datatype.DateTime.Day;
import dooyit.common.datatype.DateTime.Month;
import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

/**
 * The search command can search by keyword, day, month and datetime.
 * @author limtaeu
 *
 */
public class SearchCommand implements Command {
	
	enum SearchType {
		NAME, DATE, DAY, MONTH
	}
	
	private String searchString;
	private SearchType searchType;
	private DateTime searchDateTime;
	private Day searchDay;
	private Month searchMonth;
	private boolean hasError = false;

	public SearchCommand(String searchString) {
		searchType = SearchType.NAME;
		this.searchString = searchString;
	}
	
	public SearchCommand(String searchString, Day day){
		searchType = SearchType.DAY;
		this.searchString = searchString;
		this.searchDay = day;
	}
	
	public SearchCommand(String searchString, Month month){
		searchType = SearchType.MONTH;
		this.searchString = searchString;
		this.searchMonth = month;
	}
	
	public SearchCommand(DateTime dateTime){
		searchType = SearchType.DATE;
		this.searchDateTime = dateTime;
	}

	public boolean hasError() {
		return hasError;
	}

	public LogicAction execute(LogicController logic) throws IncorrectInputException {
		assert(logic != null);
		
		switch(searchType){
		case NAME:
			logic.setSearchKey(searchString);
			break;
			
		case DAY:
			logic.setSearchKey(searchString, searchDay);
			break;
			
		case MONTH:
			logic.setSearchKey(searchString, searchMonth);
			break;
			
		case DATE:
			logic.setSearchKey(searchDateTime);
			break;
		}
		
		LogicAction logicAction = new LogicAction(Action.SEARCH);
		return logicAction;
	}

}
```
###### src\dooyit\logic\commands\ShowCommand.java
``` java
package dooyit.logic.commands;

import dooyit.common.datatype.Category;
import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.Constants;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class ShowCommand implements Command {

	public enum ShowCommandType {
		TODAY, NEXT7DAY, FLOAT, ALL, COMPLETED, CATEGORY
	}

	String categoryName;
	ShowCommandType showCommandType;
	private boolean hasError = false;

	public ShowCommand(ShowCommandType showCommandType) {
		this.showCommandType = showCommandType;
	}

	public ShowCommand(ShowCommandType showCommandType, String categoryName) {
		this.showCommandType = showCommandType;
		this.categoryName = categoryName;
	}

	public boolean hasError() {
		return hasError;
	}

	public LogicAction execute(LogicController logic) throws IncorrectInputException {
		assert (logic != null);

		LogicAction logicAction = null;

		switch (showCommandType) {
		case TODAY:
			logicAction = new LogicAction(Action.SHOW_TODAY_TASK);
			break;

		case NEXT7DAY:
			logicAction = new LogicAction(Action.SHOW_NEXT7DAY_TASK);
			break;

		case FLOAT:
			logicAction = new LogicAction(Action.SHOW_FLOATING_TASK);
			break;

		case ALL:
			logicAction = new LogicAction(Action.SHOW_ALL_TASK);
			break;

		case COMPLETED:
			logicAction = new LogicAction(Action.SHOW_COMPLETED);
			break;

		case CATEGORY:
			if (logic.containsCategory(categoryName)) {
				Category category = logic.findCategory(categoryName);
				logic.setSelectedCategory(category);
				logicAction = new LogicAction(Action.SHOW_CATEGORY);
			} else {
				logicAction = new LogicAction(Action.ERROR, String.format(Constants.FEEDBACK_CATEGORY_NOT_FOUND, categoryName));
			}
			break;
		}

		return logicAction;
	}

}
```
###### src\dooyit\logic\commands\StorageCommand.java
``` java
package dooyit.logic.commands;

import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.Constants;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class StorageCommand implements ReversibleCommand {

	private String path;
	private String previousPath;
	private boolean hasError = false;

	public StorageCommand(String path) {
		this.path = path;
	}

	public boolean hasError() {
		return hasError;
	}

	public void undo(LogicController logic) {
		boolean fileExist = logic.setFileDestinationPath(previousPath);

		if (fileExist) {
			logic.loadFromStorage();
		}
	}

	public void redo(LogicController logic) {
		boolean fileExist = logic.setFileDestinationPath(path);

		if (fileExist) {
			logic.loadFromStorage();
		}
	}

	public LogicAction execute(LogicController logic) throws IncorrectInputException {
		assert (logic != null);
		LogicAction logicAction;

		try {
			previousPath = logic.getFilePath();
			boolean fileExist = logic.setFileDestinationPath(path);

			if (fileExist) {
				logicAction = loadFileContent(logic);
			} else {
				logicAction = setNewPath();
			}
		} catch (IncorrectInputException e) {
			logicAction = showErrorMessage(e);
			
		}

		return logicAction;
	}

	public LogicAction showErrorMessage(IncorrectInputException e) {
		hasError = true;
		return new LogicAction(Action.ERROR, e.getMessage());
	}

	public LogicAction setNewPath() {
		return new LogicAction(Action.SET_STORAGE_PATH, Constants.FEEDBACK_SET_NEW_PATH);
	}

	public LogicAction loadFileContent(LogicController logic) {
		LogicAction logicAction;
		logic.loadFromStorage();
		logicAction = new LogicAction(Action.SET_STORAGE_PATH, Constants.FEEDBACK_SET_NEW_PATH_WITH_LOAD);
		return logicAction;
	}

}
```
###### src\dooyit\logic\commands\UndoCommand.java
``` java
package dooyit.logic.commands;

import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.Constants;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class UndoCommand implements Command {

	private boolean hasError = false;

	public UndoCommand() {

	}

	public boolean hasError() {
		return hasError;
	}

	public LogicAction execute(LogicController logic) throws IncorrectInputException {
		assert (logic != null);
		LogicAction logicAction;

		boolean isSuccess = logic.undo();

		if (isSuccess) {
			logicAction = successFeedback();
		} else {
			logicAction = failFeedBack();
		}

		return logicAction;
	}

	public LogicAction failFeedBack() {
		return new LogicAction(Action.UNDO, Constants.FEEDBACK_FAIL_UNDO);
	}

	public LogicAction successFeedback() {
		return new LogicAction(Action.UNDO, Constants.FEEDBACK_SUCCESS_UNDO);
	}

}
```
###### src\dooyit\logic\commands\UnmarkTaskCommand.java
``` java
package dooyit.logic.commands;

import java.util.ArrayList;

import dooyit.common.datatype.Task;
import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.Constants;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class UnmarkTaskCommand implements ReversibleCommand {

	private ArrayList<Integer> unmarkIds;
	private ArrayList<Task> unmarkedTasks;
	private boolean hasError = false;

	public UnmarkTaskCommand(int unMarkId) {
		this.unmarkIds = new ArrayList<Integer>();
		this.unmarkedTasks = new ArrayList<Task>();
		this.unmarkIds.add(unMarkId);
	}

	public UnmarkTaskCommand(ArrayList<Integer> unMarkIds) {
		this.unmarkIds = new ArrayList<Integer>();
		this.unmarkedTasks = new ArrayList<Task>();
		this.unmarkIds.addAll(unMarkIds);
	}

	public boolean hasError() {
		return hasError;
	}

	public void undo(LogicController logic) {
		for (Task unmarkedTask : unmarkedTasks) {
			logic.markTask(unmarkedTask);
		}
	}

	public void redo(LogicController logic) {
		for (Task unmarkedTask : unmarkedTasks) {
			logic.unmarkTask(unmarkedTask);
		}
	}

	public LogicAction execute(LogicController logic) throws IncorrectInputException {
		assert (logic != null);
		LogicAction logicAction = null;

		String unmarkedTaskMsg = Constants.EMPTY_STRING;
		String errorMessageBody = Constants.EMPTY_STRING;

		for (int unmarkId : unmarkIds) {
			if (logic.containsTask(unmarkId)) {
				boolean unmarkSuccess;
				unmarkSuccess = unmarkTaskWithTaskId(logic, unmarkId);
				
				if(unmarkSuccess){
					unmarkedTaskMsg += Constants.SPACE + unmarkId;
				}
			} else {
				errorMessageBody += Constants.SPACE + unmarkId;
			}
		}

		logicAction = createLogicAction(logicAction, unmarkedTaskMsg, errorMessageBody);

		return logicAction;
	}

	public boolean unmarkTaskWithTaskId(LogicController logic, int unmarkId) {
		boolean unmarkSuccess;
		unmarkSuccess = logic.unmarkTask(unmarkId);
		Task unmarkedTask = logic.findTask(unmarkId);
		unmarkedTasks.add(unmarkedTask);
		return unmarkSuccess;
	}

	public LogicAction createLogicAction(LogicAction logicAction, String unmarkedTaskMsg, String errorMessageBody) {
		if (!unmarkedTasks.isEmpty()) {
			if(unmarkedTaskMsg == Constants.EMPTY_STRING){
				logicAction = new LogicAction(Action.UNMARK_TASK, String.format(Constants.FEEDBACK_TASK_NOT_COMPLETED));
			}else if (unmarkedTasks.size() == 1) {
				logicAction = new LogicAction(Action.UNMARK_TASK, String.format(Constants.FEEDBACK_TASK_UNMARKED, unmarkedTaskMsg));
			} else {
				logicAction = new LogicAction(Action.UNMARK_TASK, String.format(Constants.FEEDBACK_TASKS_UNMARKED, unmarkedTaskMsg));
			}

		} else {
			hasError = true;
			if (errorMessageBody != Constants.EMPTY_STRING) {
				logicAction = new LogicAction(Action.ERROR, String.format(Constants.FEEDBACK_INVALID_IDS, errorMessageBody));
			}
		}
		return logicAction;
	}
}
```
###### src\dooyit\logic\commands\UnMoveCategory.java
``` java
package dooyit.logic.commands;

import dooyit.common.datatype.Category;
import dooyit.common.datatype.Task;
import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.Constants;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class UnMoveCategory implements ReversibleCommand {

	private int taskId;
	private Task taskWithCategory;
	private Category removedCategory;
	private boolean hasError = false;

	public UnMoveCategory(int taskId) {
		this.taskId = taskId;
	}

	public boolean hasError() {
		return hasError;
	}

	public void undo(LogicController logic) {
		taskWithCategory.setCategory(removedCategory);
	}

	public void redo(LogicController logic) {
		taskWithCategory.removeCategory();
	}

	public LogicAction execute(LogicController logic) throws IncorrectInputException {
		assert (logic != null);
		LogicAction logicAction;

		if (!logic.containsTask(taskId)) {
			logicAction = cantFindTask();
			return logicAction;
		}
		
		taskWithCategory = logic.findTask(taskId);
		if(!taskWithCategory.hasCategory()){
			logicAction = taskDoesntHaveCategory();
			return logicAction;
		}
		
		logicAction = removeCategoryFromTask();

		return logicAction;
	}

	public LogicAction cantFindTask() {
		LogicAction logicAction;
		hasError = true;
		logicAction = new LogicAction(Action.ERROR, String.format(Constants.FEEDBACK_INVALID_ID, taskId));
		return logicAction;
	}

	public LogicAction taskDoesntHaveCategory() {
		LogicAction logicAction;
		hasError = true;
		logicAction = new LogicAction(Action.ERROR, String.format(Constants.FEEDBACK_CATEGORY_DOESNT_EXIST, taskId));
		return logicAction;
	}

	public LogicAction removeCategoryFromTask() {
		LogicAction logicAction;
		removedCategory = taskWithCategory.getCategory();
		taskWithCategory.setCategory(null);
		logicAction = new LogicAction(Action.REMOVE_CAT_FROM_TASK, String.format(Constants.FEEDBACK_TASK_UNMOVED, taskId));
		return logicAction;
	}

}
```
###### src\dooyit\logic\Constants.java
``` java
package dooyit.logic;

public class Constants {
	public static final String FEEDBACK_TASK_ADDED = "Task created.";
	public static final String FEEDBACK_TASK_CLEARED = "All tasks have been cleared!";
	public static final String FEEDBACK_TASK_DELETED = "Task%1$s has been deleted.";
	public static final String FEEDBACK_TASKS_DELETED = "Tasks%1$s have been deleted.";
	public static final String FEEDBACK_TASK_MARKED = "Task%1$s has been marked.";
	public static final String FEEDBACK_TASKS_MARKED = "Tasks%1$s have been marked.";
	public static final String FEEDBACK_TASK_UNMARKED = "Task%1$s has been unmarked.";
	public static final String FEEDBACK_TASKS_UNMARKED = "Tasks%1$s have been unmarked.";
	public static final String FEEDBACK_TASK_NOT_COMPLETED = "Task is still not done.";
	public static final String FEEDBACK_TASK_MOVED = "Task%1$s has been moved to %2$s.";
	public static final String FEEDBACK_TASKS_MOVED = "Tasks%1$s have been moved to %2$s.";
	public static final String FEEDBACK_TASK_UNMOVED = "Category successfully removed from Task %1$d.";
	public static final String FEEDBACK_CONFLICTING_EVENT = "This task conclicts with another event. ";
	public static final String FEEDBACK_INCORRECT_INPUT = "Incorrect Input.";

	public static final String FEEDBACK_DELETE_CATEGORY = "CATEGORY: %1$s deleted.";
	public static final String FEEDBACK_CATEGORY_ADDED = "CATEGORY: %1$s created. %2$s";
	public static final String FEEDBACK_FAIL_CATEGORY_EXISTS = "CATEGORY: %1$s already exists.";
	public static final String FEEDBACK_CATEGORY_NOT_FOUND = "CATEGORY: %1$s not found.";
	public static final String FEEDBACK_CATEGORY_EDITED = "Category has been edited.";
	public static final String FEEDBACK_CATEGORY_DOESNT_EXIST = "Task %1$d doesn't have any category.";
	public static final String DEFAULT_CATEGORY_ENTERTAINMENT = "Entertainment";
	public static final String DEFAULT_CATEGORY_SCHOOL = "School";
	
	public static final String FEEDBACK_FAIL_UNDO = "Oops, nothing to UNDO.";
	public static final String FEEDBACK_SUCCESS_UNDO = "UNDO successful!";
	public static final String FEEDBACK_FAIL_REDO = "Oops, nothing to REDO";
	public static final String FEEDBACK_SUCCESS_REDO = "REDO successful!";

	public static final String FEEDBACK_SET_NEW_PATH_WITH_LOAD = "New data has been loaded from the new path.";
	public static final String FEEDBACK_SET_NEW_PATH = "New path has been set.";
	public static final String FEEDBACK_INVALID_PATH = "Invalid path: %1$s";

	public static final String FEEDBACK_INVALID_ID = "TASK ID: %1$d doesn't exists.";
	public static final String FEEDBACK_INVALID_IDS = "TASK ID: %1$s doesn't exists.";
	public static final String FEEDBACK_INVALID_COLOUR_WITH_SUGGESTION = "COLOUR: %1$s is not available but a random colour has been picked for you!";
	public static final String FEEDBACK_INVALID_COLOUR = "Invalid Colour: %1$s";
	
	public static final String THEME_CUSTOM = "custom";
	public static final String THEME_AQUA = "aqua";
	public static final String THEME_DARK = "dark";
	public static final String THEME_LIGHT = "light";
	public static final String THEME_DEFAULT = "default";
	public static final String FEEDBACK_SUCCESS_CHANGE_THEME = "Your theme has been change to %1$s skin!";
	public static final String FEEDBACK_INVALID_THEME = "%1$s is not available, try DEFAULT, DARK, AQUA or CUSTOM";

	public static final String ERROR_FAIL_TO_CREATE_STORAGE = "ERROR: Fail to create storage";
	public static final String ERROR_FAIL_TO_LOAD_TASK_FROM_STORAGE = "ERROR: Fail to load task from storage";
	public static final String ERROR_INCORRECT_INPUT = "ERROR: Incorrect Input.";
	public static final String ERROR_FAIL_TO_SAVE = "ERROR: Fail to save";
	public static final String ERROR_FAIL_TO_GENERATE_CSS = "Error: fail to generate CSS";
	public static final String ERROR_SET_FILE_DESTINATION_PATH = "ERROR: setFileDestinationPath";

	public static final String LOG_LOGIC = "Logic";
	public static final String LOG_MSG_INITIALISING_LOGIC_CLASS = "Initialising logic class";
	public static final String LOG_MSG_END_OF_INITIALISING_LOGIC_CLASS = "End of initialising logic class";
	public static final String LOG_MSG_INITIALISING_PARSER = "Initialising Parser";
	public static final String LOG_MSG_INITIALISING_TASK_MANAGER = "Initialising Task Manager";
	public static final String LOG_MSG_INITIALISING_CATEGORY_MANAGER = "Initialising Category Manager";
	public static final String LOG_MSG_INITIALISING_HISTORY_MANAGER = "Initialising History Manager";
	public static final String LOG_MSG_INITIALISING_STORAGE = "Initialising Storage";
	public static final String LOG_MSG_INITIALISING_DATA_MANAGER = "Initialising DataManager";
	public static final String LOG_MSG_LOADING_DATA_FROM_STORAGE = "Loading data from storage";
	
	public static final String TITLE_TODAY = "Today";
	public static final String TITLE_TOMORROW = "Tomorrow";
	public static final String TITLE_FLOAT = "Float";
	public static final String TITLE_ALL = "All";
	public static final String TITLE_COMPLETED = "Completed";
	public static final String TITLE_OVERDUE = "Overdue";
	public static final String TITLE_SEARCH_LIST = "Search List";
	public static final String TITLE_TASK_LIST = "Task List";
	
	public static final int DAYS_PER_WEEK = 7;
	public static final int FIRST_DAY = 1;
	public static final int SECOND_DAY = 2;
	public static final String SPACE = " ";
	public static final String EMPTY_STRING = "";
	public static final String SYMBOL_COLON = ": ";
}
```
###### test\AllTestSuite.java
``` java
import org.junit.runner.RunWith;
import org.junit.runners.Suite;

import dooyit.common.datatype.DataTypeTestSuite;
import dooyit.logic.LogicTestSuite;
import dooyit.logic.commands.LogicCommandTestSuite;
import dooyit.parser.ParserTestSuite;
import dooyit.storage.StorageTestSuite;

@RunWith(Suite.class)
@Suite.SuiteClasses({ IntegrationTestSuite.class, LogicCommandTestSuite.class, LogicTestSuite.class,
		ParserTestSuite.class, StorageTestSuite.class, DataTypeTestSuite.class })

public class AllTestSuite {

}
```
###### test\dooyit\logic\CategoryManagerTest.java
``` java
package dooyit.logic;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.util.ArrayList;

import org.junit.Before;
import org.junit.Test;

import dooyit.common.datatype.Category;
import dooyit.common.datatype.CustomColour;
import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.api.CategoryManager;
import dooyit.logic.api.LogicController;

public class CategoryManagerTest {

	LogicController logicController;
	CategoryManager categoryManager;

	Category schoolCat1;
	Category schoolCat2;
	Category schoolCat3;
	Category shoppingCat;

	@Before
	public void setUp() {
		logicController = new LogicController();
		logicController.disableSave();
		logicController.clearTasks();

		categoryManager = new CategoryManager();
		setUpCategory();
	}

	public void setUpCategory() {
		schoolCat1 = new Category("school");
		schoolCat2 = new Category("school");
		schoolCat3 = new Category("school", CustomColour.BLUE);
		shoppingCat = new Category("shopping");
	}

	@Test
	public void findCategory() {
		categoryManager.clear();
		Category addedCategory = categoryManager.addCategory("school");
		assertTrue(categoryManager.find("school").equals(addedCategory));
		assertTrue(categoryManager.find(addedCategory).equals(addedCategory));
		assertTrue(categoryManager.find("hello") == null);
		assertTrue(categoryManager.find(shoppingCat) == null);
	}

	@Test
	public void containsCategory() {
		categoryManager.clear();
		Category addedCategory = categoryManager.addCategory("school");
		assertTrue(categoryManager.contains("school"));
		assertFalse(categoryManager.contains("hello"));
		assertTrue(categoryManager.contains(addedCategory));
		assertFalse(categoryManager.contains(shoppingCat));
	}

	@Test
	public void addCategory() {
		categoryManager.clear();
		categoryManager.addCategory("school");
		categoryManager.contains("school");
		categoryManager.contains(schoolCat1);
	}

	@Test
	public void addCategoryWithColour() {
		categoryManager.clear();
		categoryManager.addCategory("school", "blue");
		categoryManager.contains(schoolCat3);
	}

	@Test(expected = IncorrectInputException.class)
	public void addExistingCategory() {
		categoryManager.clear();
		categoryManager.addCategory("school");
		categoryManager.addCategory("school");
	}

	@Test(expected = IncorrectInputException.class)
	public void addCategoryWithInvalidColour() {
		categoryManager.clear();
		categoryManager.addCategory("school", "darkorange");
	}

	@Test
	public void addCategoryWithDifferentLetterCase() {
		categoryManager.clear();
		categoryManager.addCategory("school");
		categoryManager.contains("school");
		categoryManager.contains(schoolCat1);

		categoryManager.clear();
		categoryManager.addCategory("school");
		categoryManager.contains("School");
		categoryManager.contains(schoolCat1);

		categoryManager.clear();
		categoryManager.addCategory("School");
		categoryManager.contains("school");
		categoryManager.contains(schoolCat1);

		categoryManager.clear();
		categoryManager.addCategory("SCHOOL");
		categoryManager.contains("school");
		categoryManager.contains(schoolCat1);
	}

	@Test
	public void setDefaultCategories() {
		categoryManager.clear();
		categoryManager.setDefaultCategories();
		categoryManager.find("school");
		categoryManager.find("entertainment");
	}

	@Test
	public void getAllCategories() {
		categoryManager.clear();
		Category addedCat1 = categoryManager.addCategory("school");
		Category addedCat2 = categoryManager.addCategory("vehicle");

		ArrayList<Category> categories = categoryManager.getAllCategories();
		assertTrue(categories.contains(addedCat1));
		assertTrue(categories.contains(addedCat2));
	}

	@Test
	public void loadCategories() {
		categoryManager.clear();
		ArrayList<Category> categories = new ArrayList<Category>();
		categories.add(schoolCat1);
		categories.add(shoppingCat);
		categoryManager.load(categories);

		assertTrue(categoryManager.contains(schoolCat1));
		assertTrue(categoryManager.contains(shoppingCat));
	}

}
```
###### test\dooyit\logic\commands\AddCategoryCommandTest.java
``` java
package dooyit.logic.commands;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import org.junit.Before;
import org.junit.Test;
import org.powermock.reflect.Whitebox;

import dooyit.common.datatype.Category;
import dooyit.common.datatype.CustomColour;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class AddCategoryCommandTest {

	LogicController logic;
	AddCategoryCommand addCatCommand;

	@Before
	public void setUp() {
		logic = new LogicController();
		logic.disableSave();
		logic.clearTasks();
	}

	@Test
	public void addCategory() {
		logic.clearCategory();
		addCatCommand = new AddCategoryCommand("CS3230");
		addCatCommand.execute(logic);

		assertTrue(logic.containsCategory("CS3230"));
	}

	@Test
	public void addExistingCategory() {
		logic.clearCategory();
		addCatCommand = new AddCategoryCommand("CS3230");
		addCatCommand.execute(logic);

		assertTrue(logic.containsCategory("CS3230"));

		addCatCommand = new AddCategoryCommand("CS3230");
		LogicAction logicAction = addCatCommand.execute(logic);
		Action action = Whitebox.getInternalState(logicAction, "action");
		assertEquals(Action.ERROR, action);
	}

	@Test
	public void addCategoryWithColour() {
		logic.clearCategory();
		addCatCommand = new AddCategoryCommand("CS3230", "blue");
		addCatCommand.execute(logic);

		assertTrue(logic.containsCategory("CS3230"));
		Category category = logic.findCategory("CS3230");
		assertTrue(category.getCustomColour() == CustomColour.BLUE);
	}

	@Test
	public void addCategoryWithInvalidColour() {
		logic.clearCategory();
		addCatCommand = new AddCategoryCommand("CS3230", "darkorange");
		LogicAction logicAction = addCatCommand.execute(logic);
		Action action = Whitebox.getInternalState(logicAction, "action");
		assertEquals(Action.ADD_CATEGORY, action);
	}
}
```
###### test\dooyit\logic\commands\AddCommandTest.java
``` java
package dooyit.logic.commands;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Before;
import org.junit.Test;

import dooyit.common.datatype.DateTime;
import dooyit.common.datatype.Task;
import dooyit.logic.api.LogicController;
import dooyit.logic.api.TaskManager;

public class AddCommandTest {

	LogicController logic;
	AddTaskCommand addCommand;

	@Before
	public void setUp() {
		logic = new LogicController();
		logic.disableSave();
		logic.clearTasks();
	}

	@Test
	public void addFloatingTask() {
		addCommand = new AddTaskCommand("hello");
		addCommand.execute(logic);

		Task task = getMostRecentTask();

		assertTrue(logic.containsTask(task));
	}

	@Test
	public void addDeadlineTask() {
		DateTime dateTime = new DateTime();
		addCommand = new AddTaskCommand("hello", dateTime);
		addCommand.execute(logic);

		Task task = getMostRecentTask();

		assertTrue(logic.containsTask(task));
	}

	@Test
	public void addEventTask() {
		DateTime dateTimeStart = new DateTime();
		DateTime dateTimeEnd = new DateTime();
		addCommand = new AddTaskCommand("hello", dateTimeStart, dateTimeEnd);
		addCommand.execute(logic);

		Task task = getMostRecentTask();

		assertTrue(logic.containsTask(task));
	}

	@Test
	public void undoAddedFloatingTask() {
		addCommand = new AddTaskCommand("hello");
		addCommand.execute(logic);

		Task task = getMostRecentTask();

		// make sure task is inside taskManager
		assertTrue(logic.containsTask(task));

		addCommand.undo(logic);
		assertFalse(logic.containsTask(task));
	}

	@Test
	public void undoAddedDeadlineTask() {
		DateTime dateTime = new DateTime();
		addCommand = new AddTaskCommand("hello", dateTime);
		addCommand.execute(logic);

		Task task = getMostRecentTask();

		// make sure task is inside taskManager
		assertTrue(logic.containsTask(task));

		addCommand.undo(logic);
		assertFalse(logic.containsTask(task));
	}

	@Test
	public void undoAddedEventTask() {
		DateTime dateTimeStart = new DateTime();
		DateTime dateTimeEnd = new DateTime();
		addCommand = new AddTaskCommand("hello", dateTimeStart, dateTimeEnd);
		addCommand.execute(logic);

		Task task = getMostRecentTask();

		// make sure task is inside taskManager
		assertTrue(logic.containsTask(task));

		addCommand.undo(logic);
		assertFalse(logic.containsTask(task));
	}

	private Task getMostRecentTask() {
		TaskManager manager = logic.getTaskManager();
		Task task = manager.getMostRecentTask();

		return task;
	}
}
```
###### test\dooyit\logic\commands\DeleteCommandTest.java
``` java
package dooyit.logic.commands;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.util.ArrayList;

import org.junit.Before;
import org.junit.Test;
import org.powermock.reflect.Whitebox;

import dooyit.common.datatype.DateTime;
import dooyit.common.datatype.DeadlineTask;
import dooyit.common.datatype.EventTask;
import dooyit.common.datatype.FloatingTask;
import dooyit.common.datatype.Task;
import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.api.Action;
import dooyit.logic.api.LogicAction;
import dooyit.logic.api.LogicController;

public class DeleteCommandTest {

	private static final String ACTION = "action";

	LogicController logic;
	DeleteTaskCommand deleteCommand;

	Task floatingTask1;
	Task floatingTask2;
	Task deadlineTask;
	Task eventTask;
	Task floatingTask3;

	@Before
	public void setUp() {
		logic = new LogicController();
		logic.disableSave();
		logic.clearTasks();
	}

	public void setUpTask() {
		logic.clearTasks();

		DateTime dateTimeDeadline = new DateTime();
		DateTime dateTimeStart = new DateTime();
		DateTime dateTimeEnd = new DateTime();

		floatingTask1 = new FloatingTask("hello");
		floatingTask2 = new FloatingTask("go");
		floatingTask3 = new FloatingTask("water");
		deadlineTask = new DeadlineTask("car", dateTimeDeadline);
		eventTask = new EventTask("house", dateTimeStart, dateTimeEnd);

		logic.addTask(floatingTask1);
		logic.addTask(floatingTask2);
		logic.addTask(deadlineTask);
		logic.addTask(eventTask);
		logic.addTask(floatingTask3);
	}

	@Test
	public void executeSingleDeleteOfFloatingTask() {
		setUpTask();

		// make sure task1 is inside task manager
		assertTrue(logic.containsTask(floatingTask1));

		// delete task1
		deleteCommand = new DeleteTaskCommand(floatingTask1.getDisplayId());
		deleteCommand.execute(logic);
		// try to find task1
		assertFalse(logic.containsTask(floatingTask1));

		// tasks left in taskManager: task2, task3, task4, task5
		// make sure task2 task3, task 4, task 5 is still inside task manager
		// after deletion
		assertTrue(logic.containsTask(floatingTask2));
		assertTrue(logic.containsTask(floatingTask3));
		assertTrue(logic.containsTask(deadlineTask));
		assertTrue(logic.containsTask(eventTask));
	}

	@Test
	public void executeSingleDeleteOfDeadlineTask() {
		setUpTask();

		// make sure task1 is inside task manager
		assertTrue(logic.containsTask(deadlineTask));

		// delete task1
		deleteCommand = new DeleteTaskCommand(deadlineTask.getDisplayId());
		deleteCommand.execute(logic);
		// try to find task1
		assertFalse(logic.containsTask(deadlineTask));

		// tasks left in taskManager: task2, task3, task4, task5
		// make sure task2 task3, task 4, task 5 is still inside task manager
		// after deletion
		assertTrue(logic.containsTask(floatingTask1));
		assertTrue(logic.containsTask(floatingTask2));
		assertTrue(logic.containsTask(floatingTask3));
		assertTrue(logic.containsTask(eventTask));
	}

	@Test
	public void executeSingleDeleteOfEventTask() {
		setUpTask();

		// make sure task1 is inside task manager
		assertTrue(logic.containsTask(eventTask));

		// delete task1
		deleteCommand = new DeleteTaskCommand(eventTask.getDisplayId());
		deleteCommand.execute(logic);
		// try to find task1
		assertFalse(logic.containsTask(eventTask));

		// tasks left in taskManager: task2, task3, task4, task5
		// make sure task2 task3, task 4, task 5 is still inside task manager
		// after deletion
		assertTrue(logic.containsTask(floatingTask1));
		assertTrue(logic.containsTask(floatingTask2));
		assertTrue(logic.containsTask(floatingTask3));
		assertTrue(logic.containsTask(deadlineTask));
	}

	@Test
	public void executeBatchDelete() {
		setUpTask();

		// delete tasks in batch using 1 command
		ArrayList<Integer> deleteIds = new ArrayList<Integer>();
		deleteIds.add(floatingTask2.getDisplayId());
		deleteIds.add(deadlineTask.getDisplayId());
		deleteIds.add(eventTask.getDisplayId());

		// delete task1
		deleteCommand = new DeleteTaskCommand(deleteIds);
		deleteCommand.execute(logic);

		// try to find task2, task3, task4
		assertFalse(logic.containsTask(floatingTask2));
		assertFalse(logic.containsTask(deadlineTask));
		assertFalse(logic.containsTask(eventTask));

		// make sure task5 is still inside taskManager
		assertTrue(logic.containsTask(floatingTask1));
		assertTrue(logic.containsTask(floatingTask3));
	}

	// boundary case for negative partition
	@Test
	public void executeExceptionHandlingNegative() throws IncorrectInputException {
		setUpTask();
		int invalidTaskId;

		// delete taskId -1
		invalidTaskId = -1;
		// try to find invalid task
		assertFalse(logic.containsTask(invalidTaskId));

		deleteCommand = new DeleteTaskCommand(invalidTaskId);
		LogicAction logicAction = deleteCommand.execute(logic);
		Action action = Whitebox.getInternalState(logicAction, ACTION);
		assertEquals(Action.ERROR, action);
	}

	// boundary case for positive partition
	@Test
	public void executeExceptionHandlingPositive() throws IncorrectInputException {
		setUpTask();
		int invalidTaskId;

		// delete taskId 100
		invalidTaskId = 100;
		// try to find invalid task
		assertFalse(logic.containsTask(invalidTaskId));

		deleteCommand = new DeleteTaskCommand(invalidTaskId);
		LogicAction logicAction = deleteCommand.execute(logic);
		Action action = Whitebox.getInternalState(logicAction, ACTION);
		assertEquals(Action.ERROR, action);

	}

	@Test
	public void undoDeletedFloatingTask() {
		setUpTask();

		// make sure task1 is inside taskManager
		assertTrue(logic.containsTask(floatingTask1));

		deleteCommand = new DeleteTaskCommand(floatingTask1.getDisplayId());
		deleteCommand.execute(logic);

		// make sure task1 is deleted
		assertFalse(logic.containsTask(floatingTask1));

		deleteCommand.undo(logic);
		// make sure task1 is inside taskManager
		assertTrue(logic.containsTask(floatingTask1));
	}

	@Test
	public void undoDeletedDeadlineTask() {
		setUpTask();

		// make sure task1 is inside taskManager
		assertTrue(logic.containsTask(deadlineTask));

		deleteCommand = new DeleteTaskCommand(deadlineTask.getDisplayId());
		deleteCommand.execute(logic);

		// make sure task1 is deleted
		assertFalse(logic.containsTask(deadlineTask));

		deleteCommand.undo(logic);
		// make sure task1 is inside taskManager
		assertTrue(logic.containsTask(deadlineTask));
	}

	@Test
	public void undoDeletedEventTask() {
		setUpTask();

		// make sure task1 is inside taskManager
		assertTrue(logic.containsTask(eventTask));

		deleteCommand = new DeleteTaskCommand(eventTask.getDisplayId());
		deleteCommand.execute(logic);

		// make sure task1 is deleted
		assertFalse(logic.containsTask(eventTask));

		deleteCommand.undo(logic);
		// make sure task1 is inside taskManager
		assertTrue(logic.containsTask(eventTask));
	}

	@Test
	public void undoBatchDelete() {
		setUpTask();

		// delete tasks in batch using 1 command
		ArrayList<Integer> deleteIds = new ArrayList<Integer>();
		deleteIds.add(floatingTask2.getDisplayId());
		deleteIds.add(deadlineTask.getDisplayId());
		deleteIds.add(eventTask.getDisplayId());

		// delete task1
		deleteCommand = new DeleteTaskCommand(deleteIds);
		deleteCommand.execute(logic);

		// try to find task2, task3, task4
		assertFalse(logic.containsTask(floatingTask2));
		assertFalse(logic.containsTask(deadlineTask));
		assertFalse(logic.containsTask(eventTask));

		deleteCommand.undo(logic);
		// try to find task2, task3, task4
		assertTrue(logic.containsTask(floatingTask2));
		assertTrue(logic.containsTask(deadlineTask));
		assertTrue(logic.containsTask(eventTask));
	}

}
```
###### test\dooyit\logic\commands\LogicCommandTestSuite.java
``` java
package dooyit.logic.commands;

import org.junit.runner.RunWith;
import org.junit.runners.Suite;

@RunWith(Suite.class)
@Suite.SuiteClasses({ AddCommandTest.class, DeleteCommandTest.class, SearchCommandTest.class,
		AddCategoryCommandTest.class, DeleteCategoryCommandTest.class, SetCategoryCommandTest.class,
		ShowCommandTest.class })

public class LogicCommandTestSuite {

}
```
###### test\dooyit\logic\LogicTestSuite.java
``` java
package dooyit.logic;

import org.junit.runner.RunWith;
import org.junit.runners.Suite;

@RunWith(Suite.class)
@Suite.SuiteClasses({ TaskManagerTest.class, CategoryManagerTest.class })

public class LogicTestSuite {

}
```
###### test\dooyit\logic\TaskManagerTest.java
``` java
package dooyit.logic;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.util.ArrayList;

import org.junit.Before;
import org.junit.Test;

import dooyit.common.datatype.Category;
import dooyit.common.datatype.CustomColour;
import dooyit.common.datatype.DateTime;
import dooyit.common.datatype.DeadlineTask;
import dooyit.common.datatype.EventTask;
import dooyit.common.datatype.FloatingTask;
import dooyit.common.datatype.Task;
import dooyit.logic.api.LogicController;
import dooyit.logic.api.TaskManager;

public class TaskManagerTest {

	LogicController logicController;
	TaskManager taskManager;

	Task task1;
	Task task2;
	Task task3;
	Task task4;
	Task task5;
	Task task6;

	@Before
	public void setUp() {
		logicController = new LogicController();
		logicController.disableSave();
		logicController.clearTasks();

		taskManager = logicController.getTaskManager();
	}

	public void setupTasks() {
		taskManager.clear();

		DateTime dateTimeStart = new DateTime();
		DateTime dateTimeEnd = new DateTime();
		DateTime deadline = new DateTime();

		task1 = taskManager.addEventTask("hello", dateTimeStart, dateTimeEnd);
		task2 = taskManager.addFloatingTask("buy milk");
		task3 = taskManager.addDeadlineTask("goodbye", deadline, true);
		task4 = taskManager.addEventTask("driving lesson", dateTimeStart, dateTimeEnd, true);
		task5 = taskManager.addFloatingTask("Get oreos", true);
		task6 = taskManager.addDeadlineTask("hahaha", deadline);

	}

	@Test
	public void addTaskTest() {
		taskManager.clear();

		Task task1 = new FloatingTask("hi");
		taskManager.add(task1);
		assertTrue(taskManager.contains(task1));
	}

	@Test
	public void findAndContainTest() {
		taskManager.clear();

		DateTime dateTimeDeadline = new DateTime();
		DateTime dateTimeStart = new DateTime();
		DateTime dateTimeEnd = new DateTime();

		Task task1 = new FloatingTask("hi");
		Task task2 = new DeadlineTask("hello", dateTimeDeadline);
		Task task3 = new EventTask("car", dateTimeStart, dateTimeEnd);
		Task task4 = new EventTask("house", dateTimeStart, dateTimeEnd);

		taskManager.add(task1);
		taskManager.add(task2);
		taskManager.add(task3);

		assertFalse(taskManager.contains(task4));
		assertTrue(taskManager.find(task4) == null);

		assertTrue(taskManager.contains(task1.getDisplayId()));
		assertTrue(taskManager.contains(task1));
		assertTrue(taskManager.find(task1.getDisplayId()).equals(task1));
		assertTrue(taskManager.find(task1).equals(task1));

		assertTrue(taskManager.contains(task2.getDisplayId()));
		assertTrue(taskManager.contains(task2));
		assertTrue(taskManager.find(task2.getDisplayId()).equals(task2));
		assertTrue(taskManager.find(task2).equals(task2));

		assertTrue(taskManager.contains(task3.getDisplayId()));
		assertTrue(taskManager.contains(task3));
		assertTrue(taskManager.find(task3.getDisplayId()).equals(task3));
		assertTrue(taskManager.find(task3).equals(task3));

		assertFalse(taskManager.contains(task4));
		assertTrue(taskManager.find(task4) == null);
	}

	@Test
	public void removeTaskTest() {
		taskManager.clear();
		boolean removeSuccessful;

		Task task1 = new FloatingTask("hi");
		removeSuccessful = taskManager.remove(task1);
		assertFalse(removeSuccessful);

		taskManager.add(task1);
		removeSuccessful = taskManager.remove(task1);
		assertTrue(removeSuccessful);
		assertFalse(taskManager.contains(task1));
	}

	@Test
	public void loadTaskTest() {
		taskManager.clear();

		DateTime dateTimeDeadline = new DateTime();
		DateTime dateTimeStart = new DateTime();
		DateTime dateTimeEnd = new DateTime();

		Task task1 = new FloatingTask("hi");
		Task task2 = new DeadlineTask("hello", dateTimeDeadline);
		Task task3 = new EventTask("car", dateTimeStart, dateTimeEnd);

		ArrayList<Task> tasks = new ArrayList<Task>();
		tasks.add(task1);
		tasks.add(task2);
		tasks.add(task3);

		taskManager.load(tasks);

		assertTrue(taskManager.contains(task1));
		assertTrue(taskManager.contains(task2));
		assertTrue(taskManager.contains(task3));
	}

	@Test
	public void addFloatingTaskTest() {
		taskManager.clear();

		Task task1 = taskManager.addFloatingTask("hello");
		assertTrue(!task1.isCompleted());
		assertTrue(taskManager.contains(task1));
		assertTrue(task1 instanceof FloatingTask);

		Task task2 = taskManager.addFloatingTask("hello", true);
		assertTrue(task2.isCompleted());
		assertTrue(taskManager.contains(task2));
		assertTrue(task2 instanceof FloatingTask);
	}

	@Test
	public void addDeadlineTaskTest() {
		taskManager.clear();

		DateTime dateTime = new DateTime();

		Task task1 = taskManager.addDeadlineTask("hello", dateTime);
		assertTrue(!task1.isCompleted());
		assertTrue(taskManager.contains(task1));
		assertTrue(task1 instanceof DeadlineTask);

		Task task2 = taskManager.addDeadlineTask("hello", dateTime, true);
		assertTrue(task2.isCompleted());
		assertTrue(taskManager.contains(task2));
		assertTrue(task2 instanceof DeadlineTask);
	}

	@Test
	public void addEventTaskTest() {
		taskManager.clear();

		DateTime dateTimeStart = new DateTime();
		DateTime dateTimeEnd = new DateTime();

		Task task1 = taskManager.addEventTask("hello", dateTimeStart, dateTimeEnd);
		assertTrue(!task1.isCompleted());
		assertTrue(taskManager.contains(task1));
		assertTrue(task1 instanceof EventTask);

		Task task2 = taskManager.addEventTask("hello", dateTimeStart, dateTimeEnd, true);
		assertTrue(task2.isCompleted());
		assertTrue(taskManager.contains(task2));
		assertTrue(task2 instanceof EventTask);
	}

```
###### test\IntegrationTestSuite.java
``` java
import org.junit.runner.RunWith;
import org.junit.runners.Suite;

@RunWith(Suite.class)
@Suite.SuiteClasses({ IntegrationTest.class })

public class IntegrationTestSuite {

}
```
