# A0133338J
###### src\dooyit\common\datatype\DateTime.java
``` java
public class DateTime {
	private static final String FORMAT_SPACE = " ";
	private static final String TWELVE = "12";
	private static final String TIME_SEPARATOR_COLON = ":";
	private static final String TIME_SEPARATOR_DOT = ".";
	private static final String TWELVE_MIDNIGHT = "12 am";
	private static final String PM = " pm";
	private static final String AM = " am";
	private static final String DUMMY_STR = "Dummy_Str";
	private static final String ONE_ZERO = "0";
	private static final String CALENDAR_DATE_FORMAT = "dd MM yyyy HH:mm E u";
	private static final String CALENDAR_DEFAULT_TIME_ZONE = "UTC+08:00"; // Singapore Time Zone
	
	private static final String UNINITIALIZED_STRING = "-1";
	private static final int UNINITIALIZED_INT = -1;
	
	private static final int INDEX_DD = 0;
	private static final int INDEX_MM = 1;
	private static final int INDEX_YY = 2;
	private static final int INDEX_TIME_INT = 3;
	private static final int INDEX_DAY_INT = 5;
	private static final int COMPARISON_FIRST_IS_BEFORE_SECOND = -1;
	private static final int COMPARISON_FIRST_EQUALS_SECOND = 0;
	private static final int COMPARISON_FIRST_IS_AFTER_SECOND = 1;
	private static final int NUM_MONTHS_IN_A_YEAR = 12;
	private static final int NUM_DAYS_IN_A_WEEK = 7;
	private static final int FORMAT_24H_12AM = 0;
	private static final int FORMAT_24H_12PM = 1200;
	private static final int FORMAT_24H_10AM = 1000;
	private static final int FORMAT_24H_1AM = 100;
	
	private static String[] months = new String[] { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };
	private static String[] daysInWeek = new String[] { DUMMY_STR, "mon", "tue", "wed", "thu", "fri", "sat", "sun" };
	private static int[] daysInMonth = new int[] { UNINITIALIZED_INT, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

	private String date; // 8 March 2016
	private String timeStr24H; // 1300
	private String timeStr12H; // 1 pm, 2 am, 3.30 am
	private String dayStr; // Mon
	private int dayInt; // 1
	private int dd; // 8
	private int mm;
	private int yy; // 2016
	private int timeInt;

	public DateTime(DateTime dt) {
		this.dd = dt.getDD();
		this.mm = dt.getMM();
		this.yy = dt.getYY();
		this.timeInt = dt.getTimeInt();
		this.timeStr12H = dt.getTime12hStr();
		this.timeStr24H = dt.getTime24hStr();
		this.dayStr = dt.getDayStr();
		this.dayInt = setDayInt(this.dayStr);
		this.date = this.dd + FORMAT_SPACE + months[decrementByOne(this.mm)] + FORMAT_SPACE + this.yy;
	}

	private int decrementByOne(int number) {
		return number - 1;
	}

	public DateTime(int[] date, String day, int time) {
		this.dd = date[INDEX_DD];
		this.mm = date[INDEX_MM];
		this.yy = date[INDEX_YY];
		this.timeInt = time;
		this.timeStr24H = convertTimeIntTo24hString(time);
		this.timeStr12H = convertTimeIntTo12hString(time);
		this.dayStr = day;
		
		this.dayInt = setDayInt(dayStr);
		this.date = this.dd + FORMAT_SPACE + months[decrementByOne(this.mm)] + FORMAT_SPACE + this.yy;
	}

	public DateTime() {
		Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(CALENDAR_DEFAULT_TIME_ZONE));
		DateFormat dateFormat = new SimpleDateFormat(CALENDAR_DATE_FORMAT);

		String date = dateFormat.format(cal.getTime());
		String[] splitDate = date.split("\\s+");

		this.dd = Integer.parseInt(splitDate[INDEX_DD]);
		this.mm = Integer.parseInt(splitDate[INDEX_MM]);
		this.yy = Integer.parseInt(splitDate[INDEX_YY]);
		this.timeInt = Integer.parseInt(splitDate[INDEX_TIME_INT].replace(TIME_SEPARATOR_COLON, ""));
		this.dayInt = Integer.parseInt(splitDate[INDEX_DAY_INT]);
		this.dayStr = daysInWeek[this.dayInt];
		this.timeStr24H = convertTimeIntTo24hString(this.timeInt);
		this.timeStr12H = convertTimeIntTo12hString(this.timeInt);
		this.date = this.dd + FORMAT_SPACE + months[decrementByOne(this.mm)] + FORMAT_SPACE + this.yy;
	}

	public DateTime(int[] date, String day) {
		this.dd = date[INDEX_DD];
		this.mm = date[INDEX_MM];
		this.yy = date[INDEX_YY];
		this.timeStr24H = String.valueOf(UNINITIALIZED_INT);
		this.timeStr12H = String.valueOf(UNINITIALIZED_INT);
		this.dayStr = day;
		this.dayInt = setDayInt(dayStr);
		this.date = this.dd + FORMAT_SPACE + months[decrementByOne(this.mm)] + FORMAT_SPACE + this.yy;
	}

	public DateTime(int dd, int mm, int yy, String day, String time) throws NumberFormatException {
		this.dd = dd;
		this.mm = mm;
		this.yy = yy;
		try {
			this.timeInt = Integer.parseInt(time);
			this.timeStr24H = time;
			this.timeStr12H = convertTimeIntTo12hString(Integer.parseInt(time));
		} catch (NumberFormatException e) {
			System.out.println("Error: time is " + time);
			System.out.println(e.getMessage());
			this.timeInt = UNINITIALIZED_INT;
			this.timeStr24H = UNINITIALIZED_STRING;
			this.timeStr12H = UNINITIALIZED_STRING;
		}
		this.dayStr = day;
		this.dayInt = setDayInt(dayStr);
		this.date = this.dd + FORMAT_SPACE + months[decrementByOne(this.mm)] + FORMAT_SPACE + this.yy;
	}

	public DateTime(String[] split, String day, int time2) {
		this.dd = Integer.parseInt(split[INDEX_DD]);
		this.mm = Integer.parseInt(split[INDEX_MM]);
		this.yy = Integer.parseInt(split[INDEX_YY]);
		this.timeStr24H = convertTimeIntTo24hString(time2);
		this.timeStr12H = convertTimeIntTo12hString(time2);
		this.dayStr = day;
		this.dayInt = setDayInt(dayStr);
		this.date = this.dd + FORMAT_SPACE + months[decrementByOne(this.mm)] + FORMAT_SPACE + this.yy;
	}
	
	// Returns 0 if this DateTime object has the same date and time as the DateTime object passed in as argument
	// Returns 1 if this DateTime object lies after DateTime object passed in as argument
	// Returns -1 if this DateTime object lies before DateTime object passed in as argument
	public int compareTo(DateTime dateTime) {
		int comparison = COMPARISON_FIRST_EQUALS_SECOND;
		if(!this.equals(dateTime)) {
			int dateComparison = compareDates(this, dateTime);
			int timeComparison = compareTime(this, dateTime);
			comparison = getComparison(dateComparison, timeComparison);
		}
		return comparison;
	}
	
	private int getComparison(int dateComparison, int timeComparison) {
		int comparison;
		if(dateComparison != 0) {
			comparison = dateComparison;
		} else {
			comparison = timeComparison;
		}
		return comparison;
	}

	private int compareTime(DateTime first, DateTime second) {
		int comparison = COMPARISON_FIRST_EQUALS_SECOND;
		int firstTimeInt = first.getTimeInt();
		int secondTimeInt = second.getTimeInt();
		if(firstTimeInt != secondTimeInt) {
			if(firstTimeInt < secondTimeInt) {
				comparison = COMPARISON_FIRST_IS_BEFORE_SECOND;
			} else {
				comparison = COMPARISON_FIRST_IS_AFTER_SECOND;
			}
		}
		return comparison;
	}

	private int compareDates(DateTime first, DateTime second) {
		boolean isSameDate = compareDateStrings(first, second);
		int yearComparison = compareYear(first, second);
		int monthComparison = compareMonth(first, second);
		int dayComparison = compareDay(first, second);
		
		int comparison = COMPARISON_FIRST_EQUALS_SECOND;
		
		if(!isSameDate) {
			comparison = compareYearMonthDay(yearComparison, monthComparison, dayComparison);
		}
		
		return comparison;
			
	}
	private int compareYearMonthDay(int yearComparison, int monthComparison, int dayComparison) {
		int comparison;
		if(isSameYear(yearComparison)) {
			comparison = compareMonthDay(monthComparison, dayComparison);
		} else {
			comparison = yearComparison;
		}
		return comparison;
	}

	private int compareMonthDay(int monthComparison, int dayComparison) {
		int comparison;
		if(isSameMonth(monthComparison)) {
			comparison = dayComparison;
		} else {
			comparison = monthComparison;
		}
		return comparison;
	}

	private boolean isSameMonth(int monthComparison) {
		return monthComparison == COMPARISON_FIRST_EQUALS_SECOND;
	}

	private boolean isSameYear(int yearComparison) {
		return yearComparison == COMPARISON_FIRST_EQUALS_SECOND;
	}
	

	private int compareDay(DateTime first, DateTime second) {
		int comparison = COMPARISON_FIRST_EQUALS_SECOND;
		int firstDD = first.getDD();
		int secondDD = second.getDD();
		if(firstDD != secondDD) {
			if(firstDD < secondDD) {
				comparison = COMPARISON_FIRST_IS_BEFORE_SECOND;
			} else {
				comparison = COMPARISON_FIRST_IS_AFTER_SECOND;
			}
		}
		return comparison;
	}

	private int compareMonth(DateTime first, DateTime second) {
		int comparison = COMPARISON_FIRST_EQUALS_SECOND;
		int firstMM = first.getMM();
		int secondMM = second.getMM();
		if(firstMM != secondMM) {
			if(firstMM < secondMM) {
				comparison = COMPARISON_FIRST_IS_BEFORE_SECOND;
			} else {
				comparison = COMPARISON_FIRST_IS_AFTER_SECOND;
			}
		}
		return comparison;
	}

	private int compareYear(DateTime first, DateTime second) {
		int comparison = COMPARISON_FIRST_EQUALS_SECOND;
		int firstYY = first.getYY();
		int secondYY = second.getYY();
		if(firstYY != secondYY) {
			if(firstYY < secondYY) {
				comparison = COMPARISON_FIRST_IS_BEFORE_SECOND;
			} else {
				comparison = COMPARISON_FIRST_IS_AFTER_SECOND;
			}
		}
		return comparison;
	}

	private boolean compareDateStrings(DateTime first, DateTime second) {
		return first.getDate().equals(second.getDate());
	}

	public boolean equals(DateTime dateTime) {
		boolean hasEqualDateString = this.getDate().equals(dateTime.getDate());
		boolean hasEqualTimeStr24H = this.getTime24hStr().equals(dateTime.getTime24hStr());
		boolean hasEqualTimeStr12H = this.getTime12hStr().equals(dateTime.getTime12hStr());
		boolean hasEqualDayStr = this.getDayStr().equals(dateTime.getDayStr());
		boolean hasEqualDayInt = this.getDayInt() == dateTime.getDayInt();
		return hasEqualDateString && hasEqualTimeStr24H && hasEqualTimeStr12H && hasEqualDayStr && hasEqualDayInt;
	}
	
	private int setDayInt(String str) {
		int ans = UNINITIALIZED_INT;
		for (int i = 0; i < daysInWeek.length; i++) {
			if (str.equals(daysInWeek[i])) {
				ans = i;
				break;
			}
		}
		return ans;
	}

	// Converts the 24h time int to 12h String format
	private String convertTimeIntTo12hString(int time) {
		String timeString12H;
		if (isUninitialized(time)) {
			timeString12H = UNINITIALIZED_STRING;
		} else if (isMidnight(time)) {
			timeString12H = TWELVE_MIDNIGHT;
		} else if (isAfter12amAndBefore1am(time)) {
			timeString12H = TWELVE + TIME_SEPARATOR_DOT + time + AM;
		} else if (isAfter1amAndBefor12pm(time)) {
			if (timeHasNoMinutes(time)) { // 12 am etc
				timeString12H = getHourNumeralIn12HStringForMorningTiming(time) + AM;
			} else { // 12.30 am etc
				timeString12H = getHourNumeralIn12HStringForMorningTiming(time) + TIME_SEPARATOR_DOT + getMinutesNumeral(time) + AM;
			}
		} else {
			if (timeHasNoMinutes(time)) { // 12 pm etc
				timeString12H = getHourNumberalIn12HStringForAfternoonTiming(time) + PM;
			} else { // 12.30 pm etc
				if (timeHasLessThanTenMinutes(time)) {
					timeString12H = getHourNumberalIn12HStringForAfternoonTiming(time) + TIME_SEPARATOR_DOT + ONE_ZERO + getMinutesNumeral(time) + PM;
				} else {
					timeString12H = getHourNumberalIn12HStringForAfternoonTiming(time) + TIME_SEPARATOR_DOT + getMinutesNumeral(time) + PM;
				}
			}
		}
		return timeString12H;
	}

	private int getHourNumeralIn12HStringForMorningTiming(int time) {
		return getHourNumeral(time);
	}

	private int getHourNumberalIn12HStringForAfternoonTiming(int time) {
		return getHourNumeral(time - FORMAT_24H_12PM);
	}

	private int getHourNumeral(int time) {
		return time / 100;
	}

	private boolean timeHasLessThanTenMinutes(int time) {
		return getMinutesNumeral(time) < 10;
	}

	private boolean timeHasNoMinutes(int time) {
		return getMinutesNumeral(time) == 0;
	}

	private int getMinutesNumeral(int time) {
		return time % 100;
	}

	private boolean isUninitialized(int time) {
		return time == UNINITIALIZED_INT;
	}

	private boolean isAfter1amAndBefor12pm(int time) {
		return time > FORMAT_24H_1AM && time < FORMAT_24H_12PM;
	}

	private boolean isAfter12amAndBefore1am(int time) {
		return time < FORMAT_24H_1AM && time > FORMAT_24H_12AM;
	}

	private boolean isMidnight(int time) {
		return time == FORMAT_24H_12AM;
	}

	// Converts the 24h time int to 24h String format
	private String convertTimeIntTo24hString(int time) {
		String timeString24H;
		if (isUninitialized(time)) {
			timeString24H = UNINITIALIZED_STRING;
		} else if (isMidnight(time)) {
			timeString24H = "0000";
		} else if (isAfter12amAndBefore1am(time)) {
			timeString24H = "00" + time;
		} else if (isAfter1amAndBefore10am(time)) {
			timeString24H = "0" + time;
		} else {
			timeString24H = String.valueOf(time);
		}
		return timeString24H;
	}

	private boolean isAfter1amAndBefore10am(int time) {
		return time > FORMAT_24H_1AM && time < FORMAT_24H_10AM;
	}

	public String getDayStr() {
		return this.dayStr;
	}

	public int getDayInt() {
		return this.dayInt;
	}

	public String getDate() {
		return this.date;
	}

	public String getTime24hStr() {
		return this.timeStr24H;
	}

	public String getTime12hStr() {
		return this.timeStr12H;
	}

	public int getTimeInt() {
		return this.timeInt;
	}

	public int getDD() {
		return this.dd;
	}

	public int getMM() {
		return this.mm;
	}

	public int getYY() {
		return this.yy;
	}

	public String toString() {
		String ans = this.date + FORMAT_SPACE + this.dayStr + FORMAT_SPACE + this.timeStr24H + FORMAT_SPACE + this.timeStr12H;
		return ans;
	}

	public boolean hasTime() {
		return this.getTimeInt() != UNINITIALIZED_INT;
	}

	public boolean isTheSameDateAs(DateTime obj) {
		return this.getDD() == obj.getDD() && this.getMM() == obj.getMM() && this.getYY() == obj.getYY();
	}

	public void increaseByOne() {
		this.dd += 1;
		if (this.dd > daysInMonth[this.mm]) {
			this.dd = 1;
			this.mm += 1;
		}
		if (this.mm > NUM_MONTHS_IN_A_YEAR) {
			this.mm = 1;
			this.yy += 1;
		}
		this.dayInt = increaseDayIntByOne();
		this.dayStr = daysInWeek[this.dayInt];
		this.date = this.dd + FORMAT_SPACE + months[decrementByOne(this.mm)] + FORMAT_SPACE + this.yy;
	}

	private int increaseDayIntByOne() {
		if (this.dayInt == NUM_DAYS_IN_A_WEEK) {
			return 1;
		} else {
			this.dayInt += 1;
			return this.dayInt;
		}
	}

	public String convertToSavableString() {
		String dateTimeString = "";
		dateTimeString += String.valueOf(dd) + FORMAT_SPACE;
		dateTimeString += String.valueOf(mm) + FORMAT_SPACE;
		dateTimeString += String.valueOf(yy) + FORMAT_SPACE;
		dateTimeString += dayStr + FORMAT_SPACE;
		dateTimeString += timeStr24H;

		return dateTimeString;
	}

}
```
###### src\dooyit\parser\AddCategoryParser.java
``` java
public class AddCategoryParser extends TagParser{
	
	private static String userInput;
	private static String catName;
	private static String catColour;
	private static final String DEFAULT_COLOUR = "";
	
	private static Command command;
	
	private static final int INDEX_NAME = 0;
	private static final int INDEX_COLOUR = 1;

	private static boolean hasTasks;
	private static boolean hasColour;
	
	enum ADD_CATEGORY_TYPE {
		CREATE_NEW_CATEGORY_WITHOUT_TASKS, CREATE_NEW_CATEGORY_WITH_TASKS, INVALID
	};

	public AddCategoryParser() {
		super();
	}

	public Command getCommand(String input) {
		resetVariables(input);
		parse();
		
		switch (getCommandType()) {
		case CREATE_NEW_CATEGORY_WITHOUT_TASKS:
			setCommandToCreateCategoryWithoutTasks();
			break;

		case CREATE_NEW_CATEGORY_WITH_TASKS:
			getTaskIds();
			setCommandToCreateCategoryWithTasks();
			break;

		default:
			command = CommandUtils.createInvalidCommand(userInput + " is an invalid addcat command!");
			break;
		}

		return command;
	}

	private void resetVariables(String input) {
		userInput = input;
		catColour = DEFAULT_COLOUR;
		hasTasks = false;
		hasColour = false;
	}

	private void setCommandToCreateCategoryWithTasks() {
		try {
			parseTaskIds();
		} catch (IncorrectInputException e) {
			command = getInvalidCommand(e.getMessage());
		}
		
		if(command == null) {
			setCorrectCategoryWithTasksCommand(getTagType());
		}
	}
	
	private void setCorrectCategoryWithTasksCommand(TAG_TYPE tagType) {
		switch (tagType) {
		case SINGLE:
			setCreateCategoryWithOneTaskCommand();
			break;

		case MULTIPLE:
			setCreateCategoryWithManyTasksCommand();
			break;

		case INTERVAL:
			setCreateCategoryWithManyTasksCommand();
			break;

		default:
			setInvalidCmd();
			break;
		}
	}

	private void setCreateCategoryWithOneTaskCommand() {
		if(hasColour) {
			//command = CommandUtils.createAddCategoryCommand(catName, catColour, taskIdsForTagging);
		} else {
			//command = CommandUtils.createAddCatergoryCommand(catName, taskIdsForTagging); 
		}
	}

	private void setCreateCategoryWithManyTasksCommand() {
		if(hasColour) {
			//command = CommandUtils.createAddCategoryCommand(catName, catColour, taskIdForTagging);
		} else {
			//command = CommandUtils.createAddCatergoryCommand(catName, taskIdForTagging); 
		}
	}

	private void setInvalidCmd() {
		command = CommandUtils.createInvalidCommand("Invalid Add Category Command!");
	}
	
	private void getTaskIds() {
		if(hasColour) {
			int indexOfTaskIds = userInput.indexOf(catColour) + catColour.length();
			String taskIdString = userInput.substring(indexOfTaskIds).trim();
			setVariables(taskIdString);
		} else {
			int indexOfTaskIds = userInput.indexOf(catName) + catName.length();
			String taskIdString = userInput.substring(indexOfTaskIds).trim();
			setVariables(taskIdString);
		}
	}

	private ADD_CATEGORY_TYPE getCommandType() {
		if(userInput.equals("")) {
			return ADD_CATEGORY_TYPE.INVALID;
		} else if(hasTasks) {
			return ADD_CATEGORY_TYPE.CREATE_NEW_CATEGORY_WITH_TASKS;
		} else {
			return ADD_CATEGORY_TYPE.CREATE_NEW_CATEGORY_WITHOUT_TASKS;
		} 
	}

	private void setCommandToCreateCategoryWithoutTasks() {
		if(hasColour) {
			command = CommandUtils.createAddCategoryCommand(catName, catColour);
		} else { 
			command = CommandUtils.createAddCategoryCommand(catName);
		}
	}

	private void parse() {
		String[] inputArr = userInput.split("\\s+");
		catName = inputArr[INDEX_NAME];
		if(!isOneWordInput(inputArr)) {
			catColour = inputArr[INDEX_COLOUR];
			hasColour = !isNumber(catColour);
		}
		
		for(int i = INDEX_COLOUR; i < inputArr.length; i++) {
			if(isNumber(inputArr[i])) {
				hasTasks = true;
				break;
			}
		}
	}

	private boolean isOneWordInput(String[] inputArr) {
		return inputArr.length == 1;
	}
}
```
###### src\dooyit\parser\AddParser.java
``` java
public class AddParser {

	private static final String MARKER_START_EVENT = " from ";
	private static final String MARKER_END_EVENT = " to ";
	private static final String MARKER_WORK = " by ";
	private static final String MARKER_CATEGORY = " @ ";

	private static String userInput;
	private static String taskName;
	private static String categoryName;
	private static int categoryId;
	private static DateTime start;
	private static DateTime end;
	private static DateTime deadline;
	private static Command cmd;

	enum TASK_TYPE {
		FLOATING, WORK, EVENT, INVALID, CATEGORY_AND_EVENT, CATEGORY_AND_WORK, CATEGORY_AND_FLOATING
	};

	public AddParser() {
		
	}

	public Command getCommand(String input) throws IncorrectInputException {
		userInput = input.trim();
		System.out.println("reached add command");
		switch (getTaskType()) {
		case FLOATING:
			try {
				parseFloat();
			} catch (IncorrectInputException e) {
				setToInvalidCommand(e.getMessage());
				break;
			}
			setToFloatCommand();
			break;

		case WORK:
			try {
				parseWork();
			} catch (IncorrectInputException e) {
				setToInvalidCommand(e.getMessage());
				break;
			}
			setToWorkCommand();
			break;

		case EVENT:
			try {
				parseEvent();
			} catch (IncorrectInputException e) {
				setToInvalidCommand(e.getMessage());
				break;
			}
			setToEventCommand();
			break;

		case CATEGORY_AND_FLOATING:
			try {
				parseCategoryAndFloating();
			} catch (IncorrectInputException e) {
				setToInvalidCommand(e.getMessage());
				break;
			}
			setCategoryAndFloatingCommand();
			break;

		case CATEGORY_AND_WORK:
			try {
				parseCategoryAndWork();
			} catch (IncorrectInputException e) {
				setToInvalidCommand(e.getMessage());
				break;
			}
			setCategoryAndWorkCommand();
			break;

		case CATEGORY_AND_EVENT:
			try {
				parseCategoryAndEvent();
			} catch (IncorrectInputException e) {
				setToInvalidCommand(e.getMessage());
			}
			setCategoryAndEventCommand();
			break;

		case INVALID:
			setToInvalidCommand("Invalid input!");
		}

		return cmd;
	}

	private void parseCategoryAndFloating() {
		parseCategory();
		parseWork();
	}

	private void parseCategoryAndWork() {
		parseCategory();
		parseEvent();
	}

	private void parseCategoryAndEvent() {
		parseCategory();
		parseEvent();
	}

	private void parseCategory() {
		int indexCategory = userInput.lastIndexOf(MARKER_CATEGORY);
		String category = userInput.substring(indexCategory).replace(MARKER_CATEGORY, "").trim();
		if (isNumber(category)) {
			categoryId = Integer.parseInt(category);
		} else {
			categoryName = category;
		}
	}

	private boolean isNumber(String currWord) {
		return currWord.matches("[0-9]+");
	}

	private void setCategoryAndEventCommand() {
		// cmd = CommandUtils.createAddCommandCategory(taskName, start, end,
		// categoryId, categoryName);
	}

	private void setCategoryAndWorkCommand() {
		// cmd = CommandUtils.createAddCommandCategory(taskName, deadline,
		// categoryId, categoryName);
	}

	private void setCategoryAndFloatingCommand() {
		// cmd = CommandUtils.createAddCommandCategory(taskName, categoryId,
		// categoryName);
	}

	private void setToInvalidCommand(String message) {
		cmd = CommandUtils.createInvalidCommand(message);
	}

	private void setToEventCommand() {
		cmd = CommandUtils.createAddCommandEvent(taskName, start, end);
	}

	private void setToWorkCommand() {
		cmd = CommandUtils.createAddCommandDeadline(taskName, deadline);
	}

	private void setToFloatCommand() {
		cmd = CommandUtils.createAddCommandFloat(taskName);
	}

	private void parseEvent() {
		DateTimeParser dateTimeParser = new DateTimeParser();
		int indexFrom = userInput.lastIndexOf(MARKER_START_EVENT);
		int indexTo = userInput.lastIndexOf(MARKER_END_EVENT); // what if
																// indexTo <
																// indexFrom
		taskName = userInput.substring(0, indexFrom);
		start = dateTimeParser.parse((userInput.substring(indexFrom, indexTo).replace(MARKER_START_EVENT, "").trim()));
		end = dateTimeParser.parse((userInput.substring(indexTo).replace(MARKER_END_EVENT, "").trim()));
	}

	private void parseWork() {
		DateTimeParser dateTimeParser = new DateTimeParser();
		int indexBy = userInput.lastIndexOf(MARKER_WORK);
		taskName = userInput.substring(0, indexBy);
		deadline = dateTimeParser.parse((userInput.substring(indexBy).replace(MARKER_WORK, "").trim()));
	}

	private void parseFloat() {
		taskName = userInput;
	}

	private TASK_TYPE getTaskType() {
		if (isEvent()) {
			return TASK_TYPE.EVENT;
		} else if (isWork()) {
			return TASK_TYPE.WORK;
		} else if (isFloating()) {
			return TASK_TYPE.FLOATING;
		} else if (isCatAndEvent()) {
			return TASK_TYPE.CATEGORY_AND_EVENT;
		} else if (isCatAndWork()) {
			return TASK_TYPE.CATEGORY_AND_WORK;
		} else if (isCatAndFloating()) {
			return TASK_TYPE.CATEGORY_AND_FLOATING;
		} else {
			return TASK_TYPE.INVALID;
		}
	}

	private boolean isCat() {
		return userInput.lastIndexOf(MARKER_CATEGORY) != -1;
	}

	private boolean isCatAndFloating() {
		return isCat() && isFloating();
	}

	private boolean isCatAndWork() {
		return isCat() && isWork();
	}

	private boolean isCatAndEvent() {
		return isCatAndEvent();
	}

	private boolean isFloating() {
		return !userInput.equals("") && !isEvent() && !isWork();
	}

	private boolean isEvent() {
		return userInput.lastIndexOf(MARKER_START_EVENT) != -1 && userInput.lastIndexOf(MARKER_END_EVENT) != -1;
	}

	private boolean isWork() {
		return userInput.lastIndexOf(MARKER_WORK) != -1;
	}
}
```
###### src\dooyit\parser\DateTimeParser.java
``` java
public class DateTimeParser {
	
	private static final String ERROR_MESSAGE_MINUTES_EXCEED_SIXTY = "Invalid time! Minutes must be smaller than 60";
	private static final String ERROR_MESSAGE_TIME_EXCEEDS_24H = "Invalid Time! Time must not exceed 24 hours!";
	private static final String ERROR_MESSAGE_AM_AND_PM = " cannot be am and pm!";
	private static final String TWELVE_MIDNIGHT_ONE_STRING = "12am";
	private static final int FORMAT_24H_12PM = 1200;
	private static final String EMPTY_STRING = "";
	private static final String TIME_SEPARATOR_DOT = ".";
	private static final String TIME_SEPARATOR_COLON = ":";
	private static final int MAX_NUM_OF_DAYS_IN_A_MONTH = 31;
	private static final String PM = "pm";
	private static final String AM = "am";
	private static final String DATE_SEPARATOR = "/";
	private static final int TWELVE_HOURS = 1200;
	private static final int NUMBER_OF_DAYS_IN_WEEK = 7;
	private static final int NEXT_DAY = 1;

	private static final int COMBINED_INDEX_DAY_OF_WEEK = 0;
	private static final int COMBINED_INDEX_TIME = 1;
	private static final int COMBINED_INDEX_DD = 2;
	private static final int COMBINED_INDEX_MM = 3;
	private static final int COMBINED_INDEX_YY = 4;
	private static final int COMBINED_INDEX_COUNTER = 5;

	private static final int DATE_INDEX_OF_DD = 0;
	private static final int DATE_INDEX_OF_MM = 1;
	private static final int DATE_INDEX_OF_YY = 2;
	private static final int DATE_INDEX_OF_ADVANCE_INT = 3;

	private static final String DUMMY_STR = "Dummy_Str";
	private static final int UNINITIALIZED_INT = -1;
	private static final int DEFAULT_DD_IN_MONTH = 15;
	private static final int INDEX_FEBRUARY = 2;
	private static final String THIS = "this";
	private static final String NEXT = "next";

	private static boolean isInvalidDateTime;
	DateFormat dateFormat;

	// Can just look for substrings
	private static String[] daysInWeek = new String[] { DUMMY_STR, "mon", "tue", "wed", "thu", "fri", "sat", "sun" };
	private static String[] monthsInYear = new String[] { DUMMY_STR, "jan", "feb", "mar", "apr", "may", "jun", 
															"jul", "aug", "sep", "oct", "nov", "dec" };
	private static final int NUMBER_OF_MONTHS_IN_A_YEAR = monthsInYear.length;

	int LEAP_YEAR_FEB = 29;
	private static int[] daysInMonth = new int[] { UNINITIALIZED_INT, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };


	private int currMM;
	private int currYY;
	private int currDD;
	private int currDayInWeekInt;
	private int currTime;
	private String currDayInWeekString;


	private static Logger logger = Logger.getLogger("DateTimeParser");

	enum DATE_TIME_FORMAT {
		TYPE_THIS_DAY_OF_WEEK, TYPE_NEXT_DAY_OF_WEEK, TYPE_DAY_OF_WEEK, TYPE_NEXT_WEEK, TYPE_NUM_DAYS, TYPE_NUM_WEEKS, TYPE_TODAY, TYPE_TOMORROW, TYPE_DATE, TYPE_TIME, TYPE_INVALID
	};

	public DateTimeParser() {
		DateTime dateTime = new DateTime();
		currTime = dateTime.getTimeInt();
		currDayInWeekString = dateTime.getDayStr();
		currDayInWeekInt = dateTime.getDayInt();
		currDD = dateTime.getDD();
		currMM = dateTime.getMM();
		currYY = dateTime.getYY();

		if (isLeapYear(currYY)) {
			daysInMonth[INDEX_FEBRUARY] = LEAP_YEAR_FEB;
		}
	}

	private boolean isLeapYear(int currYear) {
		int[] arrLeapYears = new int[] { 2016, 2020, 2024, 2028, 2032, 2036, 2040, 2044, 2048, 2052, 2056, 2060, 2064,
				2068, 2072, 2076, 2080, 2084, 2088, 2092, 2096 };

		boolean ans = false;
		for (int i = 0; i < arrLeapYears.length; i++) {
			if (currYear < arrLeapYears[i]) {
				break;
			}
			if (currYear == arrLeapYears[i]) {
				ans = true;
				break;
			}
		}
		return ans;
	}

	private DATE_TIME_FORMAT getDateTimeType(String currWord, String[] splitUserInput, int index) {
		if (isThisMonday(currWord, splitUserInput, index)) {
			logger.log(Level.INFO, "is this Monday");
			return DATE_TIME_FORMAT.TYPE_THIS_DAY_OF_WEEK;

		} else if (isNextWeek(currWord, splitUserInput, index)) {
			logger.log(Level.INFO, "isNextWeek");
			return DATE_TIME_FORMAT.TYPE_NEXT_WEEK;

		} else if (isNextWeekday(currWord, splitUserInput, index)) {
			logger.log(Level.INFO, "isNextWeekday");
			return DATE_TIME_FORMAT.TYPE_NEXT_DAY_OF_WEEK;

		} else if (isValidDay(currWord)) {
			logger.log(Level.INFO, "isValidDay");
			return DATE_TIME_FORMAT.TYPE_DAY_OF_WEEK;

		} else if (isValidTime(currWord, splitUserInput, index)) {
			logger.log(Level.INFO, "isValidTime");
			return DATE_TIME_FORMAT.TYPE_TIME;

		} else if (isValidDate(currWord, splitUserInput, index)) {
			logger.log(Level.INFO, "isValidDate");
			return DATE_TIME_FORMAT.TYPE_DATE;

		} else if (isToday(currWord)) {
			logger.log(Level.INFO, "isToday");
			return DATE_TIME_FORMAT.TYPE_TODAY;

		} else if (isTomorrow(currWord)) {
			logger.log(Level.INFO, "isTomorrow");
			return DATE_TIME_FORMAT.TYPE_TOMORROW;

		} else if (isNumberOfDays(currWord, splitUserInput, index)) {
			logger.log(Level.INFO, "isNumDays");
			return DATE_TIME_FORMAT.TYPE_NUM_DAYS;

		} else if (isNumberOfWeeks(currWord, splitUserInput, index)) {
			logger.log(Level.INFO, "isNumWeeks");
			return DATE_TIME_FORMAT.TYPE_NUM_WEEKS;

		} else {
			logger.log(Level.INFO, "isInvalidType");
			return DATE_TIME_FORMAT.TYPE_INVALID;
		}
	}

	private boolean isNumberOfDays(String currWord, String[] splitUserInput, int index) {
		boolean ans = false;
		if (isNumber(currWord) && hasAWordAfterCurrWord(splitUserInput, index)) {
			String nextWord = splitUserInput[incrementByOne(index)];
			ans = nextWord.equals("days") || nextWord.equals("day") || nextWord.equals("dd");
		}
		return ans;
	}

	private boolean isNumberOfWeeks(String currWord, String[] arr, int index) {
		boolean ans = false;
		if (isNumber(currWord) && hasAWordAfterCurrWord(arr, index)) {
			String nextWord = arr[incrementByOne(index)];
			ans = nextWord.equals("weeks") || nextWord.equals("week") || nextWord.equals("wk");
		}
		return ans;
	}

	private boolean hasAWordAfterCurrWord(String[] arr, int index) {
		return index < arr.length - 1;
	}

	private int incrementByOne(int index) {
		return index + 1;
	}

	public DateTime parse(String input) throws IncorrectInputException {
		String[] splitInput = input.toLowerCase().split("\\s+");
		// [dayOfWeek, time, DD, MM, YY, indexInArray]
		int[] combined = new int[] { currDayInWeekInt, UNINITIALIZED_INT, currDD, currMM, currYY, 0 };

		for (int i = 0; i < splitInput.length; i++) {
			String currWord = splitInput[i];
			switch (getDateTimeType(currWord, splitInput, i)) {
			case TYPE_THIS_DAY_OF_WEEK:
				combined = getThisDayOfWeek(splitInput, i, combined);
				break;

			case TYPE_NEXT_DAY_OF_WEEK:
				combined = getNextDayOfWeek(splitInput, i, combined);
				break;

			case TYPE_DAY_OF_WEEK:
				combined = getDayOfWeek(splitInput, i, combined);
				break;

			case TYPE_NEXT_WEEK:
				combined = getDateAfterOneWeek(splitInput, i, combined);
				break;

			case TYPE_NUM_DAYS:
				combined = getDateAndDayAfterNumberOfDays(splitInput, i, combined);
				break;

			case TYPE_NUM_WEEKS:
				combined = getDateAndDayAfterNumberOfWeeks(splitInput, i, combined);
				break;

			case TYPE_TODAY:
				combined = getToday(combined);
				break;

			case TYPE_TOMORROW:
				combined = getTomorrow(combined);
				break;

			case TYPE_DATE:
				try {
					combined = getDate(splitInput, i, combined);
				} catch (IncorrectInputException e) {
					throw e;
				}
				break;

			case TYPE_TIME:
				try {
					combined = getTime(splitInput, i, combined);
				} catch (IncorrectInputException e) {
					throw e;
				}
				break;

			default:
				combined[COMBINED_INDEX_COUNTER] += 1;
				throw new IncorrectInputException("\"" + input + "\"" + " is an invalid date time input");

			}
			i = combined[COMBINED_INDEX_COUNTER];
		}
		return getDateTimeObject(combined);
	}

	// This method converts the array into a DateTime object
	private DateTime getDateTimeObject(int[] combined) {
		DateTime dateTime;
		if (!isInvalidDateTime) {
			int[] date = new int[] { combined[COMBINED_INDEX_DD], combined[COMBINED_INDEX_MM], combined[COMBINED_INDEX_YY] };
			int time = combined[COMBINED_INDEX_TIME];
			int day = combined[COMBINED_INDEX_DAY_OF_WEEK];

			if (hasPassed(currTime, time, date)) {
				date = getDate(NEXT_DAY);
				dateTime = new DateTime(date, daysInWeek[getNextDayInt()], time);
			} else {
				dateTime = new DateTime(date, daysInWeek[day], time);
			}
		} else {
			dateTime = null;
		}
		return dateTime;
	}

	private int[] getTomorrow(int[] combined) {
		int day = getNextDayInt();
		int[] date = getDate(NEXT_DAY);
		int[] ans = getNewCombinedArray(combined, date, day);
		printArray(ans);
		return ans;
	}

	private int[] getNewCombinedArray(int[] combined, int[] date, int day ) {
		return new int[] { day, combined[COMBINED_INDEX_TIME], date[DATE_INDEX_OF_DD], date[DATE_INDEX_OF_MM], date[DATE_INDEX_OF_YY], combined[COMBINED_INDEX_COUNTER] };
	}
	
	private int[] getToday(int[] combined) {
		return combined;
	}

	private void printArray(int[] arr) {
		String temp = EMPTY_STRING;
		for (int i = 0; i < arr.length; i++) {
			temp += arr[i];
			temp += " ";
		}
		System.out.println(temp);
	}

	// Eg. 2 weeks later
	private int[] getDateAndDayAfterNumberOfWeeks(String[] splitInput, int index, int[] combined) {
		int numWeeksLater = Integer.parseInt(splitInput[index]);
		int day = currDayInWeekInt;
		int fastForward = getFastForward(day) + NUMBER_OF_DAYS_IN_WEEK * numWeeksLater;
		int[] date = getDate(fastForward);
		int[] ans = getNewCombinedArray(combined, date, day, incrementByOne(index));
		return ans;
	}
	
	private int[] getNewCombinedArray(int[] combined, int[] date, int day, int index) {
		return new int[] { day, combined[COMBINED_INDEX_TIME], date[DATE_INDEX_OF_DD], date[DATE_INDEX_OF_MM], date[DATE_INDEX_OF_YY], index };
	}

	// Eg. 2 days
	private int[] getDateAndDayAfterNumberOfDays(String[] splitInput, int index, int[] combined) {
		int numDaysLater = Integer.parseInt(splitInput[index]);
		int day = get_Int_Day_From(numDaysLater);
		int[] date = getDate(numDaysLater);
		printArray(date);
		return getNewCombinedArray(combined, date, day, incrementByOne(index));
	}

	// Eg. next week
	private int[] getDateAfterOneWeek(String[] splitInput, int index, int[] combined) {
		int day = currDayInWeekInt;
		int fastForward = getFastForward(day) + NUMBER_OF_DAYS_IN_WEEK;
		int[] date = getDate(fastForward);
		return getNewCombinedArray(combined, date, day, incrementByOne(index));
	}

	// Eg. monday, wed
	private int[] getDayOfWeek(String[] splitInput, int index, int[] combined) {
		int day = convertDayStringToInt(splitInput[index]);
		int fastForward = getFastForward(day);
		int[] date = getDate(fastForward);
		return getNewCombinedArray(combined, date, day, index);
	}

	// Eg. next monday, next wed
	private int[] getNextDayOfWeek(String[] splitInput, int index, int[] combined) {
		int day = convertDayStringToInt(splitInput[incrementByOne(index)]);
		int fastForward = getFastForward(day) + NUMBER_OF_DAYS_IN_WEEK;
		int[] date = getDate(fastForward);
		return getNewCombinedArray(combined, date, day, incrementByOne(index));
	}

	// Eg. this monday, this wed, this wednesday
	private int[] getThisDayOfWeek(String[] splitInput, int index, int[] combined) {
		// splitInput[i].equals("this")
		int day = convertDayStringToInt(splitInput[incrementByOne(index)]);
		int fastForward = getFastForward(day);
		int[] date = getDate(fastForward);
		return getNewCombinedArray(combined, date, day, incrementByOne(index));
	}

	private int[] getDate(String[] splitInput, int index, int[] combined) {
		int[] newDate = getDateAndAdvanceInt(splitInput, index); // [dd, mm, yy, advanceInt]
		return getNewCombinedArray(combined, newDate, getDayOfWeekFromADate(newDate), getAdvanceInt(newDate, combined[COMBINED_INDEX_COUNTER]));
	}

	private int getAdvanceInt(int[] newDate, int index) {
		int ans = newDate[DATE_INDEX_OF_ADVANCE_INT] + index;
		return ans;
	}

	// This method calculates that day of the week that the date falls on
	private int getDayOfWeekFromADate(int[] date) {
		int[] dayTable = new int[] { 7, 1, 2, 3, 4, 5, 6 };
		int[] monthTable = new int[] {UNINITIALIZED_INT, 6, 2, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4};
		int dd = date[DATE_INDEX_OF_DD];
		int mm = date[DATE_INDEX_OF_MM];
		int yy = date[DATE_INDEX_OF_YY];
		
		int lastTwoDigitsOfYear = yy % 1000;
		int divideLastTwoDigitsOfYearByFour = lastTwoDigitsOfYear / 4;
		int sum = lastTwoDigitsOfYear + divideLastTwoDigitsOfYearByFour + dd + monthTable[mm];
		if(isLeapYear(yy) && mm <= 2 && dd <= 31) {
			sum--;
		}
		return dayTable[sum % NUMBER_OF_DAYS_IN_WEEK];
		
	}

	// To Do: include the check for valid dates
	private int[] getDateAndAdvanceInt(String[] splitInput, int currIndexInSplitInput) {
		String firstWord = splitInput[currIndexInSplitInput];
		int[] dateAdvanceIntArray= new int[] { UNINITIALIZED_INT, UNINITIALIZED_INT, UNINITIALIZED_INT, UNINITIALIZED_INT };
		int numEntries = UNINITIALIZED_INT;

		if (firstWord.contains(DATE_SEPARATOR)) {
			//firstWord is in the form of DD/MM or DD/MM/YY
			String[] userInputForDate = firstWord.split(DATE_SEPARATOR);
			for (int j = 0; j < userInputForDate.length; j++) {
				dateAdvanceIntArray[j] = Integer.parseInt(userInputForDate[j]);
			}
			numEntries++;
			
		} else {
			int counter = 0;
			for (int j = currIndexInSplitInput; j < splitInput.length; j++) {
				if (counter > 2) {
					break;
				} else {
					String currWord = splitInput[j];
					if (isNumber(currWord)) {			//currWord is either DD or YY
						int currInt = convertStringToInt(currWord);
						if (currInt <= MAX_NUM_OF_DAYS_IN_A_MONTH && isUninitialized(dateAdvanceIntArray, DATE_INDEX_OF_DD)) {
							dateAdvanceIntArray[DATE_INDEX_OF_DD] = currInt;
							numEntries++;

						} else if (currInt >= 2000 && isUninitialized(dateAdvanceIntArray, DATE_INDEX_OF_YY)) {
							dateAdvanceIntArray[DATE_INDEX_OF_YY] = currInt;
							numEntries++;
						}
					} else if (isMonth(currWord) && isUninitialized(dateAdvanceIntArray, DATE_INDEX_OF_MM)) {
						dateAdvanceIntArray[DATE_INDEX_OF_MM] = convertMonthStrToInt(currWord);
						numEntries++;
					}
				}
				counter++;
			}
		}

		if (isUninitialized(dateAdvanceIntArray, DATE_INDEX_OF_YY)) {
			dateAdvanceIntArray[DATE_INDEX_OF_YY] = getCorrectYear(dateAdvanceIntArray);
		}

		if (isUninitialized(dateAdvanceIntArray, DATE_INDEX_OF_DD)) {
			dateAdvanceIntArray[DATE_INDEX_OF_DD] = DEFAULT_DD_IN_MONTH; // Default
		}

		if (isInvalidDate(dateAdvanceIntArray)) {
			throw new IncorrectInputException("Invalid date!");
		}

		dateAdvanceIntArray[DATE_INDEX_OF_ADVANCE_INT] = numEntries;
		return dateAdvanceIntArray;
	}

	private int getCorrectYear(int[] dateAdvanceIntArray) {
		int newDD = dateAdvanceIntArray[DATE_INDEX_OF_DD];
		int newMM = dateAdvanceIntArray[DATE_INDEX_OF_MM];
		int newYY = UNINITIALIZED_INT;
		if(newMM <= currMM && newDD < currDD) {		// Date has passed
			newYY = incrementByOne(currYY);			// Increase the year by one
		} else {				// Date has not passed
			newYY = currYY;		// Set the year to current year
		}
		return newYY;
	}

	private boolean isUninitialized(int[] ans, int index) {
		return ans[index] == UNINITIALIZED_INT;
	}

	// Checks that the num of months does not exceed the max num of days in that
	// month,
	// Eg. 30 Feb will return an error
	private boolean isInvalidDate(int[] ans) {
		int mm = ans[DATE_INDEX_OF_MM];
		return ans[DATE_INDEX_OF_DD] > daysInMonth[mm];
	}

	private boolean isValidTime(String currWord, String[] userInput, int index) {
		boolean ans = false;

		if (currWord.contains(PM) || currWord.contains(AM)) {
			currWord = currWord.replace(PM, EMPTY_STRING).replace(AM, EMPTY_STRING);
			if (currWord.contains(TIME_SEPARATOR_COLON) || currWord.contains(TIME_SEPARATOR_DOT)) { // Eg: 12pm, 12.30pm, 12:50am
				currWord = removeTimeSeparators(currWord);
				ans = true;
			} else {
				ans = true;
			}

		} else if (isNumber(removeTimeSeparators(currWord)) && hasAWordAfterCurrWord(userInput, index)) { // Eg.9.30 pm, 9
			String nextWord = userInput[incrementByOne(index)];
			if (nextWord.equals(AM) ^ nextWord.equals(PM)) {
				ans = true;
			}
		} else if (currWord.contains(TIME_SEPARATOR_COLON)) { // 24Hour formats eg: 23:30
			currWord = removeTimeSeparators(currWord);
			if (isNumber(currWord)) {
				ans = true;
			}
		} else {
			// Invalid command here
		}
		return ans;
	}

	private String removeTimeSeparators(String currWord) {
		return currWord.replace(TIME_SEPARATOR_COLON, EMPTY_STRING).replace(TIME_SEPARATOR_DOT, EMPTY_STRING);
	}

	private boolean isTomorrow(String currWord) {
		return currWord.equals("tomorrow") || currWord.equals("tmr");
	}

	private boolean isNextWeekday(String currWord, String[] userInput, int index) {
		boolean ans = false;
		if (currWord.equals(NEXT) && hasAWordAfterCurrWord(userInput, index)) { 
			//Check if there is a word that follow "this"
			ans = isValidDay(userInput[incrementByOne(index)]);
		}
		return ans;
	}

	private boolean isNextWeek(String currentWord, String[] userInput, int index) {
		boolean ans = false;
		if (currentWord.equals(NEXT) && hasAWordAfterCurrWord(userInput, index)) {
			int indexOfNextWord = incrementByOne(index);
			String nextWord = userInput[indexOfNextWord];
			ans = nextWord.equals("week") || nextWord.equals("weeks") || nextWord.equals("wk");
		}
		return ans;
	}

	private boolean isThisMonday(String currentWord, String[] userInput, int index) {
		boolean ans = false;
		if (currentWord.equals(THIS) && hasAWordAfterCurrWord(userInput, index)) { 
			int indexOfNextWord = incrementByOne(index);
			String nextWord = userInput[indexOfNextWord];
			ans = isValidDay(nextWord);
		}
		return ans;
	}

	private boolean isValidDay(String currWord) {
		return convertDayStringToInt(currWord) != -1;
	}

	private boolean isValidDate(String currWord, String[] splitInput, int i) {
		boolean ans = false;

		if (currWord.contains(DATE_SEPARATOR)) { // Date is 11/2/2016
			ans = true;
		} else {
			int numEntries = 0;
			
			for (int j = i; j < splitInput.length; j++) {
				if (numEntries > 2) {
					break;
				} else {
					String splitWord = splitInput[j]; // splitWord is "feb" of
														// "feb 2015"
					if (!isNumber(splitWord) && isMonth(splitWord)) {
						ans = true;
						break;
					}
				}
				numEntries++;
			}
		}
		return ans;
	}

	private boolean isMonth(String nextWord) {
		boolean ans = false;
		for (int i = 1; i < NUMBER_OF_MONTHS_IN_A_YEAR; i++) {
			if (nextWord.contains(monthsInYear[i])) {
				ans = true;
				break;
			}
		}
		return ans;
	}

	private boolean isNumber(String currWord) {
		return currWord.matches("[0-9]+");
	}

	private boolean isToday(String currWord) {
		return currWord.equals("today") || currWord.equals("tdy");
	}

	private int convertMonthStrToInt(String monthInput) {
		int monthInt = UNINITIALIZED_INT;
		for (int j = 1; j < NUMBER_OF_MONTHS_IN_A_YEAR; j++) {
			if (monthInput.contains(monthsInYear[j])) {
				monthInt = j;
				break;
			}
		}
		return monthInt;
	}

	private int getNextDayInt() {
		int temp = currDayInWeekInt + NEXT_DAY;
		temp %= NUMBER_OF_DAYS_IN_WEEK ;
		return temp;
	}

	private boolean hasPassed(int currTime2, int time, int[] date) {
		return currTime2 > time && date[DATE_INDEX_OF_DD] == currDD && date[DATE_INDEX_OF_MM] == currMM
				&& date[DATE_INDEX_OF_YY] == currYY && time != UNINITIALIZED_INT;
	}

	// Input number of days to fastforward from today
	// Output the day of the week
	private int get_Int_Day_From(int daysLater) {
		int dayOfWeek = daysLater + currDayInWeekInt;
		dayOfWeek %= NUMBER_OF_DAYS_IN_WEEK ;
		if (dayOfWeek == 0) {
			dayOfWeek = NUMBER_OF_DAYS_IN_WEEK;;
		}
		return dayOfWeek;
	}

	// Input desired day of the week in int
	// Output days to fastForward from today
	private int getFastForward(int desiredDay) {
		int fastForward = 0;
		if (currDayInWeekInt > desiredDay) {
			fastForward = NUMBER_OF_DAYS_IN_WEEK - currDayInWeekInt + desiredDay;
		} else if (currDayInWeekInt < desiredDay) {
			fastForward = desiredDay - currDayInWeekInt;
		} else { // if(currDay == day)
			fastForward = 0;
		}
		return fastForward;
	}

	private int[] getDate(int fastForward) {
		int newDay = currDD + fastForward;
		int newMonth = currMM;
		int newYear = currYY;

		while (newDay > daysInMonth[newMonth]) {
			newDay -= daysInMonth[newMonth];
			newMonth += 1;
		}

		if (newMonth > NUMBER_OF_MONTHS_IN_A_YEAR) {
			newMonth = 1;
			newYear = incrementByOne(newYear);
		}

		int[] ans = new int[] { newDay, newMonth, newYear };
		return ans;
	}

	private int[] getTime(String[] splitInput, int index, int[] combined) throws IncorrectInputException {
		String timeString = removeTimeSeparators(splitInput[index]);
		boolean isAm = timeString.contains(AM);
		boolean isPm = timeString.contains(PM);
		int timeInt = UNINITIALIZED_INT;
		boolean isExactlyMidnight = timeString.equals(TWELVE_MIDNIGHT_ONE_STRING);

		if (isAm && isPm) {
			throw new IncorrectInputException("\"" + timeString + "\"" + ERROR_MESSAGE_AM_AND_PM);
		}

		timeString = removeAmAndPmFromTimeString(timeString, isAm, isPm);
		timeInt = convertStringToInt(timeString);

		if (hasInvalidMinutes(timeInt)) {
			throw new IncorrectInputException(ERROR_MESSAGE_MINUTES_EXCEED_SIXTY);
		}

		timeInt = getTimeIntByAssumingOneWordTimeInput(timeString, isAm, isPm, timeInt, isExactlyMidnight);
		timeInt = getTimeIntByAssumingTwoWordsTimeInput(splitInput, index, timeInt);
		
		if (timeExceeds24H(timeInt)) {
			throw new IncorrectInputException(ERROR_MESSAGE_TIME_EXCEEDS_24H);
		}

		index = getNewAdvanceInt(splitInput, index);
		combined = updateTimeAndIndexInCombinedArray(index, combined, timeInt);
		
		return combined;
	}

	private int[] updateTimeAndIndexInCombinedArray(int index, int[] combined, int timeInt) {
		combined[COMBINED_INDEX_TIME] = timeInt;
		combined[COMBINED_INDEX_COUNTER] = index;
		return combined;
	}

	private int convertStringToInt(String timeString) {
		return Integer.parseInt(timeString);
	}

	private int getTimeIntByAssumingTwoWordsTimeInput(String[] splitInput, int index, int timeInt) {
		if (incrementByOne(index) < splitInput.length) {
			String indicator = splitInput[incrementByOne(index)];
			if (indicator.equals(PM)) {
				timeInt = timeInt + TWELVE_HOURS;
			}
			if (timeInt == FORMAT_24H_12PM && indicator.equals(AM)) {
				timeInt = 0;
			}
		}
		return timeInt;
	}

	private int getTimeIntByAssumingOneWordTimeInput(String timeString, boolean isAm, boolean isPm, int timeInt,
			boolean isExactlyMidnight) {
		if (isMidnight(timeInt, timeString, isAm) || isExactlyMidnight) {
			if (isExactlyMidnight) {
				timeInt = 0;
			} else {
				timeInt = getMinuteNumeralOfTime(timeInt);
			}
		} else if (is12HFormatTime(timeInt)) { // this is for the 12h format
			timeInt = convertTimeFrom12HTo24HFormat(timeInt);
		}

		if (isPm) {
			timeInt = timeInt + TWELVE_HOURS;
		}
		return timeInt;
	}

	private int convertTimeFrom12HTo24HFormat(int timeInt) {
		return timeInt * 100;
	}

	private boolean is12HFormatTime(int timeInt) {
		return timeInt <= 12;
	}

	private int getNewAdvanceInt(String[] splitInput, int index) {
		if (hasAWordAfterCurrWord(splitInput, index)) {
			if (splitInput[incrementByOne(index)].equals(PM) || splitInput[incrementByOne(index)].equals(AM)) {
				index += 1; // To skip the next word
			}
		}
		return index;
	}

	private boolean timeExceeds24H(int timeInt) {
		return timeInt >= 2400;
	}

	private boolean hasInvalidMinutes(int timeInt) {
		return getMinuteNumeralOfTime(timeInt) > 59;
	}

	private String removeAmAndPmFromTimeString(String timeString, boolean isAm, boolean isPm) {
		if (isAm ^ isPm) {
			timeString = timeString.replace(AM, EMPTY_STRING).trim();
			timeString = timeString.replace(PM, EMPTY_STRING).trim();
		}
		return timeString;
	}

	private int getMinuteNumeralOfTime(int timeInt) {
		return timeInt % 100;
	}

	private boolean isMidnight(int timeInt, String timeString, boolean isAm) {
		boolean isMidnight24H = timeInt >= 0 && timeInt <= 59 && timeString.contains("00");
		boolean isMidnight12H = timeInt >= 1200 && timeInt <= 1259 && isAm;
		return isMidnight24H || isMidnight12H;
	}

	private int convertDayStringToInt(String string) {
		int day = UNINITIALIZED_INT;
		for (int i = 0; i < daysInWeek.length; i++) {
			if (string.contains(daysInWeek[i])) {
				day = i;
				break;
			}
		}
		return day;
	}
}
```
###### src\dooyit\parser\DeleteCategoryParser.java
``` java
public class DeleteCategoryParser {
	public DeleteCategoryParser() {
		
	}
	
	public Command getCommand(String input) {
		//return CommandUtils.createDeleteCategoryCommand(input);
		return null;
	}
}
```
###### src\dooyit\parser\DeleteParser.java
``` java
public class DeleteParser extends TagParser {
	private static Command command;

	public DeleteParser() {
		super();
	}

	public Command getCommand(String input) {
		setVariables(input);
		command = null;
		try {
			parseTaskIds();
		} catch(IncorrectInputException e) {
			command = getInvalidCommand(e.getMessage());
		}
		if(command == null) {
			setCorrectDeleteCommand(getTagType());
		}
		
		return command;
	}

	private void setCorrectDeleteCommand(TAG_TYPE tagType) {
		switch (tagType) {
		case SINGLE:
			command = getSingleTypeDeleteCommand();
			break;

		case MULTIPLE:
			command = getMultipleTypeDeleteCommand();
			break;

		case INTERVAL:
			command = getIntervalTypeDeleteCommand();
			break;

		default:
			command = getInvalidCmd();
			break;
		}
	}

	private Command getIntervalTypeDeleteCommand() {
		return CommandUtils.createDeleteCommand(taskIdsForTagging);
	}

	// Eg. delete 5 6 8
	private Command getMultipleTypeDeleteCommand() {
		return CommandUtils.createDeleteCommand(taskIdsForTagging);
	}

	private Command getSingleTypeDeleteCommand() {
		return CommandUtils.createDeleteCommand(taskIdForTagging);
	}

	private Command getInvalidCmd() {
		return CommandUtils.createInvalidCommand("Invalid Delete Command!");
	}
}
```
###### src\dooyit\parser\EditCategoryParser.java
``` java
public class EditCategoryParser {
	private static final String MARKER_COLOUR = " to ";
	private static final int INDEX_ORIGINAL_NAME = 0;
	private static final int INDEX_NEW_NAME = 1;
	private static final int LENGTH_OF_COLOUR_MARKER = 5;
	private static final int UNINITIALIZED = -1;

	private String originalName;
	private String newName;
	private String newColour;
	
	private static final int EDIT_NAME_AND_COLOUR = 1;
	private static final int EDIT_NAME_ONLY = 2;
	private static final int EDIT_COLOUR_ONLY = 3;
	private static final int INVALID_TOO_MANY_WORDS = 4;
	private static final int INVALID_TOO_FEW_ARGUMENTS = 5;
	
	private boolean hasInsufficientArguments;
	private boolean hasTooManyWordsInNewCategoryName;
	
	private static Command command;
	
	public EditCategoryParser() {
		
	}
	
	public Command getCommand(String input) {
		resetVariables();
		setVariables(input);
		switch(getEditType()) {
		
		case EDIT_NAME_AND_COLOUR: 
			//command = CommandUtils.createEditCategoryCommand(originalName, newName, newColour);
			break;
		
		case EDIT_NAME_ONLY:
			//command = CommandUtils.creatEditCategoryNameCommand(originalName, newName);
			break;
		
		case EDIT_COLOUR_ONLY:
			//command = CommandUtils.createEditCategoryColourCommand(originalName, newColour);
			break;
		
		case INVALID_TOO_MANY_WORDS: 
			//command = CommandUtils.creatInvalidEditCategoryCommand("Can't you be more succinct in your category naming?");
			break;
		
		case INVALID_TOO_FEW_ARGUMENTS:
			command = CommandUtils.createInvalidCommand("Too few arguments for Edit Category Command");
			break;
		
		default:
			command = CommandUtils.createInvalidCommand("Invalid Edit Category Command!");
			break;
		}
		return command;
	}

	private int getEditType() {
		int editType = UNINITIALIZED;
		if(hasTooManyWordsInNewCategoryName) {
			editType = INVALID_TOO_MANY_WORDS;
		} else if(hasInsufficientArguments) {
			editType = INVALID_TOO_FEW_ARGUMENTS;
		} if(newName != null && newColour != null) {
			editType = EDIT_NAME_AND_COLOUR;
		} else if(newName == null && newColour != null) {
			editType = EDIT_COLOUR_ONLY;
		} else if(newName != null && newColour == null) {
			editType = EDIT_NAME_ONLY;
		} else {
			
		}
		return editType;
	}

	private void setVariables(String input) {
		String[] inputArr = input.split("//s+");
		originalName = inputArr[INDEX_ORIGINAL_NAME];
		
		if(inputArr.length == 1) {
			hasInsufficientArguments = true;
		} else {
			if(!inputArr[INDEX_NEW_NAME].equals(MARKER_COLOUR.trim())) {
				newName = inputArr[INDEX_NEW_NAME];
			}
			
			int indexOfMarkerColour = input.toLowerCase().indexOf(MARKER_COLOUR);
			if(indexOfMarkerColour != -1) {
				int indexOfColour = indexOfMarkerColour + LENGTH_OF_COLOUR_MARKER;
				newColour = input.substring(indexOfColour);
			}
			
			if(inputArr.length > 4) {
				hasTooManyWordsInNewCategoryName = true;
			}
		}
	}

	private void resetVariables() {
		command = null;
		originalName = null;
		newName = null;
		newColour = null;
		hasInsufficientArguments = false;
		hasTooManyWordsInNewCategoryName = false;
	}

}
```
###### src\dooyit\parser\EditParser.java
``` java
public class EditParser {
	private static final String MARKER_TIME_START = " from ";
	private static final String MARKER_TIME_END = " to ";
	private static final String MARKER_DEADLINE = " by ";

	private static String userInput;
	private static String taskName;
	private static int taskId = -1;
	private static DateTime start = null;
	private static DateTime end = null;
	private static DateTime deadline = null;

	enum EDIT_TYPE {
		NAME, DEADLINE, TIME_START_END, TIME_START, TIME_END, NAME_TIME_START_END, NAME_TIME_START, NAME_TIME_END, NAME_DEADLINE, INVALID
	};

	public EditParser() {

	}

	public Command getCommand(String input) {
		userInput = input.trim();
		taskId = Integer.parseInt(userInput.split("\\s+")[0].trim());
		
		switch (getEditType()) {
		case NAME:
			parseName();
			return CommandUtils.createEditCommandName(taskId, taskName);

		case DEADLINE:
			parseDeadline();
			return CommandUtils.createEditCommandDeadline(taskId, deadline);

		case TIME_START_END:
			parseTimeStartEnd();
			return CommandUtils.createEditCommandEvent(taskId, start, end);

		case TIME_START:
			parseTimeStart();
			return CommandUtils.createEditCommandEvent(taskId, start, end);

		case TIME_END:
			parseTimeEnd();
			return CommandUtils.createEditCommandEvent(taskId, start, end);

		case NAME_TIME_START_END:
			parseNameTimeStartEnd();
			return CommandUtils.createEditCommandNameAndEvent(taskId, taskName, start, end);

		case NAME_TIME_START:
			parseNameTimeStart();
			return CommandUtils.createEditCommandNameAndEvent(taskId, taskName, start, end);

		case NAME_TIME_END:
			parseNameTimeEnd();
			return CommandUtils.createEditCommandNameAndEvent(taskId, taskName, start, end);

		case NAME_DEADLINE:
			parseNameDeadline();
			return CommandUtils.createEditCommandNameAndDeadline(taskId, taskName, deadline);

		case INVALID:
			return CommandUtils.createInvalidCommand("Invalid Edit Command!");
		}
		return null;
	}

	private void parseNameDeadline() {
		parseNameForDeadlineType();
		parseDeadline();
	}

	private void parseNameForDeadlineType() {
		int indexDeadline = userInput.lastIndexOf(MARKER_DEADLINE);
		int startOfName = userInput.indexOf(" ") + 1;
		taskName = userInput.substring(startOfName, indexDeadline);
	}

	private void parseNameTimeEnd() {
		parseNameForTimeEndType();
		parseTimeEnd();
	}

	private void parseNameForTimeEndType() {
		int indexTo = userInput.lastIndexOf(MARKER_TIME_END);
		int startOfName = userInput.indexOf(" ") + 1;
		taskName = userInput.substring(startOfName, indexTo);
	}

	private void parseNameTimeStart() {
		parseNameForTimeStartType();
		parseTimeStart();
	}

	private void parseNameForTimeStartType() {
		int indexFrom = userInput.lastIndexOf(MARKER_TIME_START);
		int startOfName = userInput.indexOf(" ") + 1;
		taskName = userInput.substring(startOfName, indexFrom);
	}

	private void parseNameTimeStartEnd() {
		parseNameForTimeStartEndType();
		parseTimeStart();
		parseTimeEnd();
	}

	private void parseNameForTimeStartEndType() {
		parseNameForTimeStartType();
	}

	private void parseTimeEnd() {
		DateTimeParser dateTimeParser = new DateTimeParser();
		int indexTo = userInput.lastIndexOf(MARKER_TIME_END);
		end = dateTimeParser.parse(userInput.substring(indexTo).replace(MARKER_TIME_END, "").trim());
	}

	private void parseTimeStart() {
		DateTimeParser dateTimeParser = new DateTimeParser();
		int indexFrom = userInput.lastIndexOf(MARKER_TIME_START);
		int indexTo = userInput.lastIndexOf(MARKER_TIME_END);
		if (indexTo != -1) {
			start = dateTimeParser.parse(userInput.substring(indexFrom, indexTo).replace(MARKER_TIME_START, "").trim());
		} else {
			start = dateTimeParser.parse(userInput.substring(indexFrom).replace(MARKER_TIME_START, "").trim());
		}
	}

	private void parseTimeStartEnd() {
		parseName();
		parseTimeEnd();
		parseTimeStart();
	}

	private void parseDeadline() {
		DateTimeParser dateTimeParser = new DateTimeParser();
		int indexDeadline = userInput.lastIndexOf(MARKER_DEADLINE);
		deadline = dateTimeParser.parse(userInput.substring(indexDeadline).replace(MARKER_DEADLINE, "").trim());
	}

	private void parseName() {
		int startOfName = userInput.indexOf(" ") + 1;
		taskName = userInput.substring(startOfName);
	}

	private EDIT_TYPE getEditType() {
		if (hasName()) {
			if (!hasStart() && !hasEnd() && !hasDeadline()) {
				return EDIT_TYPE.NAME;
			} else if (hasStart() && hasEnd() && !hasDeadline()) {
				return EDIT_TYPE.NAME_TIME_START_END;
			} else if (hasStart() && !hasEnd() && !hasDeadline()) {
				return EDIT_TYPE.NAME_TIME_START;
			} else if (!hasStart() && hasEnd() && !hasDeadline()) {
				return EDIT_TYPE.NAME_TIME_END;
			} else if (!hasStart() && !hasEnd() && hasDeadline()) { // !hasStart()
																	// &&
																	// !hasEnd()
				return EDIT_TYPE.NAME_DEADLINE;
			}

		} else if (hasDeadline() && !hasStart() && !hasEnd()) {
			return EDIT_TYPE.DEADLINE;

		} else if (hasStart() || hasEnd()) {
			if (hasStart() && hasEnd()) {
				return EDIT_TYPE.TIME_START_END;
			} else if (hasStart() && !hasEnd()) {
				return EDIT_TYPE.TIME_START;
			} else { // !hasStart() && hasEnd()
				return EDIT_TYPE.TIME_END;
			}

		} else {
			// Invalid command
		}
		return null;
	}

	private static boolean hasName() {
		String mayBeName = userInput.split("\\s+")[1];
		// This means that the names cannot be "by", "to" or "from"
		return !mayBeName.equals(MARKER_DEADLINE.trim()) && !mayBeName.equals(MARKER_TIME_END.trim())
				&& !mayBeName.equals(MARKER_TIME_START.trim());
	}

	private static boolean hasStart() {
		return userInput.lastIndexOf(MARKER_TIME_START) != -1;
	}

	private static boolean hasEnd() {
		return userInput.lastIndexOf(MARKER_TIME_END) != -1;
	}

	private static boolean hasDeadline() {
		return userInput.lastIndexOf(MARKER_DEADLINE) != -1;
	}

}
```
###### src\dooyit\parser\MarkParser.java
``` java
public class MarkParser extends TagParser{
	private static Command command;

	public MarkParser() {
		super();
	}

	public Command getCommand(String input) {
		setVariables(input);
		command = null;
		try {
			parseTaskIds();
		} catch(IncorrectInputException e) {
			command = getInvalidCommand(e.getMessage());
		}
		
		if(command == null) {
			setCorrectMarkCommand(getTagType());
		}
		
		return command;
	}

	private void setCorrectMarkCommand(TAG_TYPE tagType) {
		switch (tagType) {
		case SINGLE:
			command = getSingleTypeMarkCommand();
			break;

		case MULTIPLE:
			command = getMultipleTypeMarkCommand();
			break;

		case INTERVAL:
			command = getIntervalTypeMarkCommand();
			break;

		default:
			command = getInvalidCmd();
			break;
		}
	}

	private Command getIntervalTypeMarkCommand() {
		return CommandUtils.createMarkCommand(taskIdsForTagging);
	}

	// Eg. mark 2 4 0 9
	private Command getMultipleTypeMarkCommand() {
		return CommandUtils.createMarkCommand(taskIdsForTagging);
	}

	private Command getSingleTypeMarkCommand() {
		return CommandUtils.createMarkCommand(taskIdForTagging);
	}

	private Command getInvalidCmd() {
		return CommandUtils.createInvalidCommand("Invalid Mark Command!");
	}
}
```
###### src\dooyit\parser\MoveParser.java
``` java
public class MoveParser extends TagParser {
	private static final int INDEX_NAME = 0;
	private static String catName;
	private static String taskIds;
	private static String userInput;
	private static Command command;
	
	public MoveParser() {
		super();
	}
	
	public Command getCommand(String input) {
		parse(input);
		setVariables(taskIds);
		
		try {
			parseTaskIds();
		} catch(IncorrectInputException e) {
			command = getInvalidCommand(e.getMessage());
		}
		
		if(command == null) {
			setCorrectMoveCommand(getTagType());
		}
		
		return command;
	}

	private void setCorrectMoveCommand(TAG_TYPE tagType) {
		switch (tagType) {
		case SINGLE:
			command = getSingleTypeMoveCommand();
			break;

		case MULTIPLE:
			command = getMultipleTypeMoveCommand();
			break;

		case INTERVAL:
			command = getIntervalTypeMoveCommand();
			break;

		default:
			command = getInvalidCmd();
			break;
		}
	}

	private Command getIntervalTypeMoveCommand() {
		//return CommandUtils.createMoveCommand(catName, taskIdsForTagging);
		return null;
	}

	// Eg. delete 5 6 8
	private Command getMultipleTypeMoveCommand() {
		//return CommandUtils.createMoveCommand(catName, taskIdsForTagging);
		return null;
	}

	private Command getSingleTypeMoveCommand() {
		return CommandUtils.createSetCategoryCommand(taskIdForTagging, catName);
	}

	private Command getInvalidCmd() {
		return CommandUtils.createInvalidCommand("Invalid Delete Command!");
	}

	private void parse(String input) {
		command = null;
		userInput = input;
		String[] inputArr = userInput.split("\\s+");
		catName = inputArr[INDEX_NAME];
		System.out.println("catName is " + catName);
		
		int indexOfTaskIds = userInput.indexOf(catName) + catName.length();
		taskIds = userInput.substring(indexOfTaskIds).trim();
		System.out.println("taskIds is " + taskIds);
	}
}
```
###### src\dooyit\parser\Parser.java
``` java
public class Parser {

	static final String COMMAND_EXIT = "exit";
	static final String COMMAND_CLOSE = "close";
	static final String COMMAND_HELP = "help";
	static final String COMMAND_CLEAR = "clear";
	static final String COMMAND_SHOW = "show";
	static final String COMMAND_DELETE = "delete";
	static final String COMMAND_MARK = "mark";
	static final String COMMAND_EDIT = "edit";
	static final String COMMAND_ADD = "add";
	static final String COMMAND_ADD_CAT = "addcat";
	static final String COMMAND_SKIN = "skin";
	static final String COMMAND_STORAGE = "storage";
	static final String COMMAND_UNMARK = "unmark";
	static final String COMMAND_UNDO = "undo";
	private static final String COMMAND_DELETE_CAT = "deletecat";
	private static final String COMMAND_EDIT_CAT = "editcat";
	private static final String COMMAND_MOVE_TO_CAT = "move";
	private static final String COMMAND_REMOVE_FROM_CAT = "rm";
	private static AddParser addParser;
	private static ShowParser showParser;
	private static EditParser editParser;
	private static AddCategoryParser addCatParser;
	private static DeleteParser deleteParser;
	private static MarkParser markParser;
	private static UnmarkParser unmarkParser;
	private static DeleteCategoryParser deleteCatParser;
	private static EditCategoryParser editCatParser;
	private static MoveParser moveParser;
	private static RemoveParser removeParser;

	public Parser() {
		addParser = new AddParser();
		showParser = new ShowParser();
		editParser = new EditParser();
		addCatParser = new AddCategoryParser();
		deleteParser = new DeleteParser();
		markParser = new MarkParser();
		unmarkParser = new UnmarkParser();
		editCatParser = new EditCategoryParser();
		moveParser = new MoveParser();
		removeParser = new RemoveParser();
	}

	public Command getCommand(String input) {
		input = input.trim();

		if (input == "") {
			Main.showToUser(Main.MESAGE_EMPTY_COMMAND);
			return null;
		}

		String[] splittedInput = input.split("\\s+", 2);
		String commandString = splittedInput[0].toLowerCase();

		Command command = null;
		switch (commandString) {
		case COMMAND_ADD:
			command = addParser.getCommand(getInputWithoutCommand(input, COMMAND_ADD));
			break;

		case COMMAND_SHOW:
			command = showParser.getCommand(getInputWithoutCommand(input, COMMAND_SHOW));
			break;

		case COMMAND_EDIT:
			command = editParser.getCommand(getInputWithoutCommand(input, COMMAND_EDIT));
			break;

		case COMMAND_DELETE:
			command = deleteParser.getCommand(getInputWithoutCommand(input, COMMAND_DELETE));
			break;

		case COMMAND_MARK:
			command = markParser.getCommand(getInputWithoutCommand(input, COMMAND_MARK));
			break;

		case COMMAND_ADD_CAT:
			command = addCatParser.getCommand(getInputWithoutCommand(input, COMMAND_ADD_CAT));
			break;
			
		case COMMAND_DELETE_CAT:
			command = deleteCatParser.getCommand(getInputWithoutCommand(input, COMMAND_DELETE_CAT));
			break;
			
		case COMMAND_EDIT_CAT:
			command = editCatParser.getCommand(getInputWithoutCommand(input, COMMAND_EDIT_CAT));
			break;

		case COMMAND_SKIN:
			String colour = getInputWithoutCommand(input, COMMAND_SKIN);
			command = CommandUtils.createChangeThemeCommand(colour);
			break;

		case COMMAND_STORAGE:
			String filePath = getInputWithoutCommand(input, COMMAND_STORAGE);
			command = CommandUtils.createStorageCommand(filePath);
			break;
		
		case COMMAND_HELP:
			command = CommandUtils.createHelpCommand();
			break;

		case COMMAND_UNMARK:
			command = unmarkParser.getCommand(getInputWithoutCommand(input, COMMAND_UNMARK));
			break;
		
		case COMMAND_MOVE_TO_CAT:
			System.out.println("reached move to cat case");
			command = moveParser.getCommand(getInputWithoutCommand(input, COMMAND_MOVE_TO_CAT));
			break;
			
		case COMMAND_REMOVE_FROM_CAT:
			command = removeParser.getCommand(getInputWithoutCommand(input, COMMAND_REMOVE_FROM_CAT));
			break;
			
		case COMMAND_UNDO:
			command = CommandUtils.createUndoCommand();
			break;
			
		case COMMAND_CLOSE:
			command = CommandUtils.createExitCommand();
			break;
			
		case COMMAND_EXIT:
			command = CommandUtils.createExitCommand();
			break;

		default:
			command = CommandUtils.createInvalidCommand("Invalid Command: " + input);
		}

		return command;
	}

	private String getInputWithoutCommand(String input, String command) {
		return input.substring(command.length()).trim();
	}
}
```
###### src\dooyit\parser\RemoveParser.java
``` java
public class RemoveParser extends TagParser {
	private static Command command;

	public RemoveParser() {
		super();
	}

	public Command getCommand(String input) {
		setVariables(input);
		command = null;
		
		try {
			parseTaskIds();
		} catch(IncorrectInputException e) {
			command = getInvalidCommand(e.getMessage());
		}
		
		if(command == null) {
			setCorrectRemoveCommand(getTagType());
		}
		
		return command;
	}

	private void setCorrectRemoveCommand(TAG_TYPE tagType) {
		switch (tagType) {
		case SINGLE:
			command = getSingleTypeRemoveCommand();
			break;

		case MULTIPLE:
			command = getMultipleTypeRemoveCommand();
			break;

		case INTERVAL:
			command = getIntervalTypeRemoveCommand();
			break;

		default:
			command = getInvalidCmd();
			break;
		}
	}

	private Command getIntervalTypeRemoveCommand() {
		//return CommandUtils.createRemoveCommand(taskIdsForTagging);
		return null;
	}

	// Eg. delete 5 6 8
	private Command getMultipleTypeRemoveCommand() {
		//return CommandUtils.createRemoveCommand(taskIdsForTagging);
		return null;
	}

	private Command getSingleTypeRemoveCommand() {
		//return CommandUtils.createRemoveCommand(taskIdForTagging);
		return null;
	}

	private Command getInvalidCmd() {
		return CommandUtils.createInvalidCommand("Invalid Remove Command!");
	}
}
```
###### src\dooyit\parser\ShowParser.java
``` java
public class ShowParser {
	private static String userInput;
	private static final String TODAY = "today";
	private static final String NEXT_SEVEN = "next7";
	private static final String DONE = "done";
	private static final String ALL = "all";
	private static final String DATE = "date";
	private static final String CATEGORY = "cat";
	private static final String COMPLETED = "completed";
	private static final String FLOAT = "float";

	public ShowParser() {
	
	}

	public Command getCommand(String input) {
		userInput = input.toLowerCase();
		switch (userInput) {
		case TODAY:
			return CommandUtils.createShowTodayCommand();

		case NEXT_SEVEN:
			return CommandUtils.createShowNext7DaysCommand();

		case DONE:
			return CommandUtils.createShowCompletedCommand();

		case ALL:
			return CommandUtils.createShowAllCommand();
			
		case FLOAT:
			return CommandUtils.createShowFloatCommand();

		case COMPLETED:
			return CommandUtils.createShowCompletedCommand();

		// case DATE :
		// DateTimeParser dateTimeParser = new DateTimeParser();
		// DateTime date = dateTimeParser.parse(userInput);
		// return CommandUtils.createShowCommand(COMMAND_DATE, date);

		case CATEGORY:
			return CommandUtils.createShowCategoryCommand(getCatName(userInput));

		default:
			return CommandUtils.createInvalidCommand("Invalid Show command");
		}
	}

	private String getCatName(String userInput2) {
		int index = userInput.indexOf(" ");
		String ans = userInput.substring(index).trim();
		return ans;
	}
}
```
###### src\dooyit\parser\TagParser.java
``` java
public class TagParser {
	public static final int INDEX_SINGLE = 0;
	public static String userInput;
	public static String[] splitInput;
	public static ArrayList<Integer> taskIdsForTagging;
	public static int taskIdForTagging;
	public static int tagType;
	
	enum TAG_TYPE {
		SINGLE, MULTIPLE, INTERVAL, INVALID
	}

	public TagParser() {

	}
	
	public void parseTaskIds() throws IncorrectInputException {
		switch (getTagType()) {
		case SINGLE:
			System.out.println("is single tag type");
			try {
				parseSingleType();
			} catch (IncorrectInputException e) {
				throw e;
			}
			break;

		case MULTIPLE:
			System.out.println("is multiple tag type");
			try {
				parseMultipleType();
			} catch (IncorrectInputException e) {
				throw e;
			}
			break;

		case INTERVAL:
			System.out.println("is interval tag type");
			try {
				parseIntervalType();
			} catch (IncorrectInputException e) {
				throw e;
			}
			break;

		default:
			throw new IncorrectInputException("Error: Invalid Task IDs");
		}
	}
	
	public void setVariables(String input) {
		userInput = input;
		splitInput = userInput.split("\\s+");
		taskIdsForTagging = new ArrayList<Integer>();
	}

	public void parseIntervalType() throws IncorrectInputException {
		for (int i = INDEX_SINGLE; i < splitInput.length; i++) {
			if (splitInput[i].equals("-")) {
				if (!isNumber(splitInput[i - 1]) || !isNumber(splitInput[i + 1])) {
					throw new IncorrectInputException("Invalid Number!");
				} else {
					setInterval(splitInput, i);
				}
			}
		}
	}

	public void setInterval(String[] arr, int index) {
		int start = Integer.parseInt(arr[index - 1]);
		int end = Integer.parseInt(arr[index + 1]);
		for (int i = start; i <= end; i++) {
			taskIdsForTagging.add(i);
		}
	}

	public void parseMultipleType() throws IncorrectInputException {
		for (int i = INDEX_SINGLE; i < splitInput.length; i++) {
			String currWord = splitInput[i];
			if (!isNumber(currWord)) {
				throw new IncorrectInputException("Invalid Number!");
			} else {
				taskIdsForTagging.add(Integer.parseInt(currWord));
			}
		}
	}

	public Command getInvalidCommand(String message) {
		return CommandUtils.createInvalidCommand(message);
	}

	public void parseSingleType() throws IncorrectInputException {
		if (isNumber(splitInput[INDEX_SINGLE])) {
			System.out.println("taskID is " + splitInput[INDEX_SINGLE]);
			taskIdForTagging = Integer.parseInt(splitInput[INDEX_SINGLE]);
		} else {
			System.out.println("taskID is " + splitInput[INDEX_SINGLE]);
			throw new IncorrectInputException("Invalid Task ID!");
		}
	}

	public TAG_TYPE getTagType() {
		if (userInput.contains("-")) {
			return TAG_TYPE.INTERVAL;
		} else if (splitInput.length == 1) {
			return TAG_TYPE.SINGLE;
		} else if (splitInput.length > 1) {
			return TAG_TYPE.MULTIPLE;
		} else {
			return TAG_TYPE.INVALID;
		}
	}

	public boolean isNumber(String currWord) {
		return currWord.matches("[0-9]+");
	}
}
```
###### src\dooyit\parser\UnmarkParser.java
``` java
public class UnmarkParser extends TagParser{
	private static Command command;

	public UnmarkParser() {
		super();
		
	}

	public Command getCommand(String input) throws IncorrectInputException {
		setVariables(input);
		command = null;
		
		System.out.println("input is " + input);
		try {
			parseTaskIds();
		} catch(IncorrectInputException e) {
			command = getInvalidCommand(e.getMessage());
		}
		
		if(command == null) {
			setUnmarkCommand(getTagType());
		}
		
		return command;
	}

	private void setUnmarkCommand(TAG_TYPE tagType) {
		switch (tagType) {
		case SINGLE:
			command = getSingleTypeUnmarkCommand();
			break;

		case MULTIPLE:
			command = getMultipleTypeUnmarkCommand();
			break;

		case INTERVAL:
			command = getIntervalTypeUnmarkCommand();
			break;

		default:
			command = getInvalidCmd();
			break;
		}
	}

	private Command getIntervalTypeUnmarkCommand() {
		return CommandUtils.createUnMarkCommand(taskIdsForTagging);
	}
	
	// Eg. unmark 2 4 0 9
	private Command getMultipleTypeUnmarkCommand() {
		return CommandUtils.createUnMarkCommand(taskIdsForTagging);
	}

	private Command getSingleTypeUnmarkCommand() {
		return CommandUtils.createUnMarkCommand(taskIdForTagging);
	}

	private Command getInvalidCmd() {
		return CommandUtils.createInvalidCommand("Invalid Unmark Command!");
	}
}
```
