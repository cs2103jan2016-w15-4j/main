# A0133338J
###### src\dooyit\common\datatype\DateTime.java
``` java
package dooyit.common.datatype;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.TimeZone;
import java.util.logging.Level;
import java.util.logging.Logger;

/** 
 * DateTime is the date structure for date and and time
 * 
 * @author Annabel
 *
 */
public class DateTime {
	// For to string method
	private static final String FORMAT_SPACE = " ";
	
	// Time indicators
	private static final String TIME_SEPARATOR_COLON = ":";
	private static final String PM = "pm";
	private static final String AM = "am";

	// Calendar for date format and time zone
	private static final String CALENDAR_DATE_FORMAT = "dd MM yyyy HH:mm E u";
	private static final String CALENDAR_DEFAULT_TIME_ZONE = "UTC+08:00"; // Singapore Time Zone
	
	// Uninitialized strings and integers
	private static final int UNINITIALIZED_INT = -1;
	private static final String UNINITIALIZED_STRING = "-1";
	private static final String DUMMY_STR = "Dummy_Str";
	
	// Index of DD, MM, YY and timeInt in the date int array input
	private static final int INDEX_DD = 0;
	private static final int INDEX_MM = 1;
	private static final int INDEX_YY = 2;
	private static final int INDEX_TIME_INT = 3;
	
	// Constants for comparison of DateTime objects
	private static final int COMPARISON_FIRST_IS_BEFORE_SECOND = -1;
	private static final int COMPARISON_FIRST_EQUALS_SECOND = 0;
	private static final int COMPARISON_FIRST_IS_AFTER_SECOND = 1;
	
	// Number of months in a year and week
	private static final int NUM_MONTHS_IN_A_YEAR = 12;
	private static final int NUMBER_OF_DAYS_IN_WEEK = 7;

	// Constants for midnight and before midnight
	private static final int MIDNIGHT_INT = 0;
	private static final int RIGHT_BEFORE_MIDNIGHT_INT = 2359;
	
	// String constants for midnight and before midnight
	private static final String RIGHT_BEFORE_MIDNIGHT_STRING = "23:59";
	private static final String MIDNIGHT_STRING ="00:00";
	
	// Int constants for the days of the week
	public static final int INT_MONDAY = 1;
	public static final int INT_TUESDAY = 2;
	public static final int INT_WEDNESDAY = 3;
	public static final int INT_THURSDAY = 4;
	public static final int INT_FRIDAY = 5;
	public static final int INT_SATURDAY = 6;
	public static final int INT_SUNDAY = 7;
	
	// Short form of the days of the week
	private static final String DAY_MON = "mon";
	private static final String DAY_TUE = "tue";
	private static final String DAY_WED = "wed";
	private static final String DAY_THU = "thu";
	private static final String DAY_FRI = "fri";
	private static final String DAY_SAT = "sat";
	private static final String DAY_SUN = "sun";
	
	// Short form of the months in a year
	private static final String MONTH_JAN = "jan";
	private static final String MONTH_FEB = "feb";
	private static final String MONTH_MARCH = "mar";
	private static final String MONTH_APR = "apr";
	private static final String MONTH_MAY = "may";
	private static final String MONTH_JUN = "jun";
	private static final String MONTH_JUL = "jul";
	private static final String MONTH_AUG = "aug";
	private static final String MONTH_SEP = "sep";
	private static final String MONTH_OCT = "oct";
	private static final String MONTH_NOV = "nov";
	private static final String MONTH_DEC = "dec";
	
	// For the formatting of time string
	private static final String FORMAT_12H = "%d.%02d %s";
	private static final String FORMAT_24H = "%02d:%02d";
	
	// Array constants
	private static final String[] months = new String[] { DUMMY_STR, "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };
	private static final String[] daysInWeek = new String[] { DUMMY_STR, "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday" };
	private static final int[] daysInMonth = new int[] { UNINITIALIZED_INT, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

	// DateTime object attributes
	private int dd; 
	private int mm;	
	private int yy; 
	private int timeInt;
	
	// Logger for DateTime class
	private static Logger logger = Logger.getLogger("DateTime");
	
	/** Types of day of the week */
	public enum Day {
		MON, TUE, WED, THU, FRI, SAT, SUN, INVALID;
	}

	/** Types of month of the year */
	public enum Month {
		JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC, INVALID
	}
	
	//********************************************
	//************* Constructors *****************
	//********************************************
	/** 
	 * Initialize a DateTime object with the same attributes as the
	 * DateTime object passed into the method
	 */
	public DateTime(DateTime dt) {
		this.dd = dt.getDD();
		this.mm = dt.getMM();
		this.yy = dt.getYY();
		this.timeInt = dt.getTimeInt();
		logger.log(Level.INFO, "Initialised DateTime object");
	}
	
	/** 
	 * Initialize a DateTime object with the same date as the 
	 * int array passed into the method
	 */
	public DateTime(int[] date) {
		this.dd = date[INDEX_DD];
		this.mm = date[INDEX_MM];
		this.yy = date[INDEX_YY];
		this.timeInt = UNINITIALIZED_INT;
		logger.log(Level.INFO, "Initialised DateTime object");
	}
	
	/** 
	 * Initialize a DateTime object with the same date as the 
	 * int array and the same time int passed into the method
	 */
	public DateTime(int[] date, int time) {
		this.dd = date[INDEX_DD];
		this.mm = date[INDEX_MM];
		this.yy = date[INDEX_YY];
		this.timeInt = time;
		logger.log(Level.INFO, "Initialised DateTime object");
	}

	/**
	 * Initialize a DateTime object with the date and time that
	 * the object is initialized. 
	 */
	public DateTime() {
		Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(CALENDAR_DEFAULT_TIME_ZONE));
		DateFormat dateFormat = new SimpleDateFormat(CALENDAR_DATE_FORMAT);

		String date = dateFormat.format(cal.getTime());
		String[] splitDate = date.split("\\s+");

		this.dd = Integer.parseInt(splitDate[INDEX_DD]);
		this.mm = Integer.parseInt(splitDate[INDEX_MM]);
		this.yy = Integer.parseInt(splitDate[INDEX_YY]);
		this.timeInt = Integer.parseInt(splitDate[INDEX_TIME_INT].replace(TIME_SEPARATOR_COLON, ""));
		logger.log(Level.INFO, "Initialised DateTime object");
	}
	
	//********************************************
	//** Methods to retrieve object attributes ***
	//********************************************
	/** 
	 * Gets the string of the day of the week like wed and thur
	 * @return day of the week in string
	 */
	public String getDayStr() {
		return daysInWeek[this.getDayInt()];
	}
 
	/** 
	 * Gets the int of the day of the week like 3 for wed
	 * @return day of the week in int form
	 */
	public int getDayInt() {
		return getDayOfWeekFromADate();
	}

	/** 
	 * Get the string format of the date.
	 * @return string format of the date.
	 */
	public String getDate() {
		return this.dd + FORMAT_SPACE + months[this.mm] + FORMAT_SPACE + this.yy;
	}

	/** 
	 * Get the 24h time string
	 * @return 24h time string
	 */
	public String getTime24hStr() {
		String timeString24H;
		if(this.timeInt == UNINITIALIZED_INT) {
			timeString24H = UNINITIALIZED_STRING;
		} else {
			int hour = getHourNumeral(this.timeInt);
			int minute = getMinutesNumeral(this.timeInt);
			timeString24H = String.format(FORMAT_24H, hour, minute);
		}
		return timeString24H;
	}

	/** 
	 * Get the 12h time string
	 * @return 12h time string
	 */
	public String getTime12hStr() {
		int hour = getHourNumeral(this.timeInt);
		int minute = getMinutesNumeral(this.timeInt);
		String timeString12H;
		if(this.timeInt == UNINITIALIZED_INT) {
			timeString12H = UNINITIALIZED_STRING;
		} else if(hour == 0) {
			hour += 12;
			timeString12H = String.format(FORMAT_12H, hour, minute, AM);
		} else if(hour < 12) {
			timeString12H = String.format(FORMAT_12H, hour, minute, AM);
		} else if(hour == 12) {
			timeString12H = String.format(FORMAT_12H, hour, minute, PM);
		} else {
			hour -= 12;
			timeString12H = String.format(FORMAT_12H, hour, minute, PM);
		}
		return timeString12H;
	}
	
	/** 
	 * Get the 24h time int of the object
	 * @return the 24h time int.
	 */
	public int getTimeInt() {
		return this.timeInt;
	}

	/** 
	 * Get the DD of the object.
	 * @return DD of the date.
	 */
	public int getDD() {
		return this.dd;
	}

	/** 
	 * Get the MM attribute of the object
	 * @return MM of the date.
	 */
	public int getMM() {
		return this.mm;
	}

	/** 
	 * Get the YY attribute of the object
	 * @return YY of the date.
	 */
	public int getYY() {
		return this.yy;
	}
	
	//****************************************************
	//****** Methods to compare 2 DateTime objects *******
	//****************************************************
	

	/** 
	 * Check if one date time object is before, equal or after another date time object.
	 * 
	 * @param DateTime
	 *        The DateTime object passed in for comparison
	 *        
	 * @return	Returns 0 if this DateTime object has the same date and time as the DateTime object passed in as argument
	 *			Returns 1 if this DateTime object lies after DateTime object passed in as argument
	 *			Returns -1 if this DateTime object lies before DateTime object passed in as argument
	 */
	public int compareTo(DateTime DateTime) {
		int comparison = COMPARISON_FIRST_EQUALS_SECOND;
		if(!this.equals(DateTime)) {
			int dateComparison = compareDates(this, DateTime);
			int timeComparison = compareTime(this, DateTime);
			comparison = getComparison(dateComparison, timeComparison);
		}
		return comparison;
	}
	
	/** 
	 * Compares the comparison values for date and time.
	 * 
	 * @param dateComparison
	 *        Possible values are -1, 0, and 1
	 *        
	 * @param timeComparison
	 *        Possible values are -1, 0, and 1
	 *        
	 * @return -1, 0, and 1 depending on whether the DateTime object if before
	 * 			equals to or after the other DateTime object.
	 */
	private static int getComparison(int dateComparison, int timeComparison) {
		int comparison;
		if(dateComparison != COMPARISON_FIRST_EQUALS_SECOND) {
			comparison = dateComparison;
		} else {
			comparison = timeComparison;
		}
		return comparison;
	}

	/** 
	 * Compares the time int of 2 DateTime objects.
	 * 
	 * @param first
	 * 		  First DateTime object passed in.
	 * 
	 * @param second
	 *        Second DateTime object passed in.
	 *        
	 * @return -1, 0, 1 if first timing is before, equals to or after second timing.
	 */
	private static int compareTime(DateTime first, DateTime second) {
		int comparison = COMPARISON_FIRST_EQUALS_SECOND;
		int firstTimeInt = first.getTimeInt();
		int secondTimeInt = second.getTimeInt();
		if(firstTimeInt != secondTimeInt) {
			if(firstTimeInt == UNINITIALIZED_INT || secondTimeInt == UNINITIALIZED_INT) {
				comparison = compareAgainstUninitializedTime(firstTimeInt, secondTimeInt);
			} else if(firstTimeInt < secondTimeInt) {
				comparison = COMPARISON_FIRST_IS_BEFORE_SECOND;
			} else {
				comparison = COMPARISON_FIRST_IS_AFTER_SECOND;
			}
		} 
		return comparison;
	}

	/** 
	 * Checks if the first timeint is uninitialized before comparing the timings.
	 * This is when the first and second timings cannot be equal to each other.
	 * 
	 * @param firstTimeInt
	 *        TimeInt of the first DateTime object.
	 *        
	 * @param secondTimeInt
	 *        TimeInt of the second dadtetime object.
	 *        
	 * @return -1, 1 when first timing is before or after second timing.
	 */
	private static int compareAgainstUninitializedTime(int firstTimeInt, int secondTimeInt) {
		int comparison;
		if(firstTimeInt == UNINITIALIZED_INT) {
			comparison = COMPARISON_FIRST_IS_AFTER_SECOND;
		} else {
			comparison = COMPARISON_FIRST_IS_BEFORE_SECOND;
		}
		return comparison;
	}

	/** 
	 * Compares just the dates of 2 DateTime objects.
	 * 
	 * @param first
	 * 		  First DateTime object input
	 * 
	 * @param second
	 * 		  Second DateTime object input
	 * 
	 * @return -1, 0, 1 if first date is before, equals to or after second date.
	 */
	private static int compareDates(DateTime first, DateTime second) {
		boolean isSameDate = compareDateStrings(first, second);
		int yearComparison = compareYear(first, second);
		int monthComparison = compareMonth(first, second);
		int dayComparison = compareDay(first, second);
		
		int comparison = COMPARISON_FIRST_EQUALS_SECOND;
		
		if(!isSameDate) {
			comparison = compareYearMonthDay(yearComparison, monthComparison, dayComparison);
		}
		
		return comparison;
	}
	
	/** 
	 * Compare the comparison values of day, month and year.
	 * 
	 * @param yearComparison
	 * 		  Possible values are -1, 0, 1
	 * 
	 * @param monthComparison
	 * 		  Possible values are -1, 0, 1
	 * 
	 * @param dayComparison
	 *        Possible values are -1, 0, 1
	 *        
	 * @return -1, 0, 1 after taking into account the year, month and day comparisons.
	 */
	private static int compareYearMonthDay(int yearComparison, int monthComparison, int dayComparison) {
		int comparison;
		if(isSameYear(yearComparison)) {
			comparison = compareMonthDay(monthComparison, dayComparison);
		} else {
			comparison = yearComparison;
		}
		return comparison;
	}

	/** 
	 * Compare the comparison values of day and month.
	 * 
	 * @param monthComparison
	 * 		  Possible values are -1, 0, 1
	 * 
	 * @param dayComparison
	 *        Possible values are -1, 0, 1
	 *        
	 * @return -1, 0, 1 after taking into account the month and day comparisons.
	 */
	private static int compareMonthDay(int monthComparison, int dayComparison) {
		int comparison;
		if(isSameMonth(monthComparison)) {
			comparison = dayComparison;
		} else {
			comparison = monthComparison;
		}
		return comparison; 
	}

	/**
	 * Checks if monthComparison value is 0
	 * 
	 * @param monthComparison
	 * 		  Possible values are -1, 0, 1
	 *        
	 * @return true if is 0 and false otherwise.
	 */
	private static boolean isSameMonth(int monthComparison) {
		return monthComparison == COMPARISON_FIRST_EQUALS_SECOND;
	}
	
	/**
	 * Checks if yearComparison value is 0
	 * 
	 * @param yearComparison
	 * 		  Possible values are -1, 0, 1
	 *        
	 * @return true if is 0 and false otherwise.
	 */
	private static boolean isSameYear(int yearComparison) {
		return yearComparison == COMPARISON_FIRST_EQUALS_SECOND;
	}

	/** 
	 * Compares the days of 2 DateTime objects.
	 * 
	 * @param first
	 * 		  First DateTime object input
	 * 
	 * @param second
	 * 		  Second DateTime object input
	 * 
	 * @return -1, 0, 1 if first day is before, equals to or after second day.
	 */
	private static int compareDay(DateTime first, DateTime second) {
		int comparison = COMPARISON_FIRST_EQUALS_SECOND;
		int firstDD = first.getDD();
		int secondDD = second.getDD();
		if(firstDD != secondDD) {
			if(firstDD < secondDD) {
				comparison = COMPARISON_FIRST_IS_BEFORE_SECOND;
			} else {
				comparison = COMPARISON_FIRST_IS_AFTER_SECOND;
			}
		}
		return comparison;
	}

	/** 
	 * Compares the months of 2 DateTime objects.
	 * 
	 * @param first
	 * 		  First DateTime object input
	 * 
	 * @param second
	 * 		  Second DateTime object input
	 * 
	 * @return -1, 0, 1 if first month is before, equals to or after second month.
	 */
	private static int compareMonth(DateTime first, DateTime second) {
		int comparison = COMPARISON_FIRST_EQUALS_SECOND;
		int firstMM = first.getMM();
		int secondMM = second.getMM();
		if(firstMM != secondMM) {
			if(firstMM < secondMM) {
				comparison = COMPARISON_FIRST_IS_BEFORE_SECOND;
			} else {
				comparison = COMPARISON_FIRST_IS_AFTER_SECOND;
			}
		}
		return comparison;
	}

	/** 
	 * Compares the months of 2 DateTime objects
	 * 
	 * @param first
	 * 		  First DateTime object input
	 * 
	 * @param second
	 * 		  Second DateTime object input
	 * 
	 * @return -1, 0, 1 if first year is before, equals to or after second year.
	 */
	private static int compareYear(DateTime first, DateTime second) {
		int comparison = COMPARISON_FIRST_EQUALS_SECOND;
		int firstYY = first.getYY();
		int secondYY = second.getYY();
		if(firstYY != secondYY) {
			if(firstYY < secondYY) {
				comparison = COMPARISON_FIRST_IS_BEFORE_SECOND;
			} else {
				comparison = COMPARISON_FIRST_IS_AFTER_SECOND;
			}
		}
		return comparison;
	}

	/** 
	 * Compares the date strings of 2 DateTime objects
	 * 
	 * @param first
	 * 		  First DateTime object input
	 * 
	 * @param second
	 * 		  Second DateTime object input
	 * 
	 * @return true if the date strings are equal and false otherwise.
	 */
	private static boolean compareDateStrings(DateTime first, DateTime second) {
		return first.getDate().equals(second.getDate());
	}
	
	/** 
	 * Checks if the stated day is between the start and end DateTime objects
	 * 
	 * @param day
	 * 		  Day Enum
	 * 
	 * @param first
	 * 		  First DateTime object input
	 * 
	 * @param second
	 * 		  Second DateTime object input
	 * 
	 * @return true if it lies between the start and end and false otherwise.
	 */
	public static boolean isWithinDay(Day day, DateTime start, DateTime end) {
		int startDayInt = start.getDayInt();
		int endDayInt = end.getDayInt();
		int dayEnumInt = convertDayEnumToInt(day);
		
		boolean isAfterStart = dayEnumInt >= startDayInt;
		boolean isBeforeEnd = dayEnumInt <= endDayInt;
		return isAfterStart && isBeforeEnd;
	}

	/** 
	 * Checks if this DateTime object is equal to the DateTime object passed 
	 * into the method.
	 * 
	 * @param dateTime
	 * 		  A DateTim object
	 * 
	 * @return true if the two object have the same attributes and false otherwise.
	 */
	public boolean equals(DateTime dateTime) {
		boolean hasEqualDateString = this.getDate().equals(dateTime.getDate());
		boolean hasEqualTimeStr24H = this.getTime24hStr().equals(dateTime.getTime24hStr());
		boolean hasEqualTimeStr12H = this.getTime12hStr().equals(dateTime.getTime12hStr());
		boolean hasEqualDayStr = this.getDayStr().equals(dateTime.getDayStr());
		boolean hasEqualDayInt = this.getDayInt() == dateTime.getDayInt();
		return hasEqualDateString && hasEqualTimeStr24H && hasEqualTimeStr12H && hasEqualDayStr && hasEqualDayInt;
	}
	
	//**********************************************
	//*************** Public Methods ***************
	//**********************************************

	/**
	 * Converts a DateTime object to string format
	 */
	public String toString() {
		String ans = this.getDate() + FORMAT_SPACE + this.getDayStr() + FORMAT_SPACE + this.getTime24hStr() + FORMAT_SPACE + this.getTime12hStr();
		return ans;
	}

	/** 
	 * Checks if the time field is initialised in this DateTime object
	 * 
	 * @return true is initialized and false otherwise.
	 */
	public boolean hasTime() {
		return this.getTimeInt() != UNINITIALIZED_INT;
	}

	/** 
	 * Checks if this DateTime object has the same date as the DateTime
	 * object passed into the method.
	 * 
	 * @param obj
	 *        A DateTime object
	 *        
	 * @return true if the 2 DateTime objects have the same date and false otherwise.
	 */
	public boolean isTheSameDateAs(DateTime obj) {
		return this.getDD() == obj.getDD() && this.getMM() == obj.getMM() && this.getYY() == obj.getYY();
	}

	/** 
	 * Increase the DD in the date field by one
	 */
	public void increaseByOneDay() {
		this.dd += 1;
		if (this.dd > daysInMonth[this.mm]) {
			this.dd = 1;
			this.mm += 1;
		}
		if (this.mm > NUM_MONTHS_IN_A_YEAR) {
			this.mm = 1;
			this.yy += 1;
		}
	}

	/** 
	 * Converts the DateTime object into string format for saving into task list
	 * @return string of DateTime object
	 */
	public String convertToSavableString() {
		String DateTimeString = "";
		DateTimeString += String.valueOf(dd) + FORMAT_SPACE;
		DateTimeString += String.valueOf(mm) + FORMAT_SPACE;
		DateTimeString += String.valueOf(yy) + FORMAT_SPACE;
		return DateTimeString;
	}
	
	
	/** 
	 * Checks if a year is an input year
	 * 
	 * @param year
	 * 		  Input year integer
	 * 
	 * @return true if it is leap year and false otherwise.
	 */
	public static boolean isLeapYear(int year) {
		int[] listOfLeapYears = new int[] { 2016, 2020, 2024, 2028, 2032, 2036, 2040, 2044, 2048, 2052, 2056, 2060, 2064, 2068, 2072, 2076, 2080, 2084, 2088, 2092, 2096 };

		boolean ans = false;
		for (int i = 0; i < listOfLeapYears.length; i++) {
			if (year < listOfLeapYears[i]) {
				break;
			}
			if (year == listOfLeapYears[i]) {
				ans = true;
				break;
			}
		} 
		return ans;
	}
	
	/** 
	 * Converts the start and end timings of a multi-day event into an
	 * ArrayList of time strings.
	 * 
	 * @param start
	 * 		  A DateTime object.
	 * 
	 * @param end
	 * 		  A DateTime object.
	 * 
	 * @return an ArrayList of 24h format time string
	 */
	public static ArrayList<String> getMultiDayString(DateTime start, DateTime end) {
		assert start.compareTo(end) == COMPARISON_FIRST_IS_BEFORE_SECOND;
		ArrayList<String> listOfTimings = new ArrayList<String>();
		DateTime startCopy = new DateTime(start);
		
		String startTimeString = startCopy.getTime24hStr();
		String endTimeString = end.getTime24hStr();
		String timeToBeAdded = startTimeString + " - " + RIGHT_BEFORE_MIDNIGHT_STRING;
		listOfTimings.add(timeToBeAdded);
		startCopy.increaseByOneDay();
		
		while(compareDates(startCopy, end) != COMPARISON_FIRST_EQUALS_SECOND) {
			timeToBeAdded = MIDNIGHT_STRING + " - " + RIGHT_BEFORE_MIDNIGHT_STRING;
			listOfTimings.add(timeToBeAdded);
			startCopy.increaseByOneDay();
		}
		timeToBeAdded = MIDNIGHT_STRING + " - " + endTimeString;
		listOfTimings.add(timeToBeAdded);
		
		return listOfTimings;
	}
	
	/** 
	 * Checks if 2 DateTime object falls on the same date to determine if an event
	 * task spans across multiple days or not.
	 * 
	 * @param start
	 * 		  A DateTime object.
	 * 
	 * @param end
	 * 		  A DateTime object.
	 * 
	 * @return true if the 2 DateTime objects have different dates and false otherwise.
	 */
	public static boolean hasMultiDay(DateTime start, DateTime end) {
		return !start.isTheSameDateAs(end);
	}
	
	/** 
	 * Checks if a DateTime object lies between a start and end DateTime objects.
	 * 
	 * @param dt
	 * 		  A DateTime object.
	 * 
	 * @param start
	 * 		  A DateTime object.
	 * 
	 * @param end
	 * 		  A DateTime object.
	 * 
	 * @return true is dt is between the start and the end
	 */
	public static boolean isWithin(DateTime dt, DateTime start, DateTime end) {
		boolean dtIsAfterStart = dt.compareTo(start) != COMPARISON_FIRST_IS_BEFORE_SECOND;
		boolean dtIsBeforeEnd = dt.compareTo(end) != COMPARISON_FIRST_IS_AFTER_SECOND;
		return dtIsAfterStart && dtIsBeforeEnd;
	}
	
	/** 
	 * Checks if a DateTime object has the same month as the specified month.
	 * 
	 * @param month
	 * 		  Month enum
	 * 
	 * @return true if the date lies on the same month and false otherwise.
	 */
	public boolean isMonth(Month month) {
		String monthString = month.name();
		String DateTimeMonth = months[this.getMM()];
		return monthString.equalsIgnoreCase(DateTimeMonth);
	}
	
	/** 
	 * Checks if a DateTime object has the same month as the specified month.
	 * 
	 * @param day
	 * 		  Day enum for day of the week
	 * 
	 * @return true if the date lies on the same day of the week and false otherwise.
	 */
	public boolean isDay(Day day) {
		String dayString = day.name();
		
		// Get the first 3 letters of the day of the week
		String DateTimeDay = daysInWeek[this.getDayInt()].substring(0, 3);
		
		return dayString.equalsIgnoreCase(DateTimeDay);
	}
	
	/** 
	 * Converts day of the week string to Day enum
	 * 
	 * @param input
	 * 		  Day of the week string
	 * 
	 * @return the respective Day Enum
	 */
	public static Day getDayType(String input) {
		Day type;
		if(input.contains(DAY_MON)) {
			type = Day.MON ;
		} else if(input.contains(DAY_TUE)) {
			type = Day.TUE;
		} else if(input.contains(DAY_WED)) {
			type = Day.WED;
		} else if(input.contains(DAY_THU)) {
			type = Day.THU;
		} else if(input.contains(DAY_FRI)) {
			type = Day.FRI;
		} else if(input.contains(DAY_SAT)) {
			type = Day.SAT;
		} else if(input.contains(DAY_SUN)) {
			type = Day.SUN;
		} else {
			type = Day.INVALID;
		}
		return type;
	}
	
	/** 
	 * Converts month of the year string to Month enum
	 * 
	 * @param input
	 * 		  Month of the year string
	 * 
	 * @return the respective Month Enum
	 */
	public static Month getMonthType(String input) {
		Month type;
		if(input.contains(MONTH_JAN)) {
			type = Month.JAN;
		} else if(input.contains(MONTH_FEB)) {
			type = Month.FEB;
		} else if(input.contains(MONTH_MARCH)) {
			type = Month.MAR;
		} else if(input.contains(MONTH_APR)) {
			type = Month.APR;
		} else if(input.contains(MONTH_MAY)) {
			type = Month.MAY;
		} else if(input.contains(MONTH_JUN)) {
			type = Month.JUN;
		} else if(input.contains(MONTH_JUL)) {
			type = Month.JUL;
		} else if(input.contains(MONTH_AUG)) {
			type = Month.AUG;
		} else if(input.contains(MONTH_SEP)) {
			type = Month.SEP;
		} else if(input.contains(MONTH_OCT)) {
			type = Month.OCT;
		} else if(input.contains(MONTH_NOV)) {
			type = Month.NOV;
		} else if(input.contains(MONTH_DEC)) {
			type = Month.DEC;
		} else {
			type = Month.INVALID;
		}
		return type;
	}
	
	/** 
	 * Sets date of this DateTime object to the same date as the DateTime object
	 * 
	 * @param start
	 * 		  A DateTime object
	 */
	public void setDate(DateTime start) {
		this.dd = start.getDD();
		this.mm = start.getMM();
		this.yy = start.getYY();
	}

	/** 
	 * Sets time of this DateTime object to the same time as the DateTime object
	 */
	public void setTimeToMidnight() {
		this.timeInt = MIDNIGHT_INT;
	}

	/** 
	 * Sets time of this DateTime object to right before midnight
	 */
	public void setTimeToRightBeforeMidnight() {
		this.timeInt = RIGHT_BEFORE_MIDNIGHT_INT;
	}
	
	/** 
	 * Checks if there is an overlap between the first start and end date and timings and the
	 * second start and end timings. This is to check if 2 events overlap.
	 * 
	 * @param startOne
	 * 		  A DateTime object
	 * 
	 * @param endOne
	 *  	  A DateTime object
	 *  
	 * @param startTwo
	 *        A DateTime object
	 *        
	 * @param endTwo
	 *        A DateTime object
	 *        
	 * @return true if there is an overlap and false otherwise.
	 */
	public static boolean isOverlap(DateTime startOne, DateTime endOne, DateTime startTwo, DateTime endTwo) {
		boolean startOneIsBeforeEndTwo = startOne.compareTo(endTwo) == COMPARISON_FIRST_IS_BEFORE_SECOND;
		boolean endOneIsAfterEndTwo = endOne.compareTo(endTwo) == COMPARISON_FIRST_IS_AFTER_SECOND;
		boolean firstIntervalIsAfterSecond = !startOneIsBeforeEndTwo && endOneIsAfterEndTwo;
		
		boolean startOneIsBeforeStartTwo = startOne.compareTo(startTwo) == COMPARISON_FIRST_IS_BEFORE_SECOND;
		boolean endOneIsBeforeStartTwo = endOne.compareTo(startTwo) != COMPARISON_FIRST_IS_AFTER_SECOND;
		boolean firstIntervalIsBeforeSecond = startOneIsBeforeStartTwo && endOneIsBeforeStartTwo;
		
		boolean hasNoOverlap = firstIntervalIsAfterSecond || firstIntervalIsBeforeSecond;
		return !hasNoOverlap;
	}
	
	/** 
	 * Checks if the deadline lies within the event start and end date and timings.
	 * 
	 * @param deadline
	 * 	      A DateTime object
	 * 
	 * @param start
	 * 	      A DateTime object
	 * 
	 * @param end
	 * 	      A DateTime object
	 * 
	 * @return true if there is an overlap and false otherwise.
	 */
	public static boolean isOverlap(DateTime deadline, DateTime start, DateTime end) {
		boolean deadlineIsBeforeStart = deadline.compareTo(start) == COMPARISON_FIRST_IS_BEFORE_SECOND;
		boolean deadlineIsAfterEnd = deadline.compareTo(end) == COMPARISON_FIRST_IS_AFTER_SECOND;
		return deadlineIsBeforeStart || deadlineIsAfterEnd;
	}
	
	/** 
	 * Checks if the DateTime object passed in has the specified day of the week int passed in
	 * 
	 * @param dateTime
	 * 		  A DateTime object
	 * 
	 * @param day
	 * 		  Day of the week in int form
	 * 
	 * @return true if the DateTime object lies on the same day as the day int passed in.
	 */
	public static boolean isSpecifiedDay(DateTime dateTime, int day) {
		return dateTime.getDayInt() == day;
	}
	
	//**********************************************
	//************** Private Methods ***************
	//**********************************************
	
	/** 
	 * Converts Day enum to respective day int.
	 * 
	 * @param day
	 * 		  Day of the week in int form.
	 * 
	 * @return the day of the week in int form.
	 */
	private static int convertDayEnumToInt(Day day) {
		String dayEnumString = day.toString().toLowerCase();
		int dayEnumInt = UNINITIALIZED_INT;
		for (int i = 1; i < daysInWeek.length; i++) {
			String daysInWeekString = daysInWeek[i].toLowerCase();
			if (daysInWeekString.contains(dayEnumString)) {
				dayEnumInt = i;
				break;
			}
		}
		return dayEnumInt;
	}
	
	/** 
	 * Gets the hour value of a timeInt
	 * 
	 * @param time
	 * 		  24h time int
	 * 
	 * @return returns the hour time value.
	 */
	private int getHourNumeral(int time) {
		return time / 100;
	}
	
	/** 
	 * Gets the minutes value of a time int
	 * 
	 * @param time
	 * 		  24h time int
	 * 
	 * @return the minute time value.
	 */
	private int getMinutesNumeral(int time) {
		return time % 100;
	}

	/** 
	 * Calculates the day of the week that the date falls on. 
	 * Eg. Given 17/2/2016, method will return 3 indicating wed
	 * 
	 * @return day of the week in int formg
	 */
	private int getDayOfWeekFromADate() {
		int[] dayTable = new int[] { 7, 1, 2, 3, 4, 5, 6 };
		int[] monthTable = new int[] {UNINITIALIZED_INT, 6, 2, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4};
		
		int lastTwoDigitsOfYear = this.yy % 1000;
		int divideLastTwoDigitsOfYearByFour = lastTwoDigitsOfYear / 4;
		int sum = lastTwoDigitsOfYear + divideLastTwoDigitsOfYearByFour + this.dd + monthTable[this.mm];
		if(DateTime.isLeapYear(this.yy) && this.mm <= 2 && this.dd <= 31) {
			sum--;
		}
		return dayTable[sum % NUMBER_OF_DAYS_IN_WEEK];
	}
}
```
###### src\dooyit\parser\AddCategoryParser.java
``` java
package dooyit.parser;

import java.util.logging.Level;
import java.util.logging.Logger;

import dooyit.common.utils.CommandUtils;
import dooyit.logic.commands.Command;

/**
 * The AddCategoryParser class takes in an "addcat" command input and
 * returns a Command object. It is needed for adding a category and
 * specifying the category colour. It implements the ParserCommons
 * interface to use the shared constants and share methods.
 * 
 * @author Annabel
 *
 */
public class AddCategoryParser implements ParserCommons {
	// Error Messages
	private static final String ERROR_MESSAGE_INVALID_ADDCAT_COMMAND = "Invalid addcat command!";
	private static final String ERROR_MESSAGE_TOO_MANY_WORDS = "Category name can only be one word!";

	// Index of Category Name and Colour in a userInput String array
	private static final int INDEX_NAME = 0;
	private static final int INDEX_COLOUR = 1;

	// Constant of the maximum number of words
	// allowed in an AddCategory command input
	private static final int MAXIMUM_NUMBER_OF_WORDS = 2;

	// Logger for AddCategoryParser
	private static Logger logger = Logger.getLogger("AddCategoryParser");

	// Attributes of an AddCategoryParser object
	private String userInput;
	private String categoryName;
	private String categoryColour;
	private Command command;
	private boolean hasColour;

	// Types of addcat commands
	private enum AddCategoryType {
		VALID, INVALID_TOO_MANY_WORDS, INVALID_EMPTY_STRING
	};

	/** Initializes a new AddCategoryParser object */
	public AddCategoryParser() {
		logger.log(Level.INFO, "Initialised AddCategoryParser object");
	}

	/**
	 * Parses userInput and returns correct AddCategoryCommand object
	 * 
	 * @param input
	 *        The addcat command input from the user
	 * 
	 * @return the correct AddCategoryCommand object if the command input is
	 *         valid or an invalid command object if the command input is
	 *         invalid
	 */
	public Command getCommand(String input) {
		logger.log(Level.INFO, "Getting command object from AddCategoryParser");

		// Resets object attributes for each call of the getCommand method
		resetAttributes(input);

		// Sets the categoryName and categoryColour attributes
		parse();

		// Sets the command attribute
		setToAddCategoryCommand();
		return command;
	}

	/**
	 * Sets the command attribute to either an AddCategory command object or an
	 * InvalidCommand object
	 */
	private void setToAddCategoryCommand() {
		switch (getCommandType()) {
		case VALID:
			setCreateCategoryCommand();
			break;

		case INVALID_TOO_MANY_WORDS:
			setInvalidCommand(ERROR_MESSAGE_TOO_MANY_WORDS);
			break;

		default:
			setInvalidCommand(ERROR_MESSAGE_INVALID_ADDCAT_COMMAND);
			break;
		}
	}

	/**
	 * Checks the number of words in the userInput attribute to determine if the
	 * add category command input is valid
	 * 
	 * @return the correct AddCategoryType enum constant
	 */
	private AddCategoryType getCommandType() {
		AddCategoryType type;
		if (userInput.equals(EMPTY_STRING)) {
			type = AddCategoryType.INVALID_EMPTY_STRING;
			
		} else if (userInputHasTooManyWords()) {
			type = AddCategoryType.INVALID_TOO_MANY_WORDS;
			
		} else {
			type = AddCategoryType.VALID;
		}
		return type;
	}

	/**
	 * Sets the command attribute to an InvalidCommand object.
	 * 
	 * @param errorMessage
	 *        Error message String constants defined in this class
	 */
	private void setInvalidCommand(String errorMessage) {
		command = CommandUtils.createInvalidCommand(errorMessage);
	}

	/**
	 * Sets the command attribute to the correct AddCategoryCommand object.
	 */
	private void setCreateCategoryCommand() {
		if (hasColour) {
			command = CommandUtils.createAddCategoryCommand(categoryName, categoryColour);
		} else {
			command = CommandUtils.createAddCategoryCommand(categoryName);
		}
	}

	/**
	 * Parses the userInput to set the categoryName and categoryColour
	 * attributes. Sets the hasColour boolean attribute to true if the user
	 * specified a colour.
	 */
	private void parse() {
		String[] inputArr = userInput.split("\\s+");
		categoryName = inputArr[INDEX_NAME];
		if (!isOneWordUserInput()) {
			categoryColour = inputArr[INDEX_COLOUR];
			hasColour = true;
		}
	}

	/**
	 * Sets the userInput attribute to the method parameter. Resets the
	 * hasColour and categoryColour object attributes.
	 * 
	 * @param input
	 *        The addcat command input from the user
	 */
	private void resetAttributes(String input) {
		userInput = input;
		categoryColour = EMPTY_STRING;
		hasColour = false;
	}

	/**
	 * Checks if the userInput attribute has more than the maximum number of
	 * words allowed for a AddCategory command input.
	 * 
	 * @return true if the userInput exceeds the maximum number of words and
	 *         false if the userInput does not exceed the maximum number of
	 *         words allowed.
	 */
	private boolean userInputHasTooManyWords() {
		String[] splitInput = userInput.split("\\s+");
		return splitInput.length > MAXIMUM_NUMBER_OF_WORDS;
	}

	/**
	 * Checks if the userInput is exactly one word.
	 * 
	 * @return true if the input if one word and false if it is less than or
	 *         more than one word.
	 */
	private boolean isOneWordUserInput() {
		String[] inputArr = userInput.split("\\s+");
		return inputArr.length == 1;
	}
}
```
###### src\dooyit\parser\AddEditTaskParser.java
``` java
package dooyit.parser;

import java.util.logging.Level;
import java.util.logging.Logger;

import dooyit.common.datatype.DateTime;
import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.commands.Command;

/**
 * AddEditTaskParser is the parent class of Edit and Add parser. It has
 * the methods and constants that are used by both the AddParser and 
 * EditParser classes. 
 * 
 * @author Annabel
 *
 */
public class AddEditTaskParser implements ParserCommons {
	// Markers for event and deadline tasks
	public static final String MARKER_START_EVENT = " from ";
	public static final String MARKER_END_EVENT = " to ";
	public static final String MARKER_DEADLINE_TASK = " by ";
	
	// Logger for AddEditParser
	private static Logger logger = Logger.getLogger("AddEditParser");
	
	// AddEditTaskParser object attributes
	public String userInput;
	public String taskName;
	public DateTime start;
	public DateTime end;
	public DateTime deadline;
	public Command command;
	
	/** Initializes a new AddEditTaskParser object */
	public AddEditTaskParser() {
		logger.log(Level.INFO, "Initialised AddEditTaskParser object");
	}
	
	/**
	 * Resets the object attributes to the uninitialized values.
	 */
	public void resetAttributes() {
		start = null;
		end = null;
		deadline = null;
		command = null;
		taskName = null;
		userInput = null;
	}
	
	/**
	 * Sets the userInput attribute to the string input.
	 * 
	 * @param input
	 * 		  The add command input from the user
	 */
	public void setUserInput(String input) {
		userInput = input.trim();
	}
	
	/**
	 * Gets the End date time string of an event user input
	 * 
	 * @param userInput
	 * 		  The event string input from the user
	 * 
	 * @param indexFrom
	 * 		  The integer index position of the word "from"
	 * 
	 * @param indexTo
	 * 		  The integer index position of the word "to"
	 * 
	 * @return the string containing the end DateTime
	 */
	public String getEndDateTimeString(int indexFrom, int indexTo) {
		String endTimeString;
		if (indexFrom > indexTo) {
			// For the case where user keys in "To" before "From"
			endTimeString = userInput.substring(indexTo, indexFrom).replace(MARKER_END_EVENT, EMPTY_STRING).trim();
		} else {
			// For the case where the user keys in "From" before "To"
			endTimeString = userInput.substring(indexTo).replace(MARKER_END_EVENT, EMPTY_STRING).trim();
		}
		return endTimeString;
	}

	/**
	 * Gets the Start date time string of an event user input
	 * 
	 * @param userInput
	 * 		  The event string input from the user
	 * 
	 * @param indexFrom
	 * 		  The integer index position of the word "from"
	 * 
	 * @param indexTo
	 * 		  The integer index position of the word "to"
	 * 
	 * @return the string containing the end DateTime
	 */
	public String getStartDateTimeString(int indexFrom, int indexTo) {
		String startTimeString;
		if (indexFrom > indexTo) {
			// For the case where user keys in "To" before "From"
			startTimeString = userInput.substring(indexFrom).replace(MARKER_START_EVENT, EMPTY_STRING).trim();
		} else {
			// For the case where the user keys in "From" before "To"
			startTimeString = userInput.substring(indexFrom, indexTo).replace(MARKER_START_EVENT, EMPTY_STRING).trim();
		}
		return startTimeString;
	}
	

	/**
	 * Gets the task name from an event user input
	 * 
	 * @param userInput
	 * 		  The event string input from the user
	 * 
	 * @param indexFrom
	 * 		  The integer index position of the word "from"
	 * 
	 * @param indexTo
	 * 		  The integer index position of the word "to"
	 * 
	 * @return the string containing the end DateTime
	 */
	public String getTaskName(int indexFrom, int indexTo) {
		String name;
		if (indexFrom < indexTo) {
			// For the case where user keys in "To" before "From"
			name = userInput.substring(0, indexFrom);
		} else {
			// For the case where the user keys in "From" before "To"
			name = userInput.substring(0, indexTo);
		}
		return name;
	}
	
	/**
	 * Checks if the userInput is an event task by checking if input has 
	 * BOTH the event markers "from" and "to" and checking if the words 
	 * after the respective markers are valid DateTime inputs.
	 * 
	 * @return true if input is an event task and false if it isn't
	 */
	public boolean isEvent() {
		boolean ans = false;
		if (ParserCommons.isInitialized(userInput.lastIndexOf(MARKER_START_EVENT))
				&& ParserCommons.isInitialized(userInput.lastIndexOf(MARKER_END_EVENT))) {
			ans = hasAValidDateTimeAfterEventMarkers();
		}
		return ans;
	}

	/**
	 * Checks if the string inputs after the event markers "from" and "to" are valid
	 * DateTime inputs.
	 * 
	 * @return true if both strings are valid DateTime inputs and false otherwise.
	 */
	public boolean hasAValidDateTimeAfterEventMarkers() {
		DateTimeParser dateTimeParser = new DateTimeParser();
		
		// Get the position indices of the event markers
		int indexFrom = userInput.lastIndexOf(MARKER_START_EVENT);
		int indexTo = userInput.lastIndexOf(MARKER_END_EVENT);
		
		// Get the start and end strings inputs 
		boolean ans = true;
		String startDateTimeString = getStartDateTimeString(indexFrom, indexTo);
		String endDateTimeString = getEndDateTimeString(indexFrom, indexTo);

		// Check if the start and end strings are valid DateTime inputs
		try {
			dateTimeParser.parse(startDateTimeString);
			dateTimeParser.parse(endDateTimeString);
		} catch (IncorrectInputException e) {
			ans = false;
		}
		return ans;
	}

	/**
	 * Checks if the userInput is a deadline task by checking if the input
	 * has the deadline marker "by" and checking if the words after the marker
	 * "by" are valid DateTime inputs.
	 * 
	 * @return true if the input is a deadline task and false otherwise.
	 */
	public boolean isDeadlineTask() {
		boolean ans = false;
		
		// Checks if the deadline input is a valid DateTime input
		if (ParserCommons.isInitialized(userInput.lastIndexOf(MARKER_DEADLINE_TASK))) {
			ans = hasAValidDateTimeAfterDeadlineMarker();
		}
		return ans;
	}

	/**
	 * Checks if the string input after the Deadline marker "by" is a valid
	 * DateTime input.
	 * 
	 * @return true if the string is a valid DateTime input and false otherwise.
	 */
	public boolean hasAValidDateTimeAfterDeadlineMarker() {
		DateTimeParser dateTimeParser = new DateTimeParser();
		int indexBy = userInput.lastIndexOf(MARKER_DEADLINE_TASK);
		String timeString = userInput.substring(indexBy).replace(MARKER_DEADLINE_TASK, EMPTY_STRING).trim();
		boolean ans = true;
		
		// Check if timeString is a valid DateTime input
		try {
			dateTimeParser.parse(timeString);
		} catch (IncorrectInputException e) {
			ans = false;
		}
		return ans;
	}
}
```
###### src\dooyit\parser\AddParser.java
``` java
package dooyit.parser;

import java.util.logging.Level;
import java.util.logging.Logger;

import dooyit.common.exception.IncorrectInputException;
import dooyit.common.utils.CommandUtils;
import dooyit.logic.commands.Command;

/**
 * The AddParser class takes in an "add" command input and returns a Command 
 * object. It is needed for adding floating tasks, deadline tasks and events.
 * It implements the ParserCommons interface to use the shared
 * constants and methods.
 * 
 * @author Annabel
 *
 */
public class AddParser extends AddEditTaskParser {
	// Error message
	private static final String ERROR_MESSAGE_INVALID_ADD_COMMAND = "Invalid add command!";

	// Logger for AddParser
	private static Logger logger = Logger.getLogger("AddParser");

	// Types of Add command inputs
	private enum TaskType {
		FLOATING, WORK, EVENT, INVALID
	};

	/** Initializes a new AddParser object */
	public AddParser() {
		super();
		logger.log(Level.INFO, "Initialised AddParser object");
	}

	/**
	 * Parses userInput and returns the correct AddCommand object
	 * 
	 * @param input
	 *        The add command input from the user
	 * 
	 * @return the correct AddCommand object if the command input is
	 *         valid or an invalid command object if the command input is
	 *         invalid
	 */
	public Command getCommand(String input) {
		logger.log(Level.INFO, "Getting command object from AddParser");
		resetAttributes();
		setUserInput(input);

		// Sets the command attribute to the correct command object
		setToAddCommand();

		return command;
	}

	/**
	 * Sets the command attribute to the correct type of AddCommand object or to
	 * an InvalidCommand object
	 */
	private void setToAddCommand() {
		switch (getTaskType()) {
		case FLOATING:
			parseFloat();
			setFloatCommand();
			break;

		case WORK:
			parseDeadlineTask();
			setDeadlineTaskCommand();
			break;

		case EVENT:
			try {
				parseEvent();
			} catch (IncorrectInputException e){ 
				setInvalidCommand(e.getMessage());
				break;
			}
			setEventCommand();
			break;

		default:
			setInvalidCommand(ERROR_MESSAGE_INVALID_ADD_COMMAND);
		}
	}

	/**
	 * Sets the command attribute to an InvalidCommand object
	 * 
	 * @param message
	 *        Error message that indicates why the user input is wrong.
	 */
	private void setInvalidCommand(String message) {
		command = CommandUtils.createInvalidCommand(message);
	}

	/**
	 * Sets the command attribute to an AddCommand object for events
	 */
	private void setEventCommand() {
		command = CommandUtils.createAddCommandEvent(taskName, start, end);
	}

	/**
	 * Sets the command attribute to an AddCommand object for deadline tasks
	 */
	private void setDeadlineTaskCommand() {
		command = CommandUtils.createAddCommandDeadline(taskName, deadline);
	}

	/**
	 * Sets the command attribute to an AddComamnd object for floating tasks
	 */
	private void setFloatCommand() {
		command = CommandUtils.createAddCommandFloat(taskName);
	}

	/**
	 * Parses the userInput on the assumption that it is an Event task.
	 * Sets the start and end DateTime objects and the taskName attributes
	 * to the correct values.
	 */
	private void parseEvent() throws IncorrectInputException {
		DateTimeParser dateTimeParser = new DateTimeParser();

		// Gets the position indices of the event markers "from" and "to"
		int indexFrom = userInput.lastIndexOf(MARKER_START_EVENT);
		int indexTo = userInput.lastIndexOf(MARKER_END_EVENT);

		// Sets the taskName attribute by excluding the event markers and start
		// and end date time inputs
		taskName = getTaskName(indexFrom, indexTo);

		// Gets the start and end date time string inputs
		String startDateTimeString = getStartDateTimeString(indexFrom, indexTo);
		String endDateTimeString = getEndDateTimeString(indexFrom, indexTo);

		// Sets the start and end DateTime objects
		start = dateTimeParser.parse(startDateTimeString);
		end = dateTimeParser.parse(endDateTimeString);

		// Check if end DateTime object is before start DateTime object
		if (end.compareTo(start) == BEFORE) {
			// Set date of end DateTime object to the date of start DateTime
			// object. 
			end.setDate(start);
		}
		
		// Check if end DateTime object is before start DateTime object
		// Timing of end DateTime object may be before timing of start DateTime object.
		if (end.compareTo(start) == BEFORE) {
			throw new IncorrectInputException(ERROR_MESSAGE_END_BEFORE_START);
		}
		setUninitializedTimeToDefault();
	}
	
	/**
	 * Sets the uninitialized timings of an event to the default timings of
	 * 00:00 for the start timing and 23:59 for end timing.
	 */
	private void setUninitializedTimeToDefault() {
		if (start.getTimeInt() == UNINITIALIZED_INT) {
			start.setTimeToMidnight();
		}
		if (end.getTimeInt() == UNINITIALIZED_INT) {
			end.setTimeToRightBeforeMidnight();
		}
	}

	/**
	 * Parses the userInput on the assumption that it is a deadline task.
	 * Sets the deadline and taskName attributes from the userInput
	 */
	private void parseDeadlineTask() {
		DateTimeParser dateTimeParser = new DateTimeParser();
		int indexBy = userInput.lastIndexOf(MARKER_DEADLINE_TASK);
		taskName = userInput.substring(START_OF_STRING, indexBy);
		String deadlineString = userInput.substring(indexBy).replace(MARKER_DEADLINE_TASK, EMPTY_STRING).trim();
		deadline = dateTimeParser.parse(deadlineString);
	}

	/**
	 * Parses userInput on the assumption that it is a floating task
	 */
	private void parseFloat() {
		taskName = userInput;
	}

	/**
	 * Checks if the userInput is a addCommand input for a floating task,
	 * deadline task or an event task.
	 * 
	 * @return the correct TaskType enum constant.
	 */
	private TaskType getTaskType() {
		TaskType type;
		if (isEvent()) {
			type = TaskType.EVENT;

		} else if (isDeadlineTask()) {
			type = TaskType.WORK;

		} else if (isFloating()) {
			type = TaskType.FLOATING;

		} else {
			type = TaskType.INVALID;
		}
		return type;
	}
	
	/**
	 * Checks if the userInput is a floating task
	 * 
	 * @return true if input is a floating task and false if it isn't.
	 */
	private boolean isFloating() {
		return !userInput.equals(EMPTY_STRING) && !isEvent()
				&& !isDeadlineTask();
	}
}
```
###### src\dooyit\parser\DateTimeParser.java
``` java
package dooyit.parser;

import dooyit.parser.DateTimeParserCommons;
import java.util.logging.Level;
import java.util.logging.Logger;
import dooyit.common.datatype.DateTime;
import dooyit.common.exception.IncorrectInputException;

/**
 * DateTimeParses parses date time user inputs and returns a DateTime object.
 * It calls on RelativeDateParser, FixedDateParser and TimeParser to parse the
 * relevant inputs. It implements DateTimeparserCommons and ParserCommons
 * to use the shared methods and constants.
 * 
 * @author Annabel
 *
 */
public class DateTimeParser implements DateTimeParserCommons, ParserCommons {
	// Error messages
	private static final String ERROR_MESSAGE_ONLY_ONE_DATE = "You can only key in ONE date!";
	private static final String ERROR_MESSAGE_ONLY_ONE_TIMING = "You can only key in ONE timing!";
	private static final String ERROR_MESSAGE_INVALID_DATE_TIME = "Invalid Date Time!";

	// DateTime object attributes
	private DateTime dateTime;
	private RelativeDateParser relativeDateParser;
	private TimeParser timeParser;
	private FixedDateParser fixedDateParser;
	
	// Starting value for counter in combined array
	private static final int STARTING_ARRAY_INDEX_FOR_COMBINED_ARRAY = 0;

	// Logger for DateTimeParser
	private static Logger logger = Logger.getLogger("DateTimeParser");

	// DateTimeParser object attributes
	private int currMM;
	private int currYY;
	private int currDD;
	private int currDayInWeekInt;
	private int currTime;
	private boolean hasDate, hasTime;

	/** Types of DateTime formats */
	private enum DateTimeFormat {
		TYPE_RELATIVE_DATE, TYPE_FIXED_DATE, TYPE_TIME, TYPE_INVALID
	};

	/** Initializes a DateTimeParser object with today's date */
	public DateTimeParser() {
		dateTime = new DateTime();
		currTime = dateTime.getTimeInt();
		currDayInWeekInt = dateTime.getDayInt();
		currDD = dateTime.getDD();
		currMM = dateTime.getMM();
		currYY = dateTime.getYY();

		relativeDateParser = new RelativeDateParser(dateTime);
		timeParser = new TimeParser();
		fixedDateParser = new FixedDateParser(dateTime);
		hasTime = false;
		hasDate = false;

		logger.log(Level.INFO, "Initialised DateTimeParser object with today's date");
	}

	/**
	 * Initializes a DateTimeParser object with the specified date and time in
	 * the DateTime object
	 * 
	 * @param dateTime
	 * 		  DateTime object to specify a date and time
	 */
	public DateTimeParser(DateTime dateTime) {
		this.dateTime = dateTime;
		currTime = dateTime.getTimeInt();
		currDayInWeekInt = dateTime.getDayInt();
		currDD = dateTime.getDD();
		currMM = dateTime.getMM();
		currYY = dateTime.getYY();

		relativeDateParser = new RelativeDateParser(this.dateTime);
		timeParser = new TimeParser();
		fixedDateParser = new FixedDateParser(this.dateTime);
		hasTime = false;
		hasDate = false;

		logger.log(Level.INFO, "Initialised DateTimeParser object with the date " + dateTime.toString());
	}

	/**
	 * Parses a user input and returns a DateTime object if the input is a valid
	 * date time input or throws and exception if the user input is an invalid
	 * date time input.
	 * 
	 * @param input
	 * 		  The user string input for date time
	 * 
	 * @return DateTime object of the user string input for date time.
	 * 
	 * @throws IncorrectInputException if the user input is an invalid date time.
	 */
	public DateTime parse(String input) throws IncorrectInputException {
		String[] splitInput = input.toLowerCase().split("\\s+");
		int[] combined = new int[] { currDayInWeekInt, UNINITIALIZED_INT, currDD, currMM, currYY,
				STARTING_ARRAY_INDEX_FOR_COMBINED_ARRAY };
		DateTime temp;
		resetBooleanValues();
		
		try {
			combined = setCombinedArray(splitInput, combined);
			temp = getDateTimeObject(combined);
		} catch (IncorrectInputException e) {
			throw e;
		}
		return temp;
	}

	/**
	 * Converts the user input string array into an int array.
	 * 
	 * @param splitInput
	 * 		  The user input string array
	 * 
	 * @param combined
	 *        An int array that contains the day int, time int, date (DD,
	 *        MM, YY) and the current index in the user input string array.
	 *        
	 * @return combined int array with the updated values from user input 
	 * 		   String array. 
	 * 
	 * @throws IncorrectInputException if the user input has an invalid date 
	 * 		   and time.
	 */
	private int[] setCombinedArray(String[] splitInput, int[] combined) throws IncorrectInputException {
		for (int i = 0; i < splitInput.length; i++) {
			combined[COMBINED_INDEX_COUNTER] = i;
			String currWord = splitInput[i];

			switch (getDateTimeType(currWord, splitInput, i)) {
			case TYPE_RELATIVE_DATE:
				try {
					setHasDateBoolean();
				} catch (IncorrectInputException e) {
					throw e;
				}
				combined = relativeDateParser.parse(splitInput, combined, i);
				break;

			case TYPE_FIXED_DATE:
				try {
					setHasDateBoolean();
				} catch (IncorrectInputException e) {
					throw e;
				}
				combined = fixedDateParser.parse(splitInput, combined, i);
				break;

			case TYPE_TIME:
				try {
					setHasTimeBoolean();
				} catch (IncorrectInputException e) {
					throw e;
				}
				combined = timeParser.parse(splitInput, combined, i);
				break;

			default:
				throw new IncorrectInputException(ERROR_MESSAGE_INVALID_DATE_TIME);
			}

			i = combined[COMBINED_INDEX_COUNTER];
		}
		return combined;
	}

	/** 
	 * Resets the object boolean values to false.
	 */
	private void resetBooleanValues() {
		hasTime = false;
		hasDate = false;
	}

	/**
	 * Checks if the user input has more than one time input. Sets the
	 * hasTime attribute to true if it is false.
	 * 
	 * @throws IncorrectInputException
	 *         if the user input has more than one time string.
	 */
	private void setHasTimeBoolean() throws IncorrectInputException {
		if (!hasTime) {
			hasTime = true;
		} else {
			throw new IncorrectInputException(ERROR_MESSAGE_ONLY_ONE_TIMING);
		}
	}

	/**
	 * Checks if the user input has more than one date input. Sets the 
	 * hasDate attribute to true if it is false.
	 * 
	 * @throws IncorrectInputException
	 * 		   if the user input has more than one date string.
	 */		   
	private void setHasDateBoolean() throws IncorrectInputException {
		if (!hasDate) {
			hasDate = true;
		} else {
			throw new IncorrectInputException(ERROR_MESSAGE_ONLY_ONE_DATE);
		}
	}

	/**
	 * Checks the current word to see which DateTimeType it is. 
	 * 
	 * @param currWord
	 * 		  Current word in the user input string array.
	 * 
	 * @param splitUserInput
	 * 		  The user input String array.
	 * 
	 * @param index
	 *        The array index of the current word in the user input String array.
	 *        
	 * @return DateTimeFormat type.
	 */
	private DateTimeFormat getDateTimeType(String currWord, String[] splitUserInput, int index) {
		DateTimeFormat type;
		if (timeParser.isValidTime(currWord, splitUserInput, index)) {
			type = DateTimeFormat.TYPE_TIME;

		} else if (relativeDateParser.isRelativeDate(currWord, splitUserInput, index)) {
			type = DateTimeFormat.TYPE_RELATIVE_DATE;

		} else if (fixedDateParser.isFixedDate(currWord, splitUserInput, index)) {
			type = DateTimeFormat.TYPE_FIXED_DATE;

		} else {
			type = DateTimeFormat.TYPE_INVALID;
		}
		return type;
	}

	/**
	 * This method converts the combined array into a DateTime object.
	 * 
	 * @param combined
	 *        An int array that contains the day int, time int, date (DD,
	 *        MM, YY) and the current index in the user input string array.
	 *        
	 * @return
	 * @throws IncorrectInputException
	 */
	private DateTime getDateTimeObject(int[] combined) throws IncorrectInputException {
		DateTime dateTime;
		int[] date = new int[] { combined[COMBINED_INDEX_DD], combined[COMBINED_INDEX_MM],
				combined[COMBINED_INDEX_YY] };
		int time = combined[COMBINED_INDEX_TIME];

		if (inputTimeIsOverToday(time, date) && !hasDate) {
			date = DateTimeParserCommons.getDateAfterANumberOfDays(NEXT_DAY, currDD, currMM, currYY);
			dateTime = new DateTime(date, time);
		} else {
			dateTime = new DateTime(date, time);
		}

		return dateTime;
	}

	/**
	 * Checks if the input time is over relative to the present time.
	 * 
	 * @param inputTime
	 * 		  The time string from the user input.
	 * 
	 * @param date
	 *        An int array containing a date in the form of DD, MM and YY.
	 *        
	 * @return true if the current time is after the present time.
	 */
	private boolean inputTimeIsOverToday(int inputTime, int[] date) {
		return currTime > inputTime && inputDateIsToday(date) && inputTime != UNINITIALIZED_INT;
	}

	/**
	 * Checks if the date string from the user input is today.
	 * 
	 * @param date
	 *        An int array containing a date in the form of DD, MM and YY.
	 *        
	 * @return true if the user input is today and false otherwise.
	 */
	private boolean inputDateIsToday(int[] date) {
		return date[DATE_INDEX_OF_DD] == currDD && date[DATE_INDEX_OF_MM] == currMM 
				&& date[DATE_INDEX_OF_YY] == currYY;
	}
}
```
###### src\dooyit\parser\DateTimeParserCommons.java
``` java
package dooyit.parser;

import dooyit.common.datatype.DateTime;

/** 
 * DateParserCommons interface contains methods and constants that are shared 
 * by DateTimeParser, RealtiveDateParser, FixedDateParser and TimeParser.
 * 
 * @author Annabel
 *
 */
public interface DateTimeParserCommons {
	// Index of elements in the Combined int array
	public static final int COMBINED_INDEX_DAY_OF_WEEK = 0;
	public static final int COMBINED_INDEX_TIME = 1;
	public static final int COMBINED_INDEX_DD = 2;
	public static final int COMBINED_INDEX_MM = 3;
	public static final int COMBINED_INDEX_YY = 4;
	public static final int COMBINED_INDEX_COUNTER = 5;

	// Index of elements in the date int array
	public static final int DATE_INDEX_OF_DD = 0;
	public static final int DATE_INDEX_OF_MM = 1;
	public static final int DATE_INDEX_OF_YY = 2;

	// Constant for uninitialized int attributes and variables
	public static final int DUMMY_INT = -1;
	public static final String DUMMY_STRING = "";

	// Constant for the fast forwarding to the next day
	public static final int NEXT_DAY = 1;

	// For the iteration of array constants
	public static final int STARTING_VALUE_OF_ARRAY_CONSTANTS = 1;

	// Constants indicating number of elements in week, month and year
	public static final int NUMBER_OF_DAYS_IN_A_MONTH_MAXIMUM = 31;
	public static final int NUMBER_OF_DAYS_IN_WEEK = 7;
	public static final int NUMBER_OF_MONTHS_IN_A_YEAR = 12;

	// Array constants
	public static final String[] monthsInYear = new String[] { DUMMY_STRING, "jan", "feb", "mar", "apr", "may", "jun",
			"jul", "aug", "sep", "oct", "nov", "dec" };
	public static final int[] daysInMonthNonLeapYear = new int[] { DUMMY_INT, 31, 28, 31, 30, 31, 30, 31, 31,
			30, 31, 30, 31 };
	public static final int[] daysInMonthLeapYear = new int[] { DUMMY_INT, 31, 29, 31, 30, 31, 30, 31, 31, 30,
			31, 30, 31 };

	// Time markers
	public static final String TIME_SEPARATOR_DOT = ".";
	public static final String TIME_SEPARATOR_COLON = ":";

	// Time indicators of morning and afternoon
	public static final String PM = "pm";
	public static final String AM = "am";
	
	/** 
	 * Checks if the is another word in the array after the current index.
	 * 
	 * @param arr
	 * 		  The String array of the date time inputs
	 * 
	 * @param index
	 * 		  The index of the current word.
	 * 
	 * @return true if there is another word after the current word and false 
	 * 		   otherwise.
	 */
	static boolean hasAWordAfterCurrWord(String[] arr, int index) {
		return index < arr.length - 1;
	}
	
	/**
	 * Puts the date array elements and the day int into the combined int array.
	 * 
	 * @param combined
	 *        An int array that contains the day int, time int, date (DD,
	 *        MM, YY) and the current index in the user input string array.
	 *
	 * @param date
	 *        An int array containing a date in the form of DD, MM and YY.
	 * 
	 * @param day
	 *        Integer indicating the day of the week.
	 * 
	 * @return int array with the new values from the date array and the day
	 *         int.
	 */
	static int[] getNewCombinedArray(int[] combined, int[] date, int day) {
		return new int[] { day, combined[COMBINED_INDEX_TIME], date[DATE_INDEX_OF_DD], date[DATE_INDEX_OF_MM],
				date[DATE_INDEX_OF_YY], combined[COMBINED_INDEX_COUNTER] };
	}

	/**
	 * Puts the date array elements, day int and index into the combined int
	 * array.
	 * 
	 * @param combined
	 *        An int array that contains the day int, time int, date (DD,
	 *        MM, YY) and the current index in the user input string array.
	 *
	 * @param date
	 *        An int array containing a date in the form of DD, MM and YY.
	 *        
	 * @param day
	 *        Integer indicating the day of the week.
	 * 
	 * @param index
	 *        Current index in the user input string array.
	 * 
	 * @return int array with the new values from the date array, the day int
	 *         and the index.
	 */
	static int[] getNewCombinedArray(int[] combined, int[] date, int day, int index) {
		return new int[] { day, combined[COMBINED_INDEX_TIME], date[DATE_INDEX_OF_DD], date[DATE_INDEX_OF_MM],
				date[DATE_INDEX_OF_YY], index };
	}
	
	/**
	 * Checks if the word contains the noon or morning indicators or if it
	 * contains the time markers.
	 * 
	 * @param currWord
	 * 		  One word from the user input string.
	 * 
	 * @return true if any of the conditions are met and false otherwise.
	 */
	static boolean isValidTime(String currWord) {
		boolean ans = currWord.contains(PM) || currWord.contains(AM);
		ans = ans || currWord.contains(TIME_SEPARATOR_COLON) || currWord.contains(TIME_SEPARATOR_DOT);
		return ans;
	}
	
	/**
	 * Checks if the year is a leap year and returns the correct int array.
	 * 
	 * @param yy
	 *        The year input from the user.
	 * 
	 * @return the int array with 29 days for Feb if the year input is a leap
	 *         year or 28 days for Feb if the year input is not a leap year.
	 */
	static int[] getDaysInMonthArray(int yy) {
		int[] ans;
		if(DateTime.isLeapYear(yy)) {
			ans = daysInMonthLeapYear;
		} else {
			ans = daysInMonthNonLeapYear;
		}
		return ans;
	}
	
	/**
	 * Calculates the correct day of the week int for the next day
	 * 
	 * @param day
	 *        Today's day of the week in int
	 * 
	 * @return the day of the week for the next day.
	 */
	static int getNextDayInt(int day) {
		day += 1;
		day %= NUMBER_OF_DAYS_IN_WEEK ;
		return day;
	}

	/**
	 * Calculates the date after fast forwarding a given number of days from the
	 * current date.
	 * 
	 * @param fastForward
	 * 		  The number of days to fast forward from the current date
	 * 
	 * @param day
	 * 		  The DD of the present date.
	 * 
	 * @param month
	 * 		  The MM of the present date.
	 * 
	 * @param year
	 * 		  The YY of the present date.
	 * 
	 * @return int array of the future date.
	 */
	static int[] getDateAfterANumberOfDays(int fastForward, int day, int month, int year) {
		int newDay = day + fastForward;
		int newMonth = month;
		int newYear = year;
		
		// Getting the correct days in month int array
		int[] daysInMonth = getDaysInMonthArray(newYear);

		while (newDay > daysInMonth[newMonth]) {
			newDay -= daysInMonth[newMonth];
			newMonth += 1;
			
			// Check if newMonth exceeds the number of months in a year
			if (newMonth > NUMBER_OF_MONTHS_IN_A_YEAR) {
				newMonth = 1;	// Reset month to January
				newYear += 1;	// Increment year by 1
				daysInMonth = getDaysInMonthArray(newYear);	// Update array
			}
		}

		int[] ans = new int[] { newDay, newMonth, newYear };
		return ans;
	}
	
	/**
	 * Checks if the input is a valid number
	 * 
	 * @param currWord
	 * 		  A string input from the user
	 * 
	 * @return true if currWord is a valid number, and false
	 * 		   otherwise.
	 */
	static boolean isNumber(String currWord) {
		return currWord.matches("[0-9]+");
	}
}
```
###### src\dooyit\parser\DeleteCategoryParser.java
``` java
package dooyit.parser;

import java.util.logging.Level;
import java.util.logging.Logger;

import dooyit.common.utils.CommandUtils;
import dooyit.logic.commands.Command;

/**
 * The DeleteCategoryParser class provides methods for deleting a category. 
 * It takes in a "deletecat" command input and returns a Command 
 * object. It implements the ParserCommons interface to use the shared
 * constants and methods.
 * 
 * @author Annabel
 *
 */
public class DeleteCategoryParser implements ParserCommons {
	// Error message
	private static final String ERROR_MESSAGE_INVALID_DELETE_CATEGORY_COMMAND = "Invalid Delete Category Command!";

	// Logger for DeleteCategoryParser
	private static Logger logger = Logger.getLogger("DeleteCategoryParser");
	
	/** Initializes a new DeleteCategoryParser object */
	public DeleteCategoryParser() {
		logger.log(Level.INFO, "Initialised DeleteCategoryParser object");
	}
	
	/**
	 * Parses userInput and returns correct AddCommand object
	 * 
	 * @param input
	 *        The deletecat command input from the user
	 * 
	 * @return the correct DeleteCategoryCommand object if the command input is
	 *         valid or an invalid command object if the command input is
	 *         invalid
	 */
	public Command getCommand(String input) {
		logger.log(Level.INFO, "Getting command object from DeleteCategoryParser");
		Command command = null;
		
		if (input.equals(EMPTY_STRING)) {
			command = CommandUtils.createInvalidCommand(ERROR_MESSAGE_INVALID_DELETE_CATEGORY_COMMAND);
		} else {
			command = CommandUtils.createDeleteCategoryCommand(input);
		}
		return command;
	}
}
```
###### src\dooyit\parser\DeleteParser.java
``` java
package dooyit.parser;

import java.util.logging.Level;
import java.util.logging.Logger;

import dooyit.common.exception.IncorrectInputException;
import dooyit.common.utils.CommandUtils;
import dooyit.logic.commands.Command;

/**
 * The DeleteParser class takes in a "delete" or "remove" or "rm" 
 * command input and returns a Command object. It is needed
 * for deleting tasks. It is a child class of the TagParser class.
 * 
 * @author Annabel
 *
 */
public class DeleteParser extends TagParser {
	// Error message
	private static final String ERROR_MESSAGE_INVALID_DELETE_COMMAND = "Invalid Delete Command!";
	
	// Logger for DeleteParser
	private static Logger logger = Logger.getLogger("DeleteParser");

	/** Initializes a new DeleteParser object */
	public DeleteParser() {
		super();
		logger.log(Level.INFO, "Initialised DeleteParser object");
	}

	/**
	 * Parses userInput and returns a DeleteCommand object
	 * 
	 * @param input
	 * 		  The delete command input from the user
	 * 
	 * @return a DeleteCommand object if the taskIds are valid
	 * 		   or an InvalidCommand object if the taskIds are invalid.
	 */
	public Command getCommand(String input) {
		logger.log(Level.INFO, "Getting command object from DeleteParser");
		// Reset object attributes for each call to the getCommand method
		setAttributesForTagging(input);
		resetCommandAttributeToNull();
		
		setCommandAttribute();
		return command;
	}

	/**
	 * Sets command attribute to a DeleteCommand or to an InvalidCommand
	 */
	private void setCommandAttribute() {
		// Checks if the taskIds are valid
		try {
			parseTaskIds();
		} catch (IncorrectInputException e) {
			setToInvalidCommand(e.getMessage());
		}
		
		// Checks if the command has been set to InvalidCommand object
		if (command == null) {
			// Set command attribute to a DeleteCommand object 
			// if it hasn't been set set to an InvalidCommand object.
			setToDeleteCommand();
		}
	}

	/**
	 * Sets command attribute to a DeleteCommand object or to
	 * an InvalidCommand object.
	 */
	private void setToDeleteCommand() {
		switch (getTagType()) {
		case VALID :
			command = CommandUtils.createDeleteCommand(taskIdsForTagging);
			break;

		default :
			command = CommandUtils.createInvalidCommand(ERROR_MESSAGE_INVALID_DELETE_COMMAND);
			break;
		}
	}
}
```
###### src\dooyit\parser\EditCategoryParser.java
``` java
package dooyit.parser;

import java.util.logging.Level;
import java.util.logging.Logger;

import dooyit.common.utils.CommandUtils;
import dooyit.logic.commands.Command;

/** 
 * EditCategoryParser takes in "editcat" command inputs and returns a 
 * Command object. It is needed to edit category name and colour.
 * 
 * @author Annabel
 *
 */
public class EditCategoryParser {
	// Error messages
	private static final String ERROR_MESSAGE_INVALID_EDIT_CATEGORY_COMMAND = "Invalid Edit Category Command!";
	private static final String ERROR_MESSAGE_TOO_FEW_ARGUMENTS = "Too few arguments for Edit Category Command";
	private static final String ERROR_MESSAGE_BE_SUCCINCT = "Can't you be more succinct in your category naming?";
	
	// Marker to specify colour in user input
	private static final String MARKER_COLOUR = " to ";
	
	// Position indices in string array of user input
	private static final int INDEX_ORIGINAL_NAME = 0;
	private static final int INDEX_NEW_NAME = 1;
	
	// Constants of number of words allowed 
	private static final int NUMBER_OF_WORDS_INSUFFICIENT = 1;
	private static final int NUMBER_OF_WORDS_MAXIMUM = 4;
	private static final int NUMBER_OF_WORDS_FOR_NEW_AND_ORIGINAL_NAME = 2;
	
	// Possible types of edits to a category
	private static final int EDIT_TYPE_NAME_AND_COLOUR = 1;
	private static final int EDIT_TYPE_NAME_ONLY = 2;
	private static final int EDIT_TYPE_COLOUR_ONLY = 3;
	private static final int EDIT_TYPE_INVALID_TOO_MANY_WORDS = 4;
	private static final int EDIT_TYPE_INVALID_TOO_FEW_ARGUMENTS = 5;
	private static final int EDIT_TYPE_INVALID = 6;
	
	// Logger for EditCategoryParser
	private static Logger logger = Logger.getLogger("EditCategoryParser");
	
	// EditCategoryParser object attributes
	private String originalName;
	private String newName;
	private String newColour;
	private boolean hasInsufficientArguments;
	private boolean hasTooManyWordsInNewCategoryName;
	private boolean hasNewName;
	private boolean hasNewColour;
	private Command command;
	
	/** Initializes a new EditCategoryParser object */
	public EditCategoryParser() {
		logger.log(Level.INFO, "Initialised EditCategoryParser object");
	}
	
	/** 
	 * Parses the user input and returns the correct command.
	 * 
	 * @param input
	 * 		  The user input
	 * 
	 * @return the correct Command object.
	 */
	public Command getCommand(String input) {
		resetAttributes();
		setAttributes(input);
		setCommandAttribute();
		return command;
	}

	/**
	 * Sets the command attribute to the correct EditCategoryCommand object
	 * if the user input is valid or to an InvalidCommand object if the input
	 * is invalid.
	 */
	private void setCommandAttribute() {
		switch (getEditType()) {
		case EDIT_TYPE_NAME_AND_COLOUR : 
			command = CommandUtils.createEditCategoryCommand(originalName, newName, newColour);
			break;
		
		case EDIT_TYPE_NAME_ONLY :
			command = CommandUtils.createEditCategoryCommand(originalName, newName);
			break;
		
		case EDIT_TYPE_COLOUR_ONLY :
			command = CommandUtils.createEditCategoryCommand(originalName, originalName, newColour);
			break;
		
		case EDIT_TYPE_INVALID_TOO_MANY_WORDS : 
			command = CommandUtils.createInvalidCommand(ERROR_MESSAGE_BE_SUCCINCT);
			break;
		
		case EDIT_TYPE_INVALID_TOO_FEW_ARGUMENTS :
			command = CommandUtils.createInvalidCommand(ERROR_MESSAGE_TOO_FEW_ARGUMENTS);
			break;
		
		default :
			command = CommandUtils.createInvalidCommand(ERROR_MESSAGE_INVALID_EDIT_CATEGORY_COMMAND);
			break;
		}
	}

	/** 
	 * Checks the object's boolean attributes to return the 
	 * correct type of category edit.
	 * 
	 * @return the type of category edit.
	 */
	private int getEditType() {
		int editType;
		if (hasTooManyWordsInNewCategoryName) {
			editType = EDIT_TYPE_INVALID_TOO_MANY_WORDS;
			
		} else if (hasInsufficientArguments) {
			editType = EDIT_TYPE_INVALID_TOO_FEW_ARGUMENTS;
			
		} else if (hasNewName && hasNewColour) {
			editType = EDIT_TYPE_NAME_AND_COLOUR;
			
		} else if (!hasNewName && hasNewColour) {
			editType = EDIT_TYPE_COLOUR_ONLY;
			
		} else if (hasNewName && !hasNewColour) { 
			editType = EDIT_TYPE_NAME_ONLY;
			
		} else {
			editType = EDIT_TYPE_INVALID;
		}
		return editType;
	}

	/** 
	 * Checks the user input and sets the object attributes
	 * accordingly.
	 * 
	 * @param input
	 * 		  The user input.
	 */
	private void setAttributes(String input) {
		String[] inputArr = input.split("\\s+");
		originalName = inputArr[INDEX_ORIGINAL_NAME];
		if (inputArr.length == NUMBER_OF_WORDS_INSUFFICIENT) {
			hasInsufficientArguments = true;
			
		} else if (inputArr.length > NUMBER_OF_WORDS_MAXIMUM){
			hasTooManyWordsInNewCategoryName = true;
			
		} else {
			if (input.contains(MARKER_COLOUR)) {
				setNewColour(inputArr);
				setNewName(input); 
			} else {
				setNewName(inputArr);
			}
		}
	}

	/** 
	 * Sets the category name related attributes. This is for 
	 * the case where the user does NOT specify the category colour.
	 * 
	 * @param inputArr
	 * 		  The user input that is split into a String array.
	 */
	private void setNewName(String[] inputArr) {
		newName = inputArr[INDEX_NEW_NAME];
		hasNewName = true;
	}

	/** 
	 * Sets the category colour related attributes.
	 * 
	 * @param inputArr
	 * 		  The user input that is split into a String array.
	 */
	private void setNewColour(String[] inputArr) {
		int indexOfColour = inputArr.length - 1;
		newColour = inputArr[indexOfColour];
		hasNewColour = true;
	}

	/** 
	 * Sets the category name related attributes. This is for 
	 * the case where the user specifies the category colour.
	 * 
	 * @param input
	 * 		  The user input
	 */
	private void setNewName(String input) {
		int lastIndexOfMarker = input.lastIndexOf(MARKER_COLOUR);
		String firstHalfOfInput = input.substring(0, lastIndexOfMarker).trim();
		if (firstHalfOfInput.equals(originalName)) {
			hasNewName = false;
		} else {
			String[] splitFirstHalf = firstHalfOfInput.split("\\s+");
			if (splitFirstHalf.length == NUMBER_OF_WORDS_FOR_NEW_AND_ORIGINAL_NAME) {
				hasNewName = true;
				newName = splitFirstHalf[INDEX_NEW_NAME];
			} else {
				hasTooManyWordsInNewCategoryName = true;
			}
		}
	}

	/** 
	 * Resets object attributes to null or false
	 */
	private void resetAttributes() {
		command = null;
		originalName = null;
		newName = null;
		newColour = null;
		hasInsufficientArguments = false;
		hasNewName = false;
		hasNewColour = false;
		hasTooManyWordsInNewCategoryName = false;
	}
}
```
###### src\dooyit\parser\EditParser.java
``` java
package dooyit.parser;

import java.util.logging.Level;
import java.util.logging.Logger;
import dooyit.common.exception.IncorrectInputException;
import dooyit.common.utils.CommandUtils;
import dooyit.logic.commands.Command;

/**
 * EditParser takes in "edit" commands and returns a Command object.
 * It is needed to edit the name, deadline and event timings of tasks.
 * 
 * @author Annabel
 *
 */
public class EditParser extends AddEditTaskParser {
	// Error message
	private static final String ERROR_MESSAGE_INVALID_EDIT_COMMAND = "Invalid edit Command!";

	// Index of task ID in user input string array
	private static final int INDEX_OF_TASK_ID = 0;
	
	// Index of input without task ID in 2-element user input string array
	private static final int INDEX_OF_INPUT_WITHOUT_TASK_ID = 1;

	// Number of words in user input
	private static final int INSUFFICIENT_LENGTH = 1;
	
	// Marker for new task name
	private static final String MARKER_FOR_NAME = " ";
	
	// Logger for EditParser
	private static Logger logger = Logger.getLogger("EditParser");
	
	// EditParser object attributes
	private int taskId;

	/** Possible types of edits */
	private enum EditType {
		NAME, DEADLINE, TIME_START_END, NAME_TIME_START_END, NAME_DEADLINE, INVALID
	};

	/** Initializes a new EditParser object */
	public EditParser() {
		logger.log(Level.INFO, "Initialised EditParser object");
	}

	/**
	 * Parses user input and returns a command object.
	 * 
	 * @param input
	 * 		  The user input.
	 * 
	 * @return a Command object
	 */
	public Command getCommand(String input) {
		setAttributes(input);
		setCommandAttribute();
		return command;
	}

	/**
	 * Checks if the command attributes is uninitialized. If it is 
	 * uninitialized, then set the command attribute to the correct 
	 * EditCommand object.
	 */
	private void setCommandAttribute() {
		if (command == null) {
			setToCorrectEditCommand();
		}
	}

	/**
	 * Set the object attributes according to user input.
	 * Sets command to InvalidCommand if there is an Integer overflow.
	 * 
	 * @param input
	 * 		  The user input
	 */
	private void setAttributes(String input) {
		taskId = UNINITIALIZED_INT;
		setUserInput(input);

		// Check for Integer overflow
		String taskIdString = userInput.split("\\s+")[INDEX_OF_TASK_ID];
		if (ParserCommons.isNumber(taskIdString)) {
			try {
				taskId = Integer.parseInt(taskIdString);
			} catch (NumberFormatException e) {
				setInvalidCommand(ERROR_MESSAGE_INTEGER_OVERFLOW);
			}
		}
	}

	/**
	 * Checks which edit type the user input is, then parses the 
	 * input and sets the command attribute.
	 */
	private void setToCorrectEditCommand() {
		switch (getEditType()) {
		case NAME:
			parseName();
			setEditNameCommand();
			break;

		case DEADLINE:
			parseDeadline();
			setEditDeadlineCommand();
			break;

		case TIME_START_END:
			try {
				parseEventDateTime();
			} catch (IncorrectInputException e){ 
				setInvalidCommand(e.getMessage());
				break;
			}
			setEditEventCommand();
			break;

		case NAME_TIME_START_END:
			try { 
				parseNameAndEventType();
			} catch (IncorrectInputException e){ 
				setInvalidCommand(e.getMessage());
				break;
			}
			setEditNameAndEventCommand();
			break;

		case NAME_DEADLINE:
			parseNameDeadline();
			setEditNameAndDeadlineCommand();
			break;

		default:
			setInvalidCommand();
			break;
		}
	}

	/**
	 * Sets the command attribute to an InvalidComamnd object.
	 * @param message
	 */
	private void setInvalidCommand(String message) {
		command = CommandUtils.createInvalidCommand(message);
	}

	/**
	 * Sets the command attribute to an InvalidCommand object.
	 */
	private void setInvalidCommand() {
		command = CommandUtils.createInvalidCommand(ERROR_MESSAGE_INVALID_EDIT_COMMAND);
	}

	/**
	 * Sets the command attribute to an EditCommand object for editing a task
	 * name and deadline.
	 */
	private void setEditNameAndDeadlineCommand() {
		command = CommandUtils.createEditCommandNameAndDeadline(taskId, taskName, deadline);
	}

	/**
	 * Sets the command attribute to an EditCommand object for editing an event name and
	 * the event's start and end dates and timings.
	 */
	private void setEditNameAndEventCommand() {
		command = CommandUtils.createEditCommandNameAndEvent(taskId, taskName, start, end);
	}

	/**
	 * Sets the command attribute to an EditCommand object for editing an event start and 
	 * end dates and timings.
	 */
	private void setEditEventCommand() {
		command = CommandUtils.createEditCommandEvent(taskId, start, end);
	}

	/**
	 * Sets the command attribute to an EditCommand object for editing a task's deadline
	 * date and timings.
	 */
	private void setEditDeadlineCommand() {
		command = CommandUtils.createEditCommandDeadline(taskId, deadline);
	}

	/**
	 * Sets the command attribute to an EditCommand object for editing a task's name.
	 */
	private void setEditNameCommand() {
		command = CommandUtils.createEditCommandName(taskId, taskName);
	}

	/**
	 * Gets the new task name and new deadline from the user input
	 * and sets the object attributes accordingly.
	 */
	private void parseNameDeadline() {
		parseNameForDeadlineType();
		parseDeadline();
	}

	/**
	 * Gets the task name from the user input that edits both the
	 * name and deadline and sets the task name attribute.
	 */
	private void parseNameForDeadlineType() {
		int indexDeadline = getIndexOfMarker(MARKER_DEADLINE_TASK);
		int startOfName = getIndexOfName();
		taskName = userInput.substring(startOfName, indexDeadline);
	}

	/**
	 * Checks for the marker of the new name in the user input and
	 * returns the index of the name.
	 * 
	 * @return the position of the name in the user input.
	 */
	private int getIndexOfName() {
		return userInput.indexOf(MARKER_FOR_NAME) + 1;
	}

	/**
	 * Gets the new task name and new event timings from the user input
	 * and sets the object attributes accordingly.
	 */
	private void parseNameAndEventType() throws IncorrectInputException {
		parseNameForTimeStartEnd();
		parseEventDateTime();

		if (end.compareTo(start) == BEFORE) {
			end.setDate(start);
		}

		if (end.compareTo(start) == BEFORE) {
			throw new IncorrectInputException(ERROR_MESSAGE_END_BEFORE_START);
		}
	}

	/**
	 * Gets the task name from the user input that edits both the
	 * name and event timings and sets the task name attribute.
	 */
	private void parseNameForTimeStartEnd() {
		int startOfName = getIndexOfName();
		int indexFrom = getIndexOfMarker(MARKER_START_EVENT);
		int indexTo = getIndexOfMarker(MARKER_END_EVENT);
		if (indexFrom < indexTo) {
			taskName = userInput.substring(startOfName, indexFrom);
		} else {
			taskName = userInput.substring(startOfName, indexTo);
		}
	}

	/**
	 * Checks for the position of the marker like "by", "to" and 
	 * "from" in the user input and returns the index of the marker.
	 * 
	 * @param marker
	 * 		  String markers of deadline tasks or events
	 * 
	 * @return the index of the marker in the user input
	 */
	private int getIndexOfMarker(String marker) {
		return userInput.lastIndexOf(marker);
	}

	/**
	 * Parses the userInput on the assumption that it is an Event task.
	 * Sets the start and end DateTime objects attributes to the correct values.
	 */
	private void parseEventDateTime() throws IncorrectInputException {
		DateTimeParser dateTimeParser = new DateTimeParser();
		
		int indexFrom = getIndexOfMarker(MARKER_START_EVENT);
		int indexTo = getIndexOfMarker(MARKER_END_EVENT);
		String startTimeString = getStartDateTimeString(indexFrom, indexTo);
		String endTimeString =getEndDateTimeString(indexFrom, indexTo);
		start = dateTimeParser.parse(startTimeString);
		end = dateTimeParser.parse(endTimeString);

		if (end.compareTo(start) == BEFORE) {
			end.setDate(start);
		}

		if (end.compareTo(start) == BEFORE) {
			throw new IncorrectInputException(ERROR_MESSAGE_END_BEFORE_START);
		}
	}

	/**
	 * Parses the userInput on the assumption that it is a deadline task.
	 * Sets the deadline attribute from the userInput
	 */
	private void parseDeadline() {
		DateTimeParser dateTimeParser = new DateTimeParser();
		int indexDeadline = getIndexOfMarker(MARKER_DEADLINE_TASK);
		String deadlineString = getDateTimeString(indexDeadline, MARKER_DEADLINE_TASK);
		deadline = dateTimeParser.parse(deadlineString);
	}

	/**
	 * Gets just the Date and Time string from the user input.
	 *  
	 * @param index
	 * 		  Position of the marker in the user input.
	 * 
	 * @param marker
	 * 		  Marker strings "by", "from" and "to".
	 * 
	 * @return the Date and Time string like "17/4 8pm"
	 */
	private String getDateTimeString(int index, String marker) {
		return userInput.substring(index).replace(marker, EMPTY_STRING).trim();
	}

	/**
	 * Sets the taskName attribute assuming that the user input edits name only.
	 */
	private void parseName() {
		int startOfName = getIndexOfName();
		taskName = userInput.substring(startOfName);
	}

	/**
	 * Checks the user input and returns the type that indicates which edits
	 * the user is trying to do such as editing name only or editing both the name
	 * and deadline of the task.
	 * 
	 * @return the EditType of the user input.
	 */
	private EditType getEditType() {
		EditType type;
		if (isInvalidType()) {
			type = EditType.INVALID;
		} else if (hasName()) {
			if (!isEvent() && !isDeadlineTask()) {
				type = EditType.NAME;
			} else if (isEvent() && !isDeadlineTask()) {
				type = EditType.NAME_TIME_START_END;
			} else if (!isEvent() && isDeadlineTask()) {
				type = EditType.NAME_DEADLINE;
			} else {
				type = EditType.INVALID;
			}

		} else if (isDeadlineTask() && !isEvent()) {
			type = EditType.DEADLINE;

		} else if (isEvent()) {
			type = EditType.TIME_START_END;

		} else {
			type = EditType.INVALID;
		}
		return type;
	}

	/**
	 * Checks if the user input falls into any of the more common invalid cases.
	 * 
	 * @return true if the user input is one of the common invalid cases and 
	 * 		   false otherwise.
	 */
	private boolean isInvalidType() {
		boolean isEmptyString = userInput.equals(EMPTY_STRING);
		boolean hasNoTaskId = !hasTaskId(userInput);
		boolean hasTooFewWords = hasInsufficientWords();
		return isEmptyString || hasNoTaskId || hasTooFewWords;
	}

	/**
	 * Checks if the the user input has too few words which indicates that 
	 * there are missing parameters.
	 * 
	 * @return true if the user input has too few words, and false otherwise.
	 */
	private boolean hasInsufficientWords() {
		String[] split = userInput.split("\\s+");
		return split.length == INSUFFICIENT_LENGTH;
	}

	/**
	 * Checks if the user input has a valid task ID.
	 * 
	 * @param input
	 * 		  The user input
	 * 
	 * @return true if a valid numeric task ID is present, and false otherwise.
	 */
	private boolean hasTaskId(String input) {
		String[] splittedInput = userInput.split("\\s+", SPLIT_INPUT_INTO_TWO_PARTS);
		String taskId = splittedInput[INDEX_OF_TASK_ID].toLowerCase();
		return ParserCommons.isNumber(taskId);
	}

	/**
	 * Checks if the user input has a name specified.
	 * 
	 * @return true if the user input has a name and false otherwise.
	 */
	private boolean hasName() {
		boolean ans;
		String[] inputWithoutTaskIdArray = userInput.split(MARKER_FOR_NAME, SPLIT_INPUT_INTO_TWO_PARTS);
		String inputWithoutTaskId = inputWithoutTaskIdArray[INDEX_OF_INPUT_WITHOUT_TASK_ID];
		
		if (isDeadlineTask())  {
			ans = checkForNameForDeadlineType(inputWithoutTaskId);
			
		} else if (isEvent()) {
			ans = checkForNameForEventType(inputWithoutTaskId);
		} else {
			ans = !inputWithoutTaskId.equals(EMPTY_STRING);
		}
		return ans;
	}

	/**
	 * Checks if the user input has a name. This is in the case where the user 
	 * input specifies a new deadline timing.
	 * 
	 * @param inputWithoutTaskId
	 * 		  This is the user input that has the task ID removed.
	 * 
	 * @return true if there is a name, and false otherwise.
	 */
	private boolean checkForNameForDeadlineType(String inputWithoutTaskId) {
		boolean ans;
		int indexBy = inputWithoutTaskId.lastIndexOf(MARKER_DEADLINE_TASK.trim());
		ans = indexBy != START_OF_STRING;
		return ans;
	}

	/**
	 * Checks if the user input has a name. This is in the case where the user
	 * input specifies new event timings.
	 * 
	 * @param inputWithoutTaskId
	 * 		  This is the user input that has the task ID removed. 
	 * 
	 * @return true if there is a name, and false otherwise.
	 */
	private boolean checkForNameForEventType(String inputWithoutTaskId) {
		boolean ans;
		int indexFrom = inputWithoutTaskId.lastIndexOf(MARKER_START_EVENT.trim());
		int indexTo = inputWithoutTaskId.lastIndexOf(MARKER_END_EVENT.trim());
		if (indexTo < indexFrom) {
			ans = indexTo != START_OF_STRING;
		} else {
			ans = indexFrom != START_OF_STRING;
		}
		return ans;
	}
}
```
###### src\dooyit\parser\FixedDateParser.java
``` java
package dooyit.parser;

import java.util.logging.Level;
import java.util.logging.Logger;

import dooyit.common.datatype.DateTime;
import dooyit.common.exception.IncorrectInputException;

/**
 * FixedDateParser takes in a word input and returns an integer array [DD, MM, YY] that indicates
 * the date. It parses fixed date user inputs like "18/2/2016" or "18 May 2016".
 * It implements DateTimeparserCommons and ParserCommons to use the shared methods and constants.
 * 
 * @author Annabel
 *
 */
public class FixedDateParser implements DateTimeParserCommons, ParserCommons {
	// Error messages
	private static final String ERROR_MESSAGE_INVALID_NUMBER_OF_DATE_INPUTS = "Invalid number of date inputs";
	private static final String ERROR_MESSAGE_DATE_INPUTS_MUST_BE_NUMBERS = "Date inputs must be numbers";
	private static final String ERROR_MESSAGE_INVALID_DATE = "Invalid date!";
	private static final String ERROR_MESSAGE_DATE_INPUTS_MUST_GREATER_THAN_ZERO = "Date Inputs must be greater than 0!";
	
	// Maximum number of words in dates of the format "2 Feb 2016"
	private static final int MAXIMUM_NUMBER_OF_WORDS_IN_WORD_DATE = 2;
	
	// Constant of the minimum value for year
	private static final int YEARY_2000 = 2000;
	
	// Index of the array index in the dateWithArrayIndex array
	private static final int DATE_INDEX_OF_ARRAY_INDEX = 3;
	
	// For user inputs with just the month, the DD will be set to 15
	private static final int DEFAULT_DD_IN_MONTH = 15;
	
	// Indicator for date strings of the format 12/3/2016
	private static final String DATE_SEPARATOR = "/";
	
	// Number of numeric values in number dates of the format "12/3/2016"
	private static final int NUMBER_OF_VALUES_IN_NUMBER_DATE_INVALID = 1;
	private static final int NUMBER_OF_VALUES_IN_NUMBER_DATE_MAXIMUM = 3;

	// Logger for FixedDateParser
	private static Logger logger = Logger.getLogger("FixedDateParser");
	
	// DateTime object attributes
	private int currMM;
	private int currYY;
	private int currDD;

	/**
	 * Initializes a FixedDateParser object
	 * 
	 * @param dateTime
	 * 		  DateTime object with specified date and time.
	 */
	public FixedDateParser(DateTime dateTime) {
		currDD = dateTime.getDD();
		currMM = dateTime.getMM();
		currYY = dateTime.getYY();
		
		logger.log(Level.INFO, "Initialised FixedDateParser object");
	}

	/**
	 * Checks if the user input string array has a fixed date string.
	 * 
	 * @param currWord
	 * 		  The word of the current word in the user input string array
	 * 
	 * @param splitUserInput
	 * 		  The user input String array.
	 * 
	 * @param index
	 *        The array index of the current word in the user input String array.
	 *        
	 * @return true if the fixed date string is present in the user input and false otherwise.
	 */
	public boolean isFixedDate(String currWord, String[] splitUserInput, int index) {
		return isValidDate(currWord, splitUserInput, index);
	}

	/**
	 * Sets the fields of DD, MM and YY in the combined int array to the correct values based on
	 * the user input string array.
	 * 
	 * @param splitUserInput
	 * 		  The user input String array.
	 * 
	 * @param index
	 *        The array index of the current word in the user input String array.
	 *        
	 * @param combined
	 *        An int array that contains the day int, time int, date (DD,
	 *        MM, YY) and the current index in the user input string array.
	 *        
	 * @return the combined int array with the updated values.
	 * 
	 * @throws IncorrectInputException if the user input has an invalid fixed date string.
	 */
	public int[] parse(String[] splitUserInput, int[] combined, int index) throws IncorrectInputException {
		try {
			combined = getDate(splitUserInput, index, combined);
		} catch (IncorrectInputException e) {
			throw e;
		}
		return combined;
	}

	/**
	 * Calculates the new updated array index.
	 * 
	 * @param newDate
	 * 		  The int array with DD, MM, YY and ArrayIndex fields.
	 * 
	 * @param index
	 *        The array index of the current word in the user input String array.
	 *        
	 * @return the new array index for the combined int array.
	 */
	private int getArrayIndex(int[] newDate, int index) {
		int ans = newDate[DATE_INDEX_OF_ARRAY_INDEX] + index;
		return ans;
	}

	/**
	 * Get the day of week in int form from a date. For example the int array
	 * that represents the date "11 April 2016" will return 1 which represents Monday.
	 * 
	 * @param date
	 * 		  The int array representing a date. Contains fields DD, MM, YY.
	 * 
	 * @return the day of the week that the date falls on in int form.
	 */
	private int getDayOfWeekFromADate(int[] date) {
		DateTime dateTime = new DateTime(date);
		return dateTime.getDayInt();
	}

	/**
	 * Converts the user input string array into a dateWithArrayIndex int array.
	 * 
	 * @param splitUserInput
	 * 		  The user input String array.
	 * 
	 * @param index
	 *        The array index of the current word in the user input String array.
	 *        
	 * @return the dateWithArrayIndex with updated values.
	 * 
	 * @throws IncorrectInputException if the date in the dateWithArrayIndex int array
	 * 		   is an invalid date.
	 */
	private int[] getdateWithArrayIndex(String[] splitUserInput, int index) throws IncorrectInputException {
		String firstWord = splitUserInput[index];
		int[] dateWithArrayIndex = new int[] { UNINITIALIZED_INT, UNINITIALIZED_INT, UNINITIALIZED_INT,
				UNINITIALIZED_INT };
		try {
			if (firstWord.contains(DATE_SEPARATOR)) {
				String[] userInputForDate = firstWord.split(DATE_SEPARATOR);
				dateWithArrayIndex = getNumberDate(dateWithArrayIndex, userInputForDate);
			} else {
				dateWithArrayIndex = getWordDate(dateWithArrayIndex, index, splitUserInput);
			}
		} catch (IncorrectInputException e) {
			throw e;
		}

		dateWithArrayIndex = setUninitializedValuesToDefault(dateWithArrayIndex);
		if (isInvalidDate(dateWithArrayIndex)) {
			throw new IncorrectInputException(ERROR_MESSAGE_INVALID_DATE);
		}

		return dateWithArrayIndex;
	}

	/**
	 * Converts the user input string array into the dateWithArrayIndex int array. This is for
	 * cases where the date is a word date like "2 feb"
	 * 
	 * @param dateWithArrayIndex
	 * 		  The int array containing the date in DD, MM, YY format and also the index of the
	 * 		  current word in the array.
	 * 
	 * @param index
	 *        The array index of the current word in the user input String array.
	 * 
	 * @param splitUserInput
	 * 		  The user input String array.
	 * 
	 * @return dateWithArrayIndex int array with the value updated.
	 * 
	 * @throws IncorrectInputException values in given in the user input are invalid DD or YY values.
	 */
	private int[] getWordDate(int[] dateWithArrayIndex, int index, String[] splitUserInput)
			throws IncorrectInputException {
		int counter = 0;
		for (int j = index; j < splitUserInput.length; j++) {
			if (counter > MAXIMUM_NUMBER_OF_WORDS_IN_WORD_DATE) {
				break;
			} else {
				String currWord = splitUserInput[j];
				try {
					dateWithArrayIndex = setValuesInArray(currWord, dateWithArrayIndex);
				} catch (IncorrectInputException e) {
					throw e;
				}
			}
			counter++;
		}
		return dateWithArrayIndex;
	}

	/**
	 * 	Converts the user input string array into the dateWithArrayIndex int array. This is for
	 * cases where the date is a number date like "2/12/2016"
	 * 
	 * @param dateWithArrayIndex
	 * 		  The int array containing the date in DD, MM, YY format and also the index of the
	 * 		  current word in the array.
	 * 
	 * @param splitUserInput
	 * 		  The user input String array.
	 * 
	 * @return dateWithArrayIndex int array with the value updated.
	 * 
	 * @throws IncorrectInputException values are not numbers like "2/a/bbbb".
	 */
	private int[] getNumberDate(int[] dateWithArrayIndex, String[] splitUserInput) throws IncorrectInputException {
		if (splitUserInput.length > NUMBER_OF_VALUES_IN_NUMBER_DATE_MAXIMUM
				|| splitUserInput.length == NUMBER_OF_VALUES_IN_NUMBER_DATE_INVALID) {
			throw new IncorrectInputException(ERROR_MESSAGE_INVALID_NUMBER_OF_DATE_INPUTS);
		}
		for (int j = 0; j < splitUserInput.length; j++) {
			if (!ParserCommons.isNumber(splitUserInput[j])) {
				throw new IncorrectInputException(ERROR_MESSAGE_DATE_INPUTS_MUST_BE_NUMBERS);
			}

			dateWithArrayIndex[j] = Integer.parseInt(splitUserInput[j]);

			if (dateWithArrayIndex[j] <= 0) {
				throw new IncorrectInputException(ERROR_MESSAGE_DATE_INPUTS_MUST_GREATER_THAN_ZERO);
			}
		}
		dateWithArrayIndex[DATE_INDEX_OF_ARRAY_INDEX] += 1;
		return dateWithArrayIndex;
	}

	/**
	 * Updates the dateWithArray index array according to the type of value that the currWord is.
	 * For eg if the currWord is a valid year value, the year field will be updated.
	 * 
	 * @param currWord
	 * 		  The word of the current word in the user input string array
	 * 
	 * @param dateWithArrayIndex
	 * 		  The int array containing the date in DD, MM, YY format and also the index of the
	 * 		  current word in the array.
	 * 
	 * @return dateWithArray int array with the fields set to the correct values
	 * 
	 * @throws IncorrectInputException if the currWord is an invalid date and an invalid time.
	 */
	private int[] setValuesInArray(String currWord, int[] dateWithArrayIndex) throws IncorrectInputException {
		if (ParserCommons.isNumber(currWord)) { // currWord is either DD or YY
			int currInt = Integer.parseInt(currWord);
			try {
				dateWithArrayIndex = setDayAndYearValues(dateWithArrayIndex, currInt);
				dateWithArrayIndex[DATE_INDEX_OF_ARRAY_INDEX] += 1;
			} catch (IncorrectInputException e) {
				throw e;
			}
		} else if (isMonth(currWord) && !ParserCommons.isInitialized(dateWithArrayIndex, DATE_INDEX_OF_MM)) {
			dateWithArrayIndex[DATE_INDEX_OF_MM] = convertMonthStrToInt(currWord);
			dateWithArrayIndex[DATE_INDEX_OF_ARRAY_INDEX] += 1;
		} else {
			if (!DateTimeParserCommons.isValidTime(currWord)) {
				throw new IncorrectInputException(ERROR_MESSAGE_INVALID_DATE);
			}
		}

		return dateWithArrayIndex;
	}

	/**
	 * Converts the fixed date string from the split user input string array into the
	 * int array new date that is of the form [dd, mm, yy, arrayIndex]. Then converts the 
	 * new date array into the combined int array.
	 * 
	 * @param splitUserInput
	 * 		  The user input String array.
	 * 
	 * @param index
	 *        The array index of the current word in the user input String array.
	 *        
	 * @param combined
	 *        An int array that contains the day int, time int, date (DD,
	 *        MM, YY) and the current index in the user input string array.
	 *        
	 * @return the combined int array with the updated DD, MM, YY fields.
	 * 
	 * @throws IncorrectInputException if the user input string array does not have a 
	 * 		   valied fixed date string.
	 */
	private int[] getDate(String[] splitUserInput, int index, int[] combined) throws IncorrectInputException {
		int[] newDate;
		try {
			// int array is of the form [dd, mm, yy, arrayIndex]
			newDate = getdateWithArrayIndex(splitUserInput, index); 
			
		} catch (IncorrectInputException e) {
			throw e;
		}

		if (isInvalidDate(newDate)) {
			throw new IncorrectInputException();
		}

		return DateTimeParserCommons.getNewCombinedArray(combined, newDate, getDayOfWeekFromADate(newDate),
				getArrayIndex(newDate, combined[COMBINED_INDEX_COUNTER]));
	}

	/**
	 * Sets the DD and YY values in the dateWitArrayIndex int array.
	 * 
	 * @param dateWithArrayIndex
	 * 		  The int array containing the date in DD, MM, YY format and also the index of the
	 * 		  current word in the array.
	 * 
	 * @param currInt
	 * 		  The current int from the user input string.
	 * 		  
	 * @return the int array with the updated values for the DD and YY fields
	 * 
	 * @throws IncorrectInputException if the DD and YY fields have already been initialized or if
	 * 		   the currInt is not a valid YY or DD value.
	 */
	private int[] setDayAndYearValues(int[] dateWithArrayIndex, int currInt) throws IncorrectInputException {
		if (currInt <= NUMBER_OF_DAYS_IN_A_MONTH_MAXIMUM
				&& !ParserCommons.isInitialized(dateWithArrayIndex, DATE_INDEX_OF_DD)) {
			
			dateWithArrayIndex[DATE_INDEX_OF_DD] = currInt;

		} else if (currInt >= YEARY_2000 && !ParserCommons.isInitialized(dateWithArrayIndex, DATE_INDEX_OF_YY)) {
			dateWithArrayIndex[DATE_INDEX_OF_YY] = currInt;

		} else {
			throw new IncorrectInputException(ERROR_MESSAGE_INVALID_DATE);
		}
		return dateWithArrayIndex;
	}

	/**
	 * Checks if a YY is uninitialized, if it is, then set the value to this year or next year 
	 * depending on whether the date has passed. If the DD is uninitialized then set the value
	 * to the default value 15.
	 * 
	 * @param dateWithArrayIndex
	 * 		  The int array containing the date in DD, MM, YY format and also the index of the
	 * 		  current word in the array.
	 * 
	 * @return dateWithArrayIndex array with the uninitialized fields set to the default
	 */
	private int[] setUninitializedValuesToDefault(int[] dateWithArrayIndex) {
		if (!ParserCommons.isInitialized(dateWithArrayIndex, DATE_INDEX_OF_YY)) {
			dateWithArrayIndex[DATE_INDEX_OF_YY] = getCorrectYear(dateWithArrayIndex);
		}

		if (!ParserCommons.isInitialized(dateWithArrayIndex, DATE_INDEX_OF_DD)) {
			dateWithArrayIndex[DATE_INDEX_OF_DD] = DEFAULT_DD_IN_MONTH; 
		}
		return dateWithArrayIndex;
	}

	/**
	 * Checks if the user input date has already passed with relative to the present date. 
	 * If it has passed then return the next year and it hasn't passed then return the
	 * present year. This is to parse user inputs like "4/2" and "4 Feb" where the year
	 * is not specified.
	 * 
	 * @param dateWithArrayIndex
	 * 		  The int array containing the date in DD, MM, YY format and also the index of the
	 * 		  current word in the array.
	 * 
	 * @return this year if date hasn't passed and next year if it has passed.
	 */
	private int getCorrectYear(int[] dateWithArrayIndex) {
		int newDD = dateWithArrayIndex[DATE_INDEX_OF_DD];
		int newMM = dateWithArrayIndex[DATE_INDEX_OF_MM];
		int newYY = UNINITIALIZED_INT;
		DateTime newDateTime = new DateTime(new int[] { newDD, newMM, currYY });
		DateTime currDateTime = new DateTime(new int[] { currDD, currMM, currYY });
		
		// Check if date has passed
		if (newDateTime.compareTo(currDateTime) == UNINITIALIZED_INT) { 
			// Increase the year by one
			newYY = currYY + 1; 						
		} else {
			// Date has not passed
			// Set the year to current year
			newYY = currYY; 
		}
		return newYY;
	}

	/**
	 *  Checks that the number of months does not exceed the max number of days 
	 *  in that month. For example "30 Feb" and "100 Mar" will return false.
	 *  
	 * @param dateWithArrayIndex
	 * 		  The int array containing the date in DD, MM, YY format and also the index of the
	 * 		  current word in the array.
	 * 
	 * @return true if the date is invalid and false otherwise.
	 */
	private static boolean isInvalidDate(int[] dateWithArrayIndex) {
		int[] daysInMonth;
		int mm = dateWithArrayIndex[DATE_INDEX_OF_MM];

		boolean output = false;
		if (mm > NUMBER_OF_MONTHS_IN_A_YEAR) {
			output = true;
		} else {
			int yy = dateWithArrayIndex[DATE_INDEX_OF_YY];
			daysInMonth = DateTimeParserCommons.getDaysInMonthArray(yy);
			output = dateWithArrayIndex[DATE_INDEX_OF_DD] > daysInMonth[mm];
		}
		return output;
	}

	/**
	 * Checks if there is a valid fixed date string in the user input.
	 * 
	 * @param currWord
	 * 		  The current word in the user input string.
	 * 
	 * @param splitUserInput
	 * 		  The user input String array.
	 * 
	 * @param index
	 *        The array index of the current word in the user input String array.
	 *        
	 * @return true if there is a valid fixed date string and false otherwise.
	 */
	private boolean isValidDate(String currWord, String[] splitUserInput, int index) {
		boolean ans = false;
		if (currWord.contains(DATE_SEPARATOR)) {
			 // Date is of the format 11/2/2016
			ans = true;
		} else {
			ans = checkIfInputIsAValidWordDate(splitUserInput, index);
		}
		return ans;
	}

	/**
	 * Checks if the user input has a valid word date like "2 Feb 2016" and "2 Feb" etc.
	 * 
	 * @param splitUserInput
	 * 		  The user input String array.
	 * 
	 * @param index
	 *        The array index of the current word in the user input String array.
	 *        
	 * @return true if the user input string array contains a valid word date and 
	 * 		   false otherwise.
	 */
	private boolean checkIfInputIsAValidWordDate(String[] splitUserInput, int index) {
		int numEntries = 0;
		boolean ans = false; 
		
		for (int j = index; j < splitUserInput.length; j++) {
			if (numEntries > MAXIMUM_NUMBER_OF_WORDS_IN_WORD_DATE) {
				break;
			} else {
				String splitWord = splitUserInput[j];
				if (!ParserCommons.isNumber(splitWord) && isMonth(splitWord)) {
					ans = true;
					break;
				}
			}
			numEntries++;
		}
		return ans;
	}

	/**
	 * Checks if the current word is a month. "Feb", "March" will return true but
	 * "Fbe" will return false.
	 * 
	 * @param currWord
	 * 		  The word of the current word in the user input string array
	 * 
	 * @return true if the word is a valid month and false otherwise
	 */
	private static boolean isMonth(String currWord) {
		boolean ans = false;
		for (int i = STARTING_VALUE_OF_ARRAY_CONSTANTS; i < monthsInYear.length; i++) {
			if (currWord.contains(monthsInYear[i])) {
				ans = true;
				break;
			}
		}
		return ans;
	}

	/**
	 * Changes a month string to the respective int. For example "Feb" will return 2.
	 * 
	 * @param monthInput
	 * 		  The month string from the user
	 * 
	 * @return the int form of the month string.
	 */
	private static int convertMonthStrToInt(String monthInput) {
		int monthInt = UNINITIALIZED_INT;
		for (int j = 1; j < monthsInYear.length; j++) {
			if (monthInput.contains(monthsInYear[j])) {
				monthInt = j;
				break;
			}
		}
		return monthInt;
	}
}
```
###### src\dooyit\parser\FloatParser.java
``` java
package dooyit.parser;

import java.util.logging.Level;
import java.util.logging.Logger;
import dooyit.common.exception.IncorrectInputException;
import dooyit.common.utils.CommandUtils;
import dooyit.logic.commands.Command;


/**
 * The FloatParser takes in a "float" or "editToFloat" command input 
 * and returns a Command object. It is needed for changing 
 * deadline and event tasks into floating tasks. It is a child class 
 * of the TagParser class.
 * 
 * @author Annabel
 *
 */
public class FloatParser extends TagParser {
	// Error message
	private static final String ERROR_MESSAGE_INVALID_FLOAT_COMMAND = "Invalid float Command!";

	// Logger for FloatParser
	private static Logger logger = Logger.getLogger("FloatParser");
	
	/** Initializes a new FloatParser object */
	public FloatParser() {
		super();
		logger.log(Level.INFO, "Initialised FloatParser object");
	}

	/**
	 * Parses userInput and returns an EditToFloatCommand object
	 * 
	 * @param input
	 * 		  The float or EditToFloat command input from the user
	 * 
	 * @return an EditToFloatCommand object if the taskIds are valid
	 * 		   or an InvalidCommand object if the taskIds are invalid.
	 */
	public Command getCommand(String input) throws IncorrectInputException {
		logger.log(Level.INFO, "Getting command object from FloatParser");
		// Reset object attributes for each call to the getCommand method
		setAttributesForTagging(input);
		resetCommandAttributeToNull();
		
		// Checks if the taskIds are valid
		try {
			parseTaskIds();
		} catch (IncorrectInputException e) {
			setToInvalidCommand(e.getMessage());
		}
		
		// Checks if the command has been set to InvalidCommand object
		if (command == null) {
			// Set command attribute to a EditToFloatCommand object 
			// if it hasn't been set set to an InvalidCommand object.
			setCorrectFloatCommand(getSingleMultipleTagType());
		}
		return command;
	}
	
	/**
	 * Sets command attribute to a EditToFloatCommand object or to
	 * an InvalidCommand object.
	 */
	private void setCorrectFloatCommand(TagType tagType) {
		switch (tagType) {
		case SINGLE :
			int taskId = getSingleTaskId();
			command = CommandUtils.createEditCommandToFloat(taskId);
			break;
			
		case MULTIPLE :
			command = CommandUtils.createInvalidCommand(ERROR_MESSAGE_TOO_MANY_IDS);
			break;

		default :
			command = CommandUtils.createInvalidCommand(ERROR_MESSAGE_INVALID_FLOAT_COMMAND);
			break;
		}
	}
}
```
###### src\dooyit\parser\MarkParser.java
``` java
package dooyit.parser;

import java.util.logging.Level;
import java.util.logging.Logger;

import dooyit.common.exception.IncorrectInputException;
import dooyit.common.utils.CommandUtils;
import dooyit.logic.commands.Command;

/**
 * The MarkParser class takes in a "mark" command input and returns 
 * a Command object. It is needed to mark tasks as completed.
 * It is a child class of the TagParser class.
 * 
 * @author Annabel
 *
 */
public class MarkParser extends TagParser{
	// Error message
	private static final String ERROR_MESSAGE_INVALID_MARK_COMMAND = "Invalid mark Command!";
	
	// Logger for MarkParser
	private static Logger logger = Logger.getLogger("MarkParser");

	/** Initializes a new MarkParser object */
	public MarkParser() {
		super();
		logger.log(Level.INFO, "Initialised MarkParser object");
	}

	/**
	 * Parses userInput and returns a MarkCommand object
	 * 
	 * @param input
	 * 		  The mark command input from the user
	 * 
	 * @return a MarkCommand object if the taskIds are valid
	 * 		   or an InvalidCommand object if the taskIds are invalid.
	 */
	public Command getCommand(String input) {
		logger.log(Level.INFO, "Getting command object from MarkParser");
		// Reset object attributes for each call to the getCommand method
		setAttributesForTagging(input);
		resetCommandAttributeToNull();
		
		setCommandAttribute();
		return command;
	}

	/**
	 * Set command attribute to MarkCommand object or to InvalidCommand object
	 */
	private void setCommandAttribute() {
		// Checks if the taskIds are valid
		try {
			parseTaskIds();
		} catch (IncorrectInputException e) {
			setToInvalidCommand(e.getMessage());
		}
		
		// Checks if the command has been set to InvalidCommand object
		if (command == null) {
			// Set command attribute to a MarkCommand object 
			// if it hasn't been set set to an InvalidCommand object.
			setMarkCommand(getTagType());
		}
	}

	/**
	 * Sets command attribute to a MarkCommand object or to
	 * an InvalidCommand object.
	 */
	private void setMarkCommand(TagType tagType) {
		switch (tagType) {
		case VALID :
			command = CommandUtils.createMarkCommand(taskIdsForTagging);
			break;

		default :
			command = CommandUtils.createInvalidCommand(ERROR_MESSAGE_INVALID_MARK_COMMAND);
			break;
		}
	}
}
```
###### src\dooyit\parser\MoveParser.java
``` java
package dooyit.parser;

import java.util.logging.Level;
import java.util.logging.Logger;

import dooyit.common.exception.IncorrectInputException;
import dooyit.common.utils.CommandUtils;
import dooyit.logic.commands.Command;

/**
 * The moveParser class is needed for moving tasks into a category.
 * It takes in a "move" command input and returns a Command object. 
 * It is a child class of the TagParser class.
 * 
 * @author Annabel
 *
 */
public class MoveParser extends TagParser {
	// Error messages
	private static final String ERROR_MESSAGE_NO_CATEGORY_SPECIFIED = "No category specified!";
	private static final String ERROR_MESSAGE_INVALID_MOVE_COMMAND = "Invalid move Command!";
	
	// MoveParser object attributes
	private String categoryName;
	private String taskIds;
	private boolean hasCategory;
	
	// Logger for MoveParser
	private static Logger logger = Logger.getLogger("MoveParser");
	
	/** Initializes a new MoveParser object */
	public MoveParser() {
		super();
		logger.log(Level.INFO, "Initialised MoveParser object");
	}
	
	public Command getCommand(String input) {
		logger.log(Level.INFO, "Getting command object from MoveParser");
		parse(input);
		
		setCommandAttribute();
		return command;
	}

	/**
	 * Sets command attribute to a MoveToCategory command object 
	 * or to an InvalidCommand object
	 */
	private void setCommandAttribute() {
		if (!hasCategory) {
			setToInvalidCommand(ERROR_MESSAGE_NO_CATEGORY_SPECIFIED); 
		} else {
			setAttributesForTagging(taskIds);
			resetCommandAttributeToNull();
			
			// Checks if the taskIds are valid
			try {
				parseTaskIds();
			} catch (IncorrectInputException e) {
				setToInvalidCommand(e.getMessage()); 
			}
		}
		
		// Checks if the command has been set to InvalidCommand object
		if (command == null) {
			// Set command attribute to a MoveToCategoryCommand object 
			// if it hasn't been set to an InvalidCommand object.
			setMoveCommand(getTagType());
		}
	}
	
	/**
	 * Sets command attribute to a MoveToCategoryCommand object or to
	 * an InvalidCommand object.
	 */
	private void setMoveCommand(TagType tagType) {
		switch (tagType) {
		case VALID :
			command = CommandUtils.createMoveToCategoryCommand(taskIdsForTagging, categoryName);
			break;

		default :
			command = CommandUtils.createInvalidCommand(ERROR_MESSAGE_INVALID_MOVE_COMMAND);
			break;
		}
	}

	private void parse(String input) {
		hasCategory = false;
		String[] splitInput = input.split("\\s+");
		int indexOfCategoryName = splitInput.length - 1;
		categoryName = splitInput[indexOfCategoryName];
		
		if (ParserCommons.isNumber(categoryName) || isIntervalType(categoryName)) {
			hasCategory = false;
		} else {
			hasCategory = true;
			taskIds = input.replace(categoryName, EMPTY_STRING).trim();
		}
	}
}
```
###### src\dooyit\parser\ParserCommons.java
``` java
package dooyit.parser;

/**
 * ParserCommons interface contains all the constants and methods that
 * are shared by two or more parser classes.
 * 
 * @author Annabel
 *
 */
public interface ParserCommons {
	// Error message
	public static final String ERROR_MESSAGE_END_BEFORE_START = "End timing cannot be before Start timing";
	public static final String ERROR_MESSAGE_INTEGER_OVERFLOW = "Do you even need to sleep with that many things to do?";
	
	// Uninitialized int and String constants
	public static final int UNINITIALIZED_INT = -1;
	public static final String UNINITIALIZED_STRING = "-1";
	
	// Constant for DateTime comparison
	public static final int BEFORE = -1;
	
	// Constant for replacing words in a string
	public static final String EMPTY_STRING = "";
	
	// For splitting a String into a 2-element String array
	public static final int SPLIT_INPUT_INTO_TWO_PARTS = 2;
	
	// To get substring from the start of a string
	public static final int START_OF_STRING = 0;
	
	/**
	 * Checks if the input is a valid number
	 * 
	 * @param currWord
	 * 		  A string input from the user
	 * 
	 * @return true if currWord is a valid number, and false
	 * 		   otherwise.
	 */
	static boolean isNumber(String currWord) {
		return currWord.matches("[0-9]+");
	}
	

	/**
	 * Checks if the input has been initialized.
	 * 
	 * @param number
	 * 		  Integer that was converted from a one word String 
	 * 		  from the user input.
	 * 
	 * @return true if the number is not the uninitialized int constant.
	 */
	static boolean isInitialized(int number) {
		return number != UNINITIALIZED_INT;
	}
	

	/**
	 * Checks if the integer in the specified position of the array 
	 * has been initialized.
	 * 
	 * @param array
	 * 		  Integer array
	 * 
	 * @param index
	 * 		  Array position of the integer to be checked.
	 * 
	 * @return true if the number is not the uninitialized int constant.
	 */
	static boolean isInitialized(int[] array, int index) {
		return array[index] != UNINITIALIZED_INT;
	}
}
```
###### src\dooyit\parser\ParserController.java
``` java
package dooyit.parser;

import dooyit.logic.commands.Command;

import java.util.logging.Level;
import java.util.logging.Logger;

import dooyit.common.utils.CommandUtils;

/**
 * The ParserController class takes in the userInput and returns a Command object. 
 * For straightforward commands like help and exit, ParserController will directly 
 * parse and return the correct Command objects. For more complicated cases, 
 * ParserController will call the getCommand methods of the relevant parser objects. 
 * It implments the interface ParserCommons to use the shared constants and methods.
 * 
 * @author Annabel
 *
 */
public class ParserController implements ParserCommons {
	// Error message
	private static final String ERROR_MESSAGE_INVALID_COMMAND = "Invalid Command: ";
	
	// Index of command string in the user input string array
	private static final int INDEX_OF_COMMAND_STRING = 0;
	
	// Types of commands
	public static final String COMMAND_ADD = "add";
	public static final String COMMAND_ADD_CAT = "addcat";
	public static final String COMMAND_CLEAR = "clear";
	public static final String COMMAND_DELETE = "delete";
	public static final String COMMAND_DELETE_CAT = "deletecat";
	public static final String COMMAND_EDIT = "edit";
	public static final String COMMAND_EDIT_CAT = "editcat";
	public static final String COMMAND_EXIT = "exit";
	public static final String COMMAND_FLOAT = "float";
	public static final String COMMAND_HELP = "help";
	public static final String COMMAND_MARK = "mark";
	public static final String COMMAND_MOVE_TO_CAT = "move";
	public static final String COMMAND_REDO = "redo";
	public static final String COMMAND_SEARCH = "search";
	public static final String COMMAND_SHOW = "show";
	public static final String COMMAND_SHOW_CATEGORY = "showcat";
	public static final String COMMAND_SKIN = "skin";
	public static final String COMMAND_STORAGE = "storage"; 
	public static final String COMMAND_UNDO = "undo";
	public static final String COMMAND_UNMARK = "unmark";
	public static final String COMMAND_UNMOVE = "unmove";
	
	// String arrays of Command Aliases
	public static final String[] exitCommandAlias = new String[]{"quit", "close", COMMAND_EXIT};
	public static final String[] deleteCommandAlias = new String[]{"rm", "remove", COMMAND_DELETE};
	public static final String[] floatCommandAlias = new String[]{"edittofloat", COMMAND_FLOAT};

	// Parser object attributes
	private AddParser addParser;
	private ShowParser showParser;
	private EditParser editParser;
	private AddCategoryParser addCatParser;
	private DeleteParser deleteParser;
	private MarkParser markParser;
	private UnmarkParser unmarkParser;
	private DeleteCategoryParser deleteCatParser;
	private EditCategoryParser editCategoryParser;
	private MoveParser moveParser;
	private FloatParser floatParser;
	private SearchParser searchParser;
	private UnmoveParser unmoveParser;
	
	// Logger for ShowParser
	private static Logger logger = Logger.getLogger("ParserController");

	/** Initializes a ParserController object */
	public ParserController() {
		addParser = new AddParser();
		showParser = new ShowParser();
		editParser = new EditParser();
		addCatParser = new AddCategoryParser();
		deleteParser = new DeleteParser();
		deleteCatParser = new DeleteCategoryParser();
		markParser = new MarkParser();
		unmarkParser = new UnmarkParser();
		editCategoryParser = new EditCategoryParser();
		moveParser = new MoveParser();
		floatParser = new FloatParser();
		searchParser = new SearchParser();
		unmoveParser = new UnmoveParser();
		
		logger.log(Level.INFO, "Initialised ParserController object");
	}

	/**
	 * Parses the input string and returns the correct Command object.
	 * 
	 * @param input
	 * 		  The input from the user.
	 * 
	 * @return the correct command object.
	 */
	public Command getCommand(String input) {
		String commandString = getCommandString(input);
		String commandInput = getInputWithoutCommand(input, commandString);
		Command command = getCommand(input, commandString, commandInput);
		return command;
	}
	
	/**
	 * Extracts the command like "add", "move", "remove" etc
	 * from the input string.
	 * 
	 * @param input
	 * 		  The user input.
	 * 
	 * @return the one word command string.
	 */
	private String getCommandString(String input) {
		input = input.trim();
		
		//Splits the userInput into a 2-element String array
		String[] splittedInput = input.split("\\s+", SPLIT_INPUT_INTO_TWO_PARTS);
		return splittedInput[INDEX_OF_COMMAND_STRING].toLowerCase();
	}

	/**
	 * Checks the command type and call the getCommand method of the 
	 * relevant parser objects (if needed) to get the correct command.
	 * 
	 * @param input
	 * 		  The user input
	 * 
	 * @param commandString
	 * 		  The command string like "add", "editcat" of the user input
	 * 
	 * @param commandInput
	 * 		  The userInput with the commandString removed.
	 * 
	 * @return the correct command object.
	 */
	private Command getCommand(String input, String commandString, String commandInput) {
		Command command;
		switch (getCommandType(commandString)) {
		case COMMAND_ADD :
			command = addParser.getCommand(commandInput);
			break;
			
		case COMMAND_ADD_CAT :
			command = addCatParser.getCommand(commandInput);
			break;
			
		case COMMAND_CLEAR :
			command = CommandUtils.createClearCommand();
			break;

		case COMMAND_DELETE :
			command = deleteParser.getCommand(commandInput);
			break;
			
		case COMMAND_DELETE_CAT :
			command = deleteCatParser.getCommand(commandInput);
			break;
			
		case COMMAND_EDIT :
			command = editParser.getCommand(commandInput);
			break;
			
		case COMMAND_EDIT_CAT :
			command = editCategoryParser.getCommand(commandInput);
			break;

		case COMMAND_EXIT :
			command = CommandUtils.createExitCommand();
			break;
			
		case COMMAND_FLOAT :
			command = floatParser.getCommand(commandInput);
			break;
			
		case COMMAND_HELP :
			command = CommandUtils.createHelpCommand();
			break;
			
		case COMMAND_MARK :
			command = markParser.getCommand(commandInput);
			break;
			
		case COMMAND_MOVE_TO_CAT :
			command = moveParser.getCommand(commandInput);
			break;
			
		case COMMAND_REDO :
			command = CommandUtils.createRedoCommand();
			break;
			
		case COMMAND_SEARCH :
			command = searchParser.getCommand(commandInput);
			break;
			
		case COMMAND_SHOW :
			command = showParser.getCommand(commandInput);
			break; 
			
		case COMMAND_SHOW_CATEGORY :
			command = CommandUtils.createShowCategoryCommand(commandInput);
			break;

		case COMMAND_SKIN :
			command = CommandUtils.createChangeThemeCommand(commandInput);
			break;

		case COMMAND_STORAGE :
			command = CommandUtils.createStorageCommand(commandInput);
			break;
			
		case COMMAND_UNDO :
			command = CommandUtils.createUndoCommand();
			break;

		case COMMAND_UNMARK : 
			command = unmarkParser.getCommand(commandInput);
			break;
			
		case COMMAND_UNMOVE : 
			command = unmoveParser.getCommand(commandInput);
			break;

		default :
			command = CommandUtils.createInvalidCommand(ERROR_MESSAGE_INVALID_COMMAND + input);
		}
		return command;
	}

	/**
	 * Removes the commandString like "showcat" from the user input.
	 * 
	 * @param input
	 * 		  The user input
	 * 
	 * @param command
	 * 		  The commandString like "addcat" etc.
	 * 
	 * @return the user input without the command string.
	 */
	private String getInputWithoutCommand(String input, String command) {
		return input.substring(command.length()).trim();
	}

	/**
	 * Checks if the commandString is a recognized alias. 
	 * 
	 * @param commandString
	 * 		  String indicating the type of command
	 * 
	 * @param aliasArray
	 * 		  String array of aliases
	 * 
	 * @return true if the commandString is an alias in the array
	 * 		   and false if the commandString isn't in the array.
	 */
	public static boolean isAliasOf(String commandString, String[] aliasArray) {
		boolean ans = false;
		for(int i = 0; i < aliasArray.length; i++) {
			if(commandString.equals(aliasArray[i])) {
				ans = true;
			}
		}
		return ans;
	}
	
	/**
	 * Checks if the commandString is a recognized alias. Changes
	 * the commandString to a generic commandString if it is a 
	 * recognized alias. If the commandString isn't a recognized
	 * alias, this method will return the original string.
	 * 
	 * @param commandString
	 * 		  The String that indicates the type of user input
	 * 
	 * @return the generic commandString
	 */
	public static String getCommandType(String commandString) {
		String type;
		if (isAliasOf(commandString, exitCommandAlias)) {
			type = COMMAND_EXIT;
		} else if (isAliasOf(commandString, deleteCommandAlias)) {
			type = COMMAND_DELETE;
		} else if (isAliasOf(commandString, floatCommandAlias)) {
			type = COMMAND_FLOAT;
		} else {
			type = commandString;
		}
		return type;
	}

}
```
###### src\dooyit\parser\RelativeDateParser.java
``` java
package dooyit.parser;

import java.util.logging.Level;
import java.util.logging.Logger;

import dooyit.common.datatype.DateTime;
import dooyit.common.exception.IncorrectInputException;

/** 
 * RelativeDateParser class takes in a date string and converts it into an int array. 
 * It implements DateTimeparserCommons and ParserCommons to use the shared methods and constants.
 * 
 * @author Annabel
 *
 */
public class RelativeDateParser implements DateTimeParserCommons, ParserCommons {
	// Error message
	private static final String ERROR_MESSAGE_INVALID_DATE_INPUT = "Invalid date input!";
	
	// Array Constants
	private static final String[] validWordForDay = new String[] { "day", "days", "dd" };
	private static final String[] validWordForWeek = new String[] { "week", "weeks", "wk" };
	private static final String[] validWordForToday = new String[] { "today", "tdy"};
	private static final String[] validWordForTomorrow = new String[] { "tomorrow", "tmr"};
	private static final String[] daysInWeekShortForm = new String[] { EMPTY_STRING, "mon", "tue", "wed", "thu", "fri", "sat", "sun" };
	
	// Indicator of relative dates
	private static final String THIS = "this";
	private static final String NEXT = "next";

	// Logger for RelativeDateParser
	private static Logger logger = Logger.getLogger("RelativeDateParser");
	
	// RelativeDateParser object attributes
	private int currMM;
	private int currYY;
	private int currDD;
	private int currDayInWeekInt;
	
	/** Types of Relative Dates */
	private enum RelativeDateFormat {
		TYPE_THIS_DAY_OF_WEEK, TYPE_NEXT_DAY_OF_WEEK, TYPE_DAY_OF_WEEK, 
		TYPE_NEXT_WEEK, TYPE_NUM_DAYS, TYPE_NUM_WEEKS, TYPE_TODAY, 
		TYPE_TOMORROW, TYPE_INVALID
	};
	
	/** 
	 * Initializes a new RelativeDateParser object with a specified date and time
	 * 
	 * @param dateTime
	 * 		  DateTime object of a specified date and time
	 */
	public RelativeDateParser(DateTime dateTime) {
		currDayInWeekInt = dateTime.getDayInt();
		currDD = dateTime.getDD();
		currMM = dateTime.getMM();
		currYY = dateTime.getYY();
		
		logger.log(Level.INFO, "Initialised RelativeDateParser object with a specified date time");
	}
	
	/** 
	 * Parses the RelativeDate input and returns a combined int array.
	 * 
	 * @param splitUserInput
	 * 		  The user input string array
	 * 
	 * @param combined
	 *        An int array that contains the day int, time int, date (DD,
	 *        MM, YY) and the current index in the user input string array.
	 *        
	 * @param index
	 * 		  The array index of the current word in the user input String array.
	 * 
	 * @return the int array form of the date string from the user.
	 * 
	 * @throws IncorrectInputException if the date string isn't a valid RelativeDate type.
	 */
	public int[] parse(String[] splitUserInput, int[] combined, int index) throws IncorrectInputException {
		
		String currWord = splitUserInput[index];
		switch (getRelativeDateType(currWord, splitUserInput, index)) {
		case TYPE_THIS_DAY_OF_WEEK :
			combined = getThisDayOfWeek(splitUserInput, index, combined);
			break;

		case TYPE_NEXT_DAY_OF_WEEK :
			combined = getNextDayOfWeek(splitUserInput, index, combined);
			break;

		case TYPE_DAY_OF_WEEK :
			combined = getDayOfWeek(splitUserInput, index, combined);
			break;

		case TYPE_NEXT_WEEK :
			combined = getDateAfterOneWeek(splitUserInput, index, combined);
			break;

		case TYPE_NUM_DAYS : 
			combined = getDateAndDayAfterANumberOfDays(splitUserInput, index, combined);
			break;

		case TYPE_NUM_WEEKS :
			combined = getDateAndDayAfterNumberOfWeeks(splitUserInput, index, combined);
			break;

		case TYPE_TODAY :
			combined = getCombinedArrayForToday(combined);
			break;

		case TYPE_TOMORROW :
			combined = getCombinedArrayForTomorrow(combined);
			break;

		default :
			combined[COMBINED_INDEX_COUNTER] += 1;
			throw new IncorrectInputException(ERROR_MESSAGE_INVALID_DATE_INPUT);
		}
			
		return combined;
	}
	
	/**
	 * Checks the current word to see which RelativeDateType it is. 
	 * 
	 * @param currWord
	 * 		  Current word in the user input string array.
	 * 
	 * @param splitUserInput
	 * 		  The user input String array.
	 * 
	 * @param index
	 *        The array index of the current word in the user input String array.
	 *        
	 * @return DateTimeFormat type.
	 */
	private RelativeDateFormat getRelativeDateType(String currWord, String[] splitUserInput, int index) {
		RelativeDateFormat type;
		if (isThisMondayType(currWord, splitUserInput, index)) {
			// For parsing "this monday", "this tue" etc.
			type = RelativeDateFormat.TYPE_THIS_DAY_OF_WEEK;

		} else if (isNextWeek(currWord, splitUserInput, index)) {
			type = RelativeDateFormat.TYPE_NEXT_WEEK;

		} else if (isNextWeekday(currWord, splitUserInput, index)) {
			// For parsing "next wed", "next thur" etc.
			type = RelativeDateFormat.TYPE_NEXT_DAY_OF_WEEK;

		} else if (isValidDay(currWord)) {
			type = RelativeDateFormat.TYPE_DAY_OF_WEEK;

		} else if (isToday(currWord)) {
			type = RelativeDateFormat.TYPE_TODAY;

		} else if (isTomorrow(currWord)) {
			type = RelativeDateFormat.TYPE_TOMORROW;

		} else if (isNumberOfDays(currWord, splitUserInput, index)) {
			// For parsing "2 days", "4 day" etc.
			type = RelativeDateFormat.TYPE_NUM_DAYS;

		} else if (isNumberOfWeeks(currWord, splitUserInput, index)) {
			// For parsing "2 weeks", "4 wk" etc.
			type = RelativeDateFormat.TYPE_NUM_WEEKS;

		} else {
			type = RelativeDateFormat.TYPE_INVALID;
		}
		return type;
	}
	
	/** 
	 * Checks if the current word is a relative date string or is part of a relative date string.
	 * 
	 * @param currWord
	 * 		  Current word in the user input string array.
	 * 
	 * @param splitUserInput
	 * 		  The user input String array.
	 * 
	 * @param index
	 *        The array index of the current word in the user input String array.
	 *        
	 * @return true if current word is part of a valid relative date string and false otherwise.
	 */
	public boolean isRelativeDate(String currWord, String[] splitUserInput, int index) {
		return getRelativeDateType(currWord, splitUserInput, index) != RelativeDateFormat.TYPE_INVALID;
	}

	/**
	 * Checks if the current word is part of a date string of the format
	 * "4 days" or "4 dd" or "4 day".
	 * 
	 * @param currWord
	 *        Current word in the user input string array.
	 * 
	 * @param splitUserInput
	 *        The user input String array.
	 * 
	 * @param index
	 *        The array index of the current word in the user input String
	 *        array.
	 *        
	 * @return true if the current word is part of the stated format of date string 
	 *		   and false otherwise. 
	 */
	private boolean isNumberOfDays(String currWord, String[] splitUserInput, int index) {
		boolean ans = false;
		if (ParserCommons.isNumber(currWord) && DateTimeParserCommons.hasAWordAfterCurrWord(splitUserInput, index)) {
			int indexOfNextWord = index + 1;
			String nextWord = splitUserInput[indexOfNextWord];
			ans = checkIfWordIsInArray(nextWord, validWordForDay);
		}
		return ans;
	}

	/** 
	 * Checks if the current word is part of a date string of the format
	 * "2 weeks", "2 week" and "2 wk".
	 * 
	 * @param currWord
	 * 		  Current word in the user input string array.
	 * 
	 * @param splitUserInput
	 * 		  The user input String array.
	 * 
	 * @param index
	 *        The array index of the current word in the user input String array.
	 *        
	 * @return true if the current word is part of the stated format of date string 
	 *		   and false otherwise. 
	 */
	private boolean isNumberOfWeeks(String currWord, String[] splitUserInput, int index) {
		boolean ans = false;
		if (ParserCommons.isNumber(currWord) && DateTimeParserCommons.hasAWordAfterCurrWord(splitUserInput, index)) {
			String nextWord = splitUserInput[index + 1];
			ans = checkIfWordIsInArray(nextWord, validWordForWeek);
		}
		return ans;
	}
	
	/** 
	 * Checks if the current word is of the format "tmr" or "tomorrow".
	 * 
	 * @param currWord
	 * 		  Current word in the user input string array.
	 * 
	 * @return true if the current word is of the stated format of date string 
	 *		   and false otherwise. 
	 */
	private boolean isTomorrow(String currWord) {
		return checkIfWordIsInArray(currWord, validWordForTomorrow);
	}

	/** 
	 * Checks if the current word is of the format "tdy" or "today".
	 * 
	 * @param currWord
	 * 		  Current word in the user input string array.
	 * 
	 * @return true if the current word is of the stated format of date string 
	 *		   and false otherwise. 
	 */
	private boolean isToday(String currWord) {
		return checkIfWordIsInArray(currWord, validWordForToday);
	}
	
	/** 
	 * Checks if a word is in an array of aliases. For example, this method is used
	 * to check if "tdy" is an acceptable alias of the word "today" by checking if "tdy"
	 * if in the string array validWordForToday.
	 * 
	 * @param currWord
	 * 		  Current word in the user input string array.
	 * 
	 * @param wordArray
	 * 		  The String arrays like validWordForToday, validWordForTomorrow, validWordForWeek,
	 * 		  and validWordForDay
	 * 
	 * @return true if the word is an alias and false otherwise.
	 */
	private boolean checkIfWordIsInArray(String currWord, String[] wordArray) {
		boolean ans = false;
		for (int i = 0; i < wordArray.length; i++) {
			if (currWord.equals(wordArray[i])) {
				ans = true;
				break;
			}
		}
		return ans;
	}
	
	/** 
	 * Checks if the current word is part of a date string of the format
	 * "next tue", "next wed" etc.
	 * 
	 * @param currWord
	 * 		  Current word in the user input string array.
	 * 
	 * @param splitUserInput
	 * 		  The user input String array.
	 * 
	 * @param index
	 *        The array index of the current word in the user input String array.
	 *        
	 * @return true if the current word is part of the stated format of date string 
	 *		   and false otherwise. 
	 */
	private boolean isNextWeekday(String currWord, String[] splitUserInput, int index) {
		boolean ans = false;
		if (currWord.equals(NEXT) && DateTimeParserCommons.hasAWordAfterCurrWord(splitUserInput, index)) { 
			int indexOfNextWord = index + 1;
			String nextWord = splitUserInput[indexOfNextWord];
			ans = isValidDay(nextWord);
		}
		return ans;
	}

	/** 
	 * Checks if the current word is part of a date string of the format
	 * "next weeks", "next week" and "next wk".
	 * 
	 * @param currWord
	 * 		  Current word in the user input string array.
	 * 
	 * @param splitUserInput
	 * 		  The user input String array.
	 * 
	 * @param index
	 *        The array index of the current word in the user input String array.
	 *        
	 * @return true if the current word is part of the stated format of date string 
	 *		   and false otherwise. 
	 */
	private boolean isNextWeek(String currentWord, String[] splitUserInput, int index) {
		boolean ans = false;
		if (currentWord.equals(NEXT) && DateTimeParserCommons.hasAWordAfterCurrWord(splitUserInput, index)) {
			int indexOfNextWord = index + 1;
			String nextWord = splitUserInput[indexOfNextWord];
			ans = checkIfWordIsInArray(nextWord, validWordForWeek);
		}
		return ans;
	}
	
	// Eg. 2 weeks later
	/** 
	 * Converts date string of the formats "2 weeks", "2 wk", "2 week" into an integer array.
	 * 
	 * @param splitUserInput
	 * 		  The user input String array.
	 * 
	 * @param index
	 *        The array index of the current word in the user input String array.
	 *        
	 * @param combined
	 *        An int array that contains the day int, time int, date (DD,
	 *        MM, YY) and the current index in the user input string array.
	 *        
	 * @return integer array with the updated fields.
	 */
	private int[] getDateAndDayAfterNumberOfWeeks(String[] splitUserInput, int index, int[] combined) {
		int numWeeksLater = Integer.parseInt(splitUserInput[index]);
		int day = currDayInWeekInt;
		
		// Calculate the number of days to fast forward from the present date.
		int fastForward = getFastForwardFromDayOfWeek(day) + NUMBER_OF_DAYS_IN_WEEK * numWeeksLater;
		
		// Get the future date in an int array
		int[] date = DateTimeParserCommons.getDateAfterANumberOfDays(fastForward, currDD, currMM, currYY);
		
		// Get the integer array
		int[] ans = DateTimeParserCommons.getNewCombinedArray(combined, date, day, index + 1);
		return ans;
	}

	/** 
	 * Checks if the current word is part of a date string of the format
	 * "this tue", "this wed" etc.
	 * 
	 * @param currentWord
	 * 
	 * @param splitUserInput
	 * 		  The user input String array.
	 * 
	 * @param index
	 *        The array index of the current word in the user input String array.
	 *        
	 * @return true if the current word is part of the stated format of date string 
	 *		   and false otherwise. 
	 */
	private boolean isThisMondayType(String currentWord, String[] splitUserInput, int index) {
		boolean ans = false;
		if (currentWord.equals(THIS) && DateTimeParserCommons.hasAWordAfterCurrWord(splitUserInput, index)) { 
			int indexOfNextWord = index + 1;
			String nextWord = splitUserInput[indexOfNextWord];
			ans = isValidDay(nextWord);
		}
		return ans;
	}
	
	/** 
	 * Converts the date inputs of the format "tmr", "tomorrow" into an int array.
	 * 
	 * @param combined
	 *        An int array that contains the day int, time int, date (DD,
	 *        MM, YY) and the current index in the user input string array.
	 *        
	 * @return the combined int array with the updated date fields.
	 */
	private int[] getCombinedArrayForTomorrow(int[] combined) {
		// Get tomorrow's day of the week in int form
		int day = DateTimeParserCommons.getNextDayInt(currDayInWeekInt);
		
		// Get the future date in an int array
		int[] date = DateTimeParserCommons.getDateAfterANumberOfDays(NEXT_DAY, currDD, currMM, currYY);
		
		// Get updated combined int array
		int[] ans = DateTimeParserCommons.getNewCombinedArray(combined, date, day);
		return ans;
	}
	
	/** 
	 * Converts the date inputs of the format "tdy", "today" into an int array.
	 * 
	 * @param combined
	 *        An int array that contains the day int, time int, date (DD,
	 *        MM, YY) and the current index in the user input string array.
	 *        
	 * @return the combined int array with the updated date fields.
	 */
	private int[] getCombinedArrayForToday(int[] combined) {
		return combined;
	}
	
	/** 
	 * 	Converts the date inputs of the format "2 days", "2 day" and "2 dd" into an int array.
	 * 
	 * @param splitUserInput
	 * 		  The user input String array.
	 * 
	 * @param index
	 *        The array index of the current word in the user input String array.
	 *        
	 * @param combined
	 *        An int array that contains the day int, time int, date (DD,
	 *        MM, YY) and the current index in the user input string array.
	 *        
	 * @return the combined int array with the updated date fields.
	 */
	private int[] getDateAndDayAfterANumberOfDays(String[] splitUserInput, int index, int[] combined) {
		// Gets the number of days later
		int numDaysLater = Integer.parseInt(splitUserInput[index]);
		
		// Gets the future date's day of the week in int form
		int day = getDayOfWeekAfterANumberOfDays(numDaysLater);
		
		// Get the future date in an int array
		int[] date = DateTimeParserCommons.getDateAfterANumberOfDays(numDaysLater, currDD, currMM, currYY);
		return DateTimeParserCommons.getNewCombinedArray(combined, date, day, index + 1);
	}

	/** 
	 * Converts the date inputs of the format "next week", "next wk" into an int array.
	 * 
	 * @param splitUserInput
	 * 		  The user input String array.
	 * 
	 * @param index
	 *        The array index of the current word in the user input String array.
	 *        
	 * @param combined
	 *        An int array that contains the day int, time int, date (DD,
	 *        MM, YY) and the current index in the user input string array.
	 *        
	 * @return the combined int array with the updated date fields.
	 */
	private int[] getDateAfterOneWeek(String[] splitUserInput, int index, int[] combined) {
		int day = currDayInWeekInt;
		
		// Get the number of days to fast forward from the present date
		int fastForward = getFastForwardFromDayOfWeek(day) + NUMBER_OF_DAYS_IN_WEEK;
		
		// Get the future date in an int array
		int[] date = DateTimeParserCommons.getDateAfterANumberOfDays(fastForward, currDD, currMM, currYY);
		
		return DateTimeParserCommons.getNewCombinedArray(combined, date, day, index + 1);
	}

	/** 
	 * Converts the date inputs of the format "mon", "wednesday" etc into an int array.
	 * 
	 * @param splitUserInput
	 * 		  The user input String array.
	 * 
	 * @param index
	 *        The array index of the current word in the user input String array.
	 *        
	 * @param combined
	 *        An int array that contains the day int, time int, date (DD,
	 *        MM, YY) and the current index in the user input string array.
	 *        
	 * @return the combined int array with the updated date fields.
	 */
	private int[] getDayOfWeek(String[] splitUserInput, int index, int[] combined) {
		// Convert the input day string into integer
		int day = convertDayStringToInt(splitUserInput[index]);
		
		// Get the number of days to fast forward from the present date
		int fastForward = getFastForwardFromDayOfWeek(day);
		
		// Get the future date in an int array
		int[] date = DateTimeParserCommons.getDateAfterANumberOfDays(fastForward, currDD, currMM, currYY);
		
		return DateTimeParserCommons.getNewCombinedArray(combined, date, day, index);
	}

	/** 
	 * Converts the date inputs of the format "next mon", "next wednesday" etc into an int array.
	 * 
	 * @param splitUserInput
	 * 		  The user input String array.
	 * 
	 * @param index
	 *        The array index of the current word in the user input String array.
	 *        
	 * @param combined
	 *        An int array that contains the day int, time int, date (DD,
	 *        MM, YY) and the current index in the user input string array.
	 *        
	 * @return the combined int array with the updated date fields.
	 */
	private int[] getNextDayOfWeek(String[] splitUserInput, int index, int[] combined) {
		// Convert the input day string into integer
		int day = convertDayStringToInt(splitUserInput[index + 1]);
		
		// Get the number of days to fast forward from the present date
		int fastForward = getFastForwardFromDayOfWeek(day) + NUMBER_OF_DAYS_IN_WEEK;
		
		// Get the future date in an int array
		int[] date = DateTimeParserCommons.getDateAfterANumberOfDays(fastForward, currDD, currMM, currYY);
		
		return DateTimeParserCommons.getNewCombinedArray(combined, date, day, index + 1);
	}

	/** 
	 * Converts the date inputs of the format "this mon", "this wednesday" etc into an int array.
	 * 
	 * @param splitUserInput
	 * 		  The user input String array.
	 * 
	 * @param index
	 *        The array index of the current word in the user input String array.
	 *        
	 * @param combined
	 *        An int array that contains the day int, time int, date (DD,
	 *        MM, YY) and the current index in the user input string array.
	 *        
	 * @return the combined int array with the updated date fields.
	 */
	private int[] getThisDayOfWeek(String[] splitUserInput, int index, int[] combined) {
		// Convert the input day string into integer
		int day = convertDayStringToInt(splitUserInput[index + 1]);
		
		// Get the number of days to fast forward from the present date
		int fastForward = getFastForwardFromDayOfWeek(day);
		
		// Get the future date in an int array
		int[] date = DateTimeParserCommons.getDateAfterANumberOfDays(fastForward, currDD, currMM, currYY);
		
		return DateTimeParserCommons.getNewCombinedArray(combined, date, day, index + 1);
	}
	
	/** 
	 * Converts a day input string into the day int form.
	 * 
	 * @param string
	 * 		  The day string like "wed", "tuesday" etc.
	 * 
	 * @return the int of the day string.
	 */
	private int convertDayStringToInt(String string) {
		int day = UNINITIALIZED_INT;
		for (int i = STARTING_VALUE_OF_ARRAY_CONSTANTS; i < daysInWeekShortForm.length; i++) {
			if (string.contains(daysInWeekShortForm[i])) {
				day = i;
				break;
			}
		}
		return day;
	}

	/** 
	 * Gets the day of the week in int form from the given number of days
	 * to fast forward from the present date.
	 * 
	 * @param daysLater
	 * 		  Number of days to fast forward from the present date
	 * 
	 * @return the day of the week in integer form.
	 */
	private int getDayOfWeekAfterANumberOfDays(int daysLater) {
		int dayOfWeek = daysLater + currDayInWeekInt;
		dayOfWeek %= NUMBER_OF_DAYS_IN_WEEK ;
		if (dayOfWeek == 0) {
			dayOfWeek = NUMBER_OF_DAYS_IN_WEEK;;
		}
		return dayOfWeek;
	}

	/** 
	 * Calculate the number of days to fast forward from the present date from the 
	 * given day string.
	 * 
	 * @param desiredDay
	 * 		  The day string like "wed", "tuesday" etc.
	 * 
	 * @return the number of days to fast forward from the present date.
	 */
	private int getFastForwardFromDayOfWeek(int desiredDay) {
		int fastForward = 0;
		if (currDayInWeekInt > desiredDay) {
			fastForward = NUMBER_OF_DAYS_IN_WEEK - currDayInWeekInt + desiredDay;
		} else if (currDayInWeekInt < desiredDay) {
			fastForward = desiredDay - currDayInWeekInt;
		} else { // if(currDay == day)
			fastForward = 0;
		}
		return fastForward;
	}
	
	/** 
	 * Checks if the word is a valid day of the week. For example "wed" is a 
	 * valid day but "wde" is not a valid day.
	 * 
	 * @param currWord
	 * 		  Current word in the user input string array.
	 * 
	 * @return true if the word is a valid day of the week and false otherwise.
	 */
	private boolean isValidDay(String currWord) {
		boolean ans = convertDayStringToInt(currWord) != -1;
		return ans;
	}
}
```
###### src\dooyit\parser\SearchParser.java
``` java
package dooyit.parser;

import java.util.logging.Level;
import java.util.logging.Logger;

import dooyit.common.datatype.DateTime;
import dooyit.common.datatype.DateTime.Day;
import dooyit.common.datatype.DateTime.Month;
import dooyit.common.exception.IncorrectInputException;
import dooyit.common.utils.CommandUtils;
import dooyit.logic.commands.Command;

/**
 * The SearchParser class takes in a "search" command input and 
 * returns a Command object. It is needed to search for tasks with
 * the specified Day, Month, date or string. It implements the 
 * ParserCommons interface to use the shared constants.
 * 
 * @author Annabel
 *
 */
public class SearchParser implements ParserCommons {
	// Error message
	private static final String ERROR_MESSAGE_EMPTY_SEARCH_COMMAND = "Empty search command!";
	
	// SearchParser object attributes
	Command command;
	String userInput;
	boolean isValidDate, isValidDay, isValidMonth, isEmptyString;
	DateTime dateTime;
	Day dayEnum;
	Month monthEnum;
	
	// Logger for SearchParser
	private static Logger logger = Logger.getLogger("SearchParser");
	
	// Possible types of searches
	private enum SearchType {
		INVALID, DATE, DAY, MONTH, WHOLE_STRING
	}
	
	/** Initializes a new SearchParser object */
	public SearchParser() {
		logger.log(Level.INFO, "Initialised SearchParser object");
	}
	
	/**
	 * Parses userInput and returns a SearchCommand object
	 * 
	 * @param input
	 * 		  The search command input from the user
	 * 
	 * @return the correct SearchCommand object if the userInput is not an 
	 * 		   empty string or an InvalidCommand object if it is.
	 */
	public Command getCommand(String input) {
		resetFields(input);
		setBooleanValues();
		setCorrectSearchCommand();
		return command;
	}

	/**
	 * Checks the userInput and sets the object's boolean 
	 * attributes accordingly.
	 */
	private void setBooleanValues() {
		// Set isValidDate boolean value
		try {
			DateTimeParser dtParser = new DateTimeParser();
			dateTime = dtParser.parse(userInput);
		} catch (IncorrectInputException e) {
			isValidDate = false;
		}
		
		// Set isValidDay boolean value
		dayEnum = DateTime.getDayType(userInput);
		isValidDay = dayEnum != Day.INVALID;
		
		// Set isValidMonth boolean value
		monthEnum = DateTime.getMonthType(userInput);
		isValidMonth = monthEnum != Month.INVALID;
		
		// Check if userUnput is an empty string
		isEmptyString = userInput.equals(EMPTY_STRING);
	}

	/**
	 * Resets all the attributes.
	 */
	private void resetFields(String input) {
		userInput = input.toLowerCase();
		isValidDate = true;
		isValidDay = false;
		isValidMonth = false;
		isEmptyString = false;
		command = null;
	}

	/**
	 * Sets the command attribute to an InvalidCommand object if the 
	 * userInput is an empty string or the correct SearchCommand object 
	 * if the userInput is not an empty string.
	 */
	private void setCorrectSearchCommand() {
		switch (getCorrectSearchType()) {
		case INVALID :
			command = CommandUtils.createInvalidCommand(ERROR_MESSAGE_EMPTY_SEARCH_COMMAND);
			break;
		
		case DAY :
			command = CommandUtils.createSearchCommand(userInput, dayEnum);
			break;
		
		case MONTH :
			command = CommandUtils.createSearchCommand(userInput, monthEnum);
			break;
			
		case DATE :
			command = CommandUtils.createSearchCommand(dateTime);
			break;
			
		default :
			command = CommandUtils.createSearchCommand(userInput);
			break;
		}
	}
	
	/**
	 * Checks the object's boolean values and returns the 
	 * correct SearchType.
	 */
	private SearchType getCorrectSearchType() {
		SearchType type;
		if (isEmptyString) {
			type = SearchType.INVALID;
		} else if (isValidDay) {
			type = SearchType.DAY;
		} else if (isValidMonth) {
			type = SearchType.MONTH;
		} else if (isValidDate) {
			type = SearchType.DATE;
		} else {
			type = SearchType.WHOLE_STRING;
		}
		return type;
	}
}
```
###### src\dooyit\parser\ShowParser.java
``` java
package dooyit.parser;

import java.util.logging.Level;
import java.util.logging.Logger;
import dooyit.common.utils.CommandUtils;
import dooyit.logic.commands.Command;

/**
 * The ShowParser class takes in a "show" command input and 
 * returns a Command object. It is needed to switch between the 
 * standard views on the Dooyit application.
 * 
 * @author Annabel
 *
 */
public class ShowParser {
	// Error message
	private static final String ERROR_MESSAGE_INVALID_SHOW_COMMAND = "Invalid show command";
	
	// Types of views
	private static final String VIEW_TODAY = "today";
	private static final String VIEW_NEXT_SEVEN = "next7";
	private static final String VIEW_DONE = "done";
	private static final String VIEW_ALL = "all";
	private static final String VIEW_COMPLETED = "completed";
	private static final String VIEW_FLOAT = "float";
	
	// ShowParser object attributes
	private String userInput;
	private Command command;
	
	// Logger for ShowParser
	private static Logger logger = Logger.getLogger("ShowParser");
	
	/** Initializes a new ShowParser object */
	public ShowParser() {
		logger.log(Level.INFO, "Initialised ShowParser object");
	}

	/**
	 * Parses userInput and returns a ShowCommand object
	 * 
	 * @param input
	 * 		  The show command input from the user
	 * 
	 * @return the correct ShowCommand object if the input is a valid view
	 * 		   or an InvalidCommand object if the input is an invalid view.
	 */
	public Command getCommand(String input) { 
		logger.log(Level.INFO, "Getting command object from ShowParser");
		setObjectAttributes(input);
		setCommandAttribute();
		return command;
	}

	/**
	 * Sets the command attribute to a ShowCommand object or to
	 * an InvalidCommand object.
	 */
	private void setCommandAttribute() {
		switch (userInput) { 
		case VIEW_TODAY :
			command = CommandUtils.createShowTodayCommand();
			break;

		case VIEW_NEXT_SEVEN :
			command = CommandUtils.createShowNext7DaysCommand();
			break;

		case VIEW_DONE :
			command = CommandUtils.createShowCompletedCommand();
			break;

		case VIEW_ALL :
			command = CommandUtils.createShowAllCommand();
			break;
			
		case VIEW_FLOAT :
			command = CommandUtils.createShowFloatCommand();
			break;

		case VIEW_COMPLETED :
			command = CommandUtils.createShowCompletedCommand();
			break;

		default :
			command = CommandUtils.createInvalidCommand(ERROR_MESSAGE_INVALID_SHOW_COMMAND);
			break;
		}
	}

	/**
	 * Resets object attributes for the new input string that the 
	 * ShowParser object is supposed to parse.
	 * 
	 * @param input
	 * 		  The show command input from the user
	 */
	private void setObjectAttributes(String input) {
		userInput = input.toLowerCase();
		command = null;
	}
}
```
###### src\dooyit\parser\TagParser.java
``` java
package dooyit.parser;

import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import dooyit.common.exception.IncorrectInputException;
import dooyit.logic.commands.Command;
import dooyit.common.utils.CommandUtils;

/**
 * TagParser class takes in a string of task IDs and returns an array 
 * list of task IDs. It is a parent class of DeleteParser, MarkParser, 
 * MoveParser, UnmarkParser and UnmoveParser. It implements the 
 * ParserCommons interface to use the shared constants.
 * 
 * @author Annabel
 *
 */
public class TagParser implements ParserCommons {
	// Error messages
	private static final String ERROR_MESSAGE_INVALID_TASK_ID = "Invalid Task ID: ";
	protected static final String MARKER_FOR_INTERVAL_TAG_TYPE = "-";
	protected static final String ERROR_MESSAGE_TOO_MANY_IDS = "Please type in ONE task ID";
	
	// TagParser Class Constants
	private static final int INDEX_OF_SINGLE_ID = 0;
	private static final int SIZE_ONE_ELEMENT = 1;
	private static final int MAXIMUM_NUMBER_OF_NUMBERS_IN_INTERVAL_TYPE = 2;
	private static final int INDEX_OF_START_IN_INTERVAL_TYPE = 0;
	private static final int INDEX_OF_END_IN_INTERVAL_TYPE = 1;
	
	// TagParser object attributes
	protected String userInput;
	protected String[] splitInput;
	protected ArrayList<Integer> taskIdsForTagging;
	protected Command command;
	
	// Logger for TagParser
	private static Logger logger = Logger.getLogger("TagParser");
	
	// Types of Task ID inputs
	protected enum TagType {
		VALID, INVALID, SINGLE, MULTIPLE
	}

	/** Initializes a new TagParser object */
	public TagParser() {
		logger.log(Level.INFO, "Initialised TagParser object");
	}
	
	/** 
	 * Parses the task IDs and puts the integers into the 
	 * taskIdsForTagging arraylist.
	 * 
	 * @throws IncorrectInputException if there is a non-integer
	 * 		   taskID or if there is IntegerOverflow.
	 */
	protected void parseTaskIds() throws IncorrectInputException {
		for (int i = 0; i < splitInput.length; i++) {
			String currWord = splitInput[i];
			try {
				addTaskIds(currWord);
			} catch (IncorrectInputException e) {
				throw e;
			}
		}
	}

	/**
	 * 
	 * @param currWord
	 * 		  The taskID or interval of taskIDs 
	 * 
	 * @throws IncorrectInputException if there is a non-integer
	 * 		   taskID or if there is IntegerOverflow.
	 */
	private void addTaskIds(String currWord) throws IncorrectInputException {
		if (ParserCommons.isNumber(currWord)) {
			// Check for Integer Overflow
			try {
				int taggedId = Integer.parseInt(currWord);
				taskIdsForTagging.add(taggedId);
			} catch (NumberFormatException e) {
				throw new IncorrectInputException(ERROR_MESSAGE_INTEGER_OVERFLOW);
			}
			
		} else if (isIntervalType(currWord)) {
			setInterval(currWord);
			
		} else {
			throw new IncorrectInputException(ERROR_MESSAGE_INVALID_TASK_ID + currWord);
		}
	}
	
	/**
	 * Check if the current string is a valid interval of taskIDs
	 * 
	 * @param currWord
	 * 		  A one word string from the user input
	 * 
	 * @return true if the word contains the interval marker and also
	 * 		   if the start and end are both numbers.
	 */
	protected static boolean isIntervalType(String currWord) {
		boolean isInterval = false;
		if (currWord.contains(MARKER_FOR_INTERVAL_TAG_TYPE)) {
			String[] splitByDash = currWord.split(MARKER_FOR_INTERVAL_TAG_TYPE);
			isInterval = checkIfStartAndEndAreNumbers(splitByDash);
		}
		return isInterval;
	}

	/**
	 * Checks if there is a correct number of elements in the String array.
	 * If the number of elements is correct, checks if the start and end
	 * strings are valid numbers.
	 * 
	 * @param splitByDash
	 * 		  String array of one of the words from the
	 * 		  user input that contains the interval marker
	 * 
	 * @return true if the number of elements in the String array is correct and 
	 * 		   also if the words are valid numbers.
	 */
	private static boolean checkIfStartAndEndAreNumbers(String[] splitByDash) {
		boolean ans = false;
		if (splitByDash.length == MAXIMUM_NUMBER_OF_NUMBERS_IN_INTERVAL_TYPE) {
			String start = splitByDash[INDEX_OF_START_IN_INTERVAL_TYPE];
			String end = splitByDash[INDEX_OF_END_IN_INTERVAL_TYPE];
			ans = ParserCommons.isNumber(start) && ParserCommons.isNumber(end);
		}
		return ans;
	}

	/**
	 * Sets the object attributes.
	 * 
	 * @param input
	 * 		  This is the user input that contains just the task IDs
	 */
	protected void setAttributesForTagging(String input) {
		userInput = input;
		splitInput = userInput.split("\\s+");
		taskIdsForTagging = new ArrayList<Integer>();
		command = null;
	}

	/**
	 * Adds the task IDs to the ArrayList taskIdsForTagging
	 * 
	 * @param currWord
	 * 		  A word in the user input that is of a similar 
	 * 		  format "4-7".
	 * 			
	 */
	protected void setInterval(String currWord) throws IncorrectInputException {
		String[] splitByDash = currWord.split(MARKER_FOR_INTERVAL_TAG_TYPE);
		
		// Check for Integer overflow
		try {
			int start = Integer.parseInt(splitByDash[INDEX_OF_START_IN_INTERVAL_TYPE]); 
			int end = Integer.parseInt(splitByDash[INDEX_OF_END_IN_INTERVAL_TYPE]);
			for (int i = start; i <= end; i++) {
				taskIdsForTagging.add(i);
			}
		} catch (NumberFormatException e) {
			throw new IncorrectInputException(ERROR_MESSAGE_INTEGER_OVERFLOW);
		}
	}

	/**
	 * Checks if the user input has valid task IDs and returns 
	 * the correct TagType.
	 * 
	 * @return the TagType VALID if the ArrayList taskIdsForTagging has at 
	 * 		   least one element and the TagType INVALID otherwise.
	 */
	protected TagType getTagType() {
		TagType type;
		if (taskIdsForTagging.size() >= SIZE_ONE_ELEMENT) {
			type = TagType.VALID;
		} else {
			type = TagType.INVALID;
		}
		return type;
	}
	
	/**
	 * Checks if the user input has one task ID or more and 
	 * returns the correct TagType.
	 * 
	 * @return the SINGLE TagType if the ArrayList only has one element
	 * 		   or the MULTIPLE TagType if the ArrayList has more than one
	 * 		   element or the INVALID TagType the ArrayList does not 
	 * 		   contain any elements.
	 */
	protected TagType getSingleMultipleTagType() {
		TagType type;
		if (taskIdsForTagging.size() == SIZE_ONE_ELEMENT) {
			type = TagType.SINGLE;
		} else if (taskIdsForTagging.size() > SIZE_ONE_ELEMENT) {
			type = TagType.MULTIPLE;
		} else {
			type = TagType.INVALID;
		}
		return type;
	}
	
	/**
	 * Resets the command attribute to null.
	 */
	protected void resetCommandAttributeToNull() {
		command = null;
	}
	
	/**
	 * Gets the single task ID from the arraylist of task IDs.
	 * 
	 * @return the single task ID.
	 */
	protected int getSingleTaskId() {
		return taskIdsForTagging.get(INDEX_OF_SINGLE_ID);
	}
	
	/**
	 * Sets the command attribute to an InvalidCommand object.
	 * 
	 * @param message
	 * 		  Error message that indicates why the user input is wrong
	 */
	protected void setToInvalidCommand(String message) {
		command = CommandUtils.createInvalidCommand(message);
	}
}
```
###### src\dooyit\parser\TimeParser.java
``` java
package dooyit.parser;

import java.util.logging.Level;
import java.util.logging.Logger;

import dooyit.common.exception.IncorrectInputException;

/**
 * TimeParser takes in a string and return the time in 24 hour integer format.
 * It implements DateTimeparserCommons and ParserCommons to use the shared 
 * methods and constants.
 * 
 * @author Annabel
 *
 */
public class TimeParser implements DateTimeParserCommons, ParserCommons {
	// Error messages
	private static final String ERROR_MESSAGE_INVALID_TIME = "Invalid time!";
	private static final String ERROR_MESSAGE_INVALID_HOURS_OR_MINUTES = "Invalid Time! Hours must fall within the 24h range and Minutes must be between 0 to 59 inclusive";
	private static final String ERROR_MESSAGE_TIME_EXCEEDS_24H = "Invalid Time! Time must not exceed 24 hours!";
	private static final String ERROR_MESSAGE_AM_AND_PM = "Time cannot be contain both am and pm!";
	
	// For checking if the time string is exactly midnight
	private static final String TWELVE_MIDNIGHT_ONE_STRING = "12am";
	
	// For converting 12h afternoon timings like 2.30pm from 230 to 1430
	private static final int TWELVE_HOURS = 1200;
	
	// For checking if 24h time int is equal to or greater than 24h
	private static final int TWENTY_FOUR_HOURS = 2400;
	
	// Constants for the isMidnight method
	private static final int FORMAT_24H_1259PM = 1259;
	private static final int FORMAT_24H_12PM = 1200;
	private static final int FORMAT_24H_1PM = 1300;
	private static final int FORMAT_24H_1259AM = 59;
	private static final int FORMAT_24H_12AM = 0;
	private static final String FORMAT_DOUBLE_ZEROES = "00";
	
	// Constants for the accepted range of minutes
	private static final int MINUTES_MINIMUM = 0;
	private static final int MINUTES_MAXIMUM = 59;

	// Logger for TimeParser
	private static Logger logger = Logger.getLogger("TimeParser");
	
	/** Initializes a TimeParser object */
	public TimeParser() {
		logger.log(Level.INFO, "Initialised TimeParser object");
	}
	
	/**
	 * Takes a valid time string from the user input and converts it into a time int.
	 * 
	 * @param splitUserInput
	 * 		  The user input String array.
	 * 
	 * @param combined
	 *        An int array that contains the day int, time int, date (DD,
	 *        MM, YY) and the current index in the user input string array.
	 *        
	 * @param index
	 *        The array index of the current word in the user input String array.
	 *        
	 * @return 24h time int of the valid time string in the user input.
	 * 
	 * @throws IncorrectInputException if the user input does not have a valid time string.
	 */
	public int[] parse(String[] splitUserInput, int[] combined, int index) throws IncorrectInputException {
		try {
			combined = getTimeFromUserInput(splitUserInput, index, combined);
		} catch (IncorrectInputException e) {
			throw e;
		}
		return combined;
	}
	
	/**
	 * Checks if the user input contains a valid time string.
	 * 
	 * @param currWord
	 * 		  The word of the current word in the user input string array
	 * 
	 * @param splitUserInput
	 * 		  The user input String array.
	 * 
	 * @param index
	 *        The array index of the current word in the user input String array.
	 *        
	 * @return true if user input has a valid time string and false otherwise.
	 */
	public boolean isValidTime(String currWord, String[] splitUserInput, int index) {
		boolean ans = false;
		if (currWord.contains(PM) || currWord.contains(AM)) {
			currWord = currWord.replace(PM, EMPTY_STRING).replace(AM, EMPTY_STRING);
			
			if (currWord.contains(TIME_SEPARATOR_COLON) || currWord.contains(TIME_SEPARATOR_DOT)) { // Eg: 12pm, 12.30pm, 12:50am
				currWord = removeTimeSeparators(currWord);
				ans = true;
			} else {
				ans = true;
			}

		} else if (currWord.contains(TIME_SEPARATOR_COLON)) { // 24Hour formats eg: 23:30
			currWord = removeTimeSeparators(currWord);
			if (ParserCommons.isNumber(currWord)) {
				ans = true;
			}
			
		} else if (ParserCommons.isNumber(removeTimeSeparators(currWord))
				&& DateTimeParserCommons.hasAWordAfterCurrWord(splitUserInput, index)) {
			String nextWord = splitUserInput[index + 1];
			if (nextWord.equals(AM) ^ nextWord.equals(PM)) {
				ans = true;
			}
		}  else {
			ans = false;
		}
		return ans;
	}

	/**
	 * Removes the recognized time separators ":" and "." from the word input.
	 * 
	 * @param currWord
	 * 		  The word of the current word in the user input string array
	 * 
	 * @return the word input without the time separators.
	 */
	private String removeTimeSeparators(String currWord) {
		return currWord.replace(TIME_SEPARATOR_COLON, EMPTY_STRING).replace(TIME_SEPARATOR_DOT, EMPTY_STRING);
	}
	
	/**
	 * Converts valid time string from user input into 24 time int and put the int into the 
	 * combined int array.
	 * 
	 * @param splitUserInput
	 * 		  The user input String array.
	 * 
	 * @param index
	 *        The array index of the current word in the user input String array.
	 *        
	 * @param combined
	 *        An int array that contains the day int, time int, date (DD,
	 *        MM, YY) and the current index in the user input string array.
	 *        
	 * @return combined int array with the time value updated.
	 * 
	 * @throws IncorrectInputException if the user input does not contain a valid time string.
	 */
	private int[] getTimeFromUserInput(String[] splitUserInput, int index, int[] combined) throws IncorrectInputException {
		String timeString = removeTimeSeparators(splitUserInput[index]);
		boolean isAm = timeString.contains(AM);
		boolean isPm = timeString.contains(PM);
		int timeInt = UNINITIALIZED_INT;
		boolean isExactlyMidnight = timeString.equals(TWELVE_MIDNIGHT_ONE_STRING);

		if (isAm && isPm) {
			throw new IncorrectInputException(ERROR_MESSAGE_AM_AND_PM);
		}

		timeString = removeAmAndPmFromTimeString(timeString, isAm, isPm);
		if (!ParserCommons.isNumber(timeString)) {
			throw new IncorrectInputException(ERROR_MESSAGE_INVALID_TIME);
		} else {
			timeInt = Integer.parseInt(timeString);
		} 
		
		if (hasInvalidHoursOrMinutes(timeInt, splitUserInput, index, isAm, isPm)) {
			throw new IncorrectInputException(ERROR_MESSAGE_INVALID_HOURS_OR_MINUTES);
		}

		timeInt = getTimeIntByAssumingOneWordTimeInput(timeString, isAm, isPm, timeInt, isExactlyMidnight);
		timeInt = getTimeIntByAssumingTwoWordsTimeInput(splitUserInput, index, timeInt);
		
		if (timeExceeds24H(timeInt)) {
			throw new IncorrectInputException(ERROR_MESSAGE_TIME_EXCEEDS_24H);
		}

		index = getNewArrayIndex(splitUserInput, index);
		combined = updateTimeAndIndexInCombinedArray(index, combined, timeInt);
		
		return combined;
	}
	
	/**
	 * Checks if the time int has invalid hour and/or minute value.
	 * 
	 * @param timeInt
	 * 		  Can be 12h (eg. 1100) or 24h (2300) format time integers.
	 * 
	 * @param splitUserInput
	 * 		  The user input String array.
	 * 
	 * @param index
	 *        The array index of the current word in the user input String array.
	 *        
	 * @param isAm
	 * 		  Boolean input that indicates if the time String contains the "am" time marker.
	 * 
	 * @param isPm
	 * 		  Boolean input that indicates if the time String contains the "pm" time marker.
	 * 
	 * @return true if the timeInt has invalid hour and/or minute value and false otherwise.
	 */
	private boolean hasInvalidHoursOrMinutes(int timeInt, String[] splitUserInput, int index, boolean isAm, boolean isPm) {
		return hasInvalidHours(timeInt, splitUserInput, index, isAm, isPm) || hasInvalidMinutes(timeInt);
	}
	
	/**
	 * Checks if the time int has invalid hour value like 100 or 25.
	 * 
	 * @param timeInt
	 * 		  Can be 12h (eg. 1100) or 24h (2300) format time integers.
	 * 
	 * @param splitUserInput
	 * 		  The user input String array.
	 * 
	 * @param index
	 *        The array index of the current word in the user input String array.
	 *        
	 * @param isAm
	 * 		  Boolean input that indicates if the time String contains the "am" time marker.
	 * 
	 * @param isPm
	 * 		  Boolean input that indicates if the time String contains the "pm" time marker.
	 * 
	 * @return true if the timeInt has invalid hour value and false otherwise.
	 */
	private boolean hasInvalidHours(int timeInt, String[] splitUserInput, int index, boolean isAm, boolean isPm) {
		String nextWord;
		boolean isAmOrPm = false, ans = false;
		if (DateTimeParserCommons.hasAWordAfterCurrWord(splitUserInput, index)) {
			nextWord = splitUserInput[index + 1];
			isAmOrPm = nextWord.contains(PM) || nextWord.contains(AM);
		}
		
		if (isAmOrPm || isAm || isPm) {
			boolean isValidHour = timeInt >= 1 && timeInt <= 12;
			boolean hasOnlyTwoDigits = timeInt < 100;
			ans = !isValidHour && hasOnlyTwoDigits;
		}
		return ans;
	}

	/**
	 * Checks if hour value exceeds or is equals to 24.
	 * 
	 * @param timeInt
	 * 		  Time string converted to 24h format int, For eg. 12.00am is 0 and 11.59pm is 2359.
	 * 
	 * @return true if the hour is equal to or greater than 24 and false otherwise.
	 */
	private boolean timeExceeds24H(int timeInt) {
		return timeInt >= TWENTY_FOUR_HOURS;
	}

	/**
	 * Check if the minute value of the time int is within the acceptable range for 
	 * minutes.
	 * 
	 * @param timeInt
	 * 		  Time string converted to 24h format int, For eg. 12.00am is 0 and 11.59pm is 2359.
	 * 
	 * @return true if the minute value is within the range and false otherwise.
	 */
	private boolean hasInvalidMinutes(int timeInt) {
		int minutes = getMinuteNumeralOfTime(timeInt);
		return minutes > MINUTES_MAXIMUM || minutes < MINUTES_MINIMUM;
	}

	/**
	 * Removes "am" and "pm" marker from the timeString.
	 * 
	 * @param timeString
	 *   	  The time string from the user input.
	 *   
	 * @param isAm
	 * 		  Boolean input that indicates if the time String contained the "am" time marker.
	 * 
	 * @param isPm
	 * 		  Boolean input that indicates if the time String contained the "pm" time marker.
	 * 
	 * @return the current word without the "am" and "pm" time string.
	 */
	private String removeAmAndPmFromTimeString(String timeString, boolean isAm, boolean isPm) {
		if (isAm ^ isPm) {
			timeString = timeString.replace(AM, EMPTY_STRING).trim();
			timeString = timeString.replace(PM, EMPTY_STRING).trim();
		}
		return timeString;
	}
	
	/**
	 * Checks if there is a need to increase the array index by 1. If the next word 
	 * if am or pm, the array index will be incremented, else it won't be increased.
	 * 
	 * @param splitUserInput
	 * 		  The user input String array.
	 * 
	 * @param index
	 *        The array index of the current word in the user input String array.
	 *        
	 * @return the correct array index.
	 */
	private int getNewArrayIndex(String[] splitUserInput, int index) {
		if (DateTimeParserCommons.hasAWordAfterCurrWord(splitUserInput, index)) {
			String nextWord = splitUserInput[index + 1];
			if (nextWord.equals(PM) || nextWord.equals(AM)) {
				index += 1; // To skip the next word
			}
		}
		return index;
	}
	
	/**
	 * Converts time string from the user into 24h time int. This is for time string of the
	 * format "12.20 pm" or "8:15 am". Note the spacing before the time markers "am" and "pm"
	 * 
	 * @param splitUserInput
	 * 		  The user input String array.
	 * 
	 * @param index
	 *        The array index of the current word in the user input String array.
	 *        
	 * @param timeInt
	 * 		  Time int in 12h format, 12pm and 12am are both 1200
	 * 
	 * @return 24h time int
	 */
	private int getTimeIntByAssumingTwoWordsTimeInput(String[] splitUserInput, int index, int timeInt) {
		index += 1;
		if (index < splitUserInput.length) {
			String indicator = splitUserInput[index];
			if (indicator.equals(PM) && !timeIsBetween1200And1259Inclusive(timeInt)) {
				timeInt += TWELVE_HOURS;
			}
			if (timeIsBetween1200And1259Inclusive(timeInt) && indicator.equals(AM)) {
				timeInt -= TWELVE_HOURS;
			}
		}
		return timeInt;
	}
	
	/**
	 * Converts time string from the user into 24h time int. This is for time string of the
	 * format "12.20pm" or "8:15am".
	 * 
	 * @param timeString
	 *   	  The time string from the user input.
	 *   
	 * @param isAm
	 * 		  Boolean input that indicates if the time String contains the "am" time marker.
	 * 
	 * @param isPm
	 * 		  Boolean input that indicates if the time String contains the "pm" time marker.
	 * 
	 * @param timeInt
	 * 		  Can be either 12h or 24 time format.
	 * 
	 * @param isExactlyMidnight
	 *        Boolean input that indicates if the time string from the user input is exactly 12 midnight.
	 *        
	 * @return 24h format time int.
	 */
	private int getTimeIntByAssumingOneWordTimeInput(String timeString, boolean isAm, boolean isPm, int timeInt, boolean isExactlyMidnight) {
		if (isMidnight(timeInt, timeString, isAm) || isExactlyMidnight) {
			if (isExactlyMidnight) {
				timeInt = FORMAT_24H_12AM;
			} else {
				timeInt = getMinuteNumeralOfTime(timeInt);
			}
		} else if (is12HNoMinutesFormatTime(timeInt)) { // Eg 12am or 1pm
			timeInt = convertTimeHourFrom12HTo24HFormat(timeInt);
		}

		if (isPm) {
			if(!timeIsBetween1200And1259Inclusive(timeInt)) {
				// Convert time int from eg 100 to 1300 for 1pm
				timeInt = timeInt + TWELVE_HOURS;
			}
		}
		return timeInt;
	}

	/**
	 * Checks if the time int is between 12pm and 11.59pm.
	 * 
	 * @param timeInt
	 * 		  Can be in 12h or 24h time format.
	 * 
	 * @return true if time int is within the stated range and false otherwise.
	 */
	private boolean timeIsBetween1200And1259Inclusive(int timeInt) {
		return timeInt >= FORMAT_24H_12PM && timeInt < FORMAT_24H_1PM;
	}
	
	/**
	 * Converts hour value time int from 12h format to 24h format. 
	 * Eg. "1" for 1pm and 1am is converted to "100" format.
	 * 
	 * @param timeInt
	 * 		  Hour value of time int in 12h format.
	 * 
	 * @return hour value in 24h format
	 */
	private int convertTimeHourFrom12HTo24HFormat(int timeInt) {
		return timeInt * 100;
	}

	/**
	 * Checks if the time int is of the format 12am or 1pm or 2pm, eg no minutes.
	 * 
	 * @param timeInt
	 * 		  Hour value of time int converted from time string.
	 * 
	 * @return true if it the stated format and false otherwise.
	 */
	private boolean is12HNoMinutesFormatTime(int timeInt) {
		return timeInt <= 12;
	}
	
	/**
	 * Updates the time and counter fields in the combined int array.
	 * 
	 * @param index
	 *        The array index of the current word in the user input String array.
	 * 
	 * @param combined
	 *        An int array that contains the day int, time int, date (DD,
	 *        MM, YY) and the current index in the user input string array.
	 *        
	 * @param timeInt
	 * 		  Time string in 24h format int, For eg. 12.00am is 0 and 11.59pm is 2359.
	 * 
	 * @return combined int array with time and counter fields updated.
	 */
	private int[] updateTimeAndIndexInCombinedArray(int index, int[] combined, int timeInt) {
		combined[COMBINED_INDEX_TIME] = timeInt;
		combined[COMBINED_INDEX_COUNTER] = index;
		return combined;
	}
	
	/**
	 * Gets the minute numeral from the 24h time int.
	 * 
	 * @param timeInt
	 * 		  Time string converted 24h format int, For eg. 12.00am is 0 and 11.59pm is 2359.
	 * 
	 * @return the minute numeral of the time int.
	 */
	private int getMinuteNumeralOfTime(int timeInt) {
		return timeInt % 100;
	}

	/**
	 * Checks if the time string is after 12am and before 1am 
	 * 
	 * @param timeInt
	 * 		  Time string in 24h format int, For eg. 12.00am is 0 and 11.59pm is 2359.
	 * 
	 * @param timeString
	 *   	  The time string from the user input.
	 *   
	 * @param isAm
	 * 		  Boolean input that indicates if the time String contained the "am" time marker
	 * 
	 * @return true if the timeString is between 12.00am to 12.59am and false otherwise.
	 */
	private boolean isMidnight(int timeInt, String timeString, boolean isAm) {
		boolean isMidnight24H = timeInt >= FORMAT_24H_12AM && timeInt <= FORMAT_24H_1259AM && timeString.contains(FORMAT_DOUBLE_ZEROES);
		boolean isMidnight12H = timeInt >= FORMAT_24H_12PM && timeInt <= FORMAT_24H_1259PM && isAm;
		return isMidnight24H || isMidnight12H;
	}

}
```
###### src\dooyit\parser\UnmarkParser.java
``` java
package dooyit.parser;

import java.util.logging.Level;
import java.util.logging.Logger;

import dooyit.common.exception.IncorrectInputException;
import dooyit.common.utils.CommandUtils;
import dooyit.logic.commands.Command;

/**
 * The UnmarkParser class is needed for unmarking completed tasks.
 * Completed tasks that are unmarked will be removed from the completed view and 
 * placed back in the original location. This class takes in an "unmark" command 
 * input and returns a Command object. It is a child class of the 
 * TagParser class.
 * 
 * @author Annabel
 *
 */
public class UnmarkParser extends TagParser{
	// Error message
	private static final String ERROR_MESSAGE_INVALID_UNMARK_COMMAND = "Invalid Unmark Command!";

	// Logger for UnmarkParser
	private static Logger logger = Logger.getLogger("UnmarkParser");
	
	/** Initializes a new UnmarkParser object */
	public UnmarkParser() {
		super();
		logger.log(Level.INFO, "Initialised UnmarkParser object");
	}
	
	/**
	 * Parses userInput and returns an UnMarkCommand object
	 * 
	 * @param input
	 * 		  The delete command input from the user
	 * 
	 * @return a DeleteCommand object if the taskIds are valid
	 * 		   or an InvalidCommand object if the taskIds are invalid.
	 */
	public Command getCommand(String input) {
		logger.log(Level.INFO, "Getting command object from UnmarkParser");
		// Reset object attributes for each call to the getCommand method
		setAttributesForTagging(input);
		resetCommandAttributeToNull();
		
		setCommandAttribute();
		return command;
	}

	/**
	 * Set command attribute to an UnMarkCommand object or 
	 * to an InvalidCommand object.
	 */
	private void setCommandAttribute() {
		// Checks if the taskIds are valid
		try {
			parseTaskIds();
		} catch (IncorrectInputException e) {
			setToInvalidCommand(e.getMessage());
		}
		
		// Checks if the command has been set to InvalidCommand object
		if (command == null) {
			// Set command attribute to an UnMarkCommand object 
			// if it hasn't been set to an InvalidCommand object.
			setUnmarkCommand(getTagType());
		}
	}
	
	/**
	 * Sets command attribute to a UnMarkCommand object or to
	 * an InvalidCommand object.
	 */
	private void setUnmarkCommand(TagType tagType) {
		switch (tagType) {
		case VALID :
			command = CommandUtils.createUnMarkCommand(taskIdsForTagging);
			break;

		default :
			command = CommandUtils.createInvalidCommand(ERROR_MESSAGE_INVALID_UNMARK_COMMAND);
			break;
		}
	}
}
```
###### src\dooyit\parser\UnmoveParser.java
``` java
package dooyit.parser;

import java.util.logging.Level;
import java.util.logging.Logger;

import dooyit.common.exception.IncorrectInputException;
import dooyit.common.utils.CommandUtils;
import dooyit.logic.commands.Command;

/**
 * The UnmoveParser class is needed for marking tasks as completed.
 * It takes in a "unmove" command input and returns a Command object. 
 * It is a child class of the TagParser class.
 * 
 * @author Annabel
 *
 */
public class UnmoveParser extends TagParser {
	// Error message
	private static final String ERROR_MESSAGE_INVALID_UNMOVE_COMMAND = "Invalid Unmove Command!";

	// Logger for UnmoveParser
	private static Logger logger = Logger.getLogger("UnmoveParser");
	
	/** Initializes a new UnmoveParser object */
	public UnmoveParser() {
		super();
		logger.log(Level.INFO, "Initialised UnmoveParser object");
	}

	/**
	 * Parses userInput and returns a UnMoveCommand object
	 * 
	 * @param input
	 * 		  The unmark command input from the user
	 * 
	 * @return an UnMarkCommand object if the taskIds are valid
	 * 		   or an InvalidCommand object if the taskIds are invalid.
	 */
	public Command getCommand(String input) {
		logger.log(Level.INFO, "Getting command object from UnmoveParser");
		// Reset object attributes for each call to the getCommand method
		setAttributesForTagging(input);
		resetCommandAttributeToNull();
		
		// Checks if the taskIds are valid
		try {
			parseTaskIds();
		} catch (IncorrectInputException e) {
			setToInvalidCommand(e.getMessage());
		}
		
		// Checks if the command has been set to InvalidCommand object
		if (command == null) {
			// Set command attribute to an UnMoveCommand object 
			// if it hasn't been set to an InvalidCommand object.
			setToUnmarkCommand(getSingleMultipleTagType());
		}
		
		return command;
	}

	/**
	 * Sets command attribute to an UnMove Command object or to
	 * an InvalidCommand object.
	 */
	private void setToUnmarkCommand(TagType tagType) {
		switch (tagType) {
		case SINGLE :
			int taskId = getSingleTaskId();
			command = CommandUtils.createUnMoveCategoryCommand(taskId);
			break;
			
		case MULTIPLE :
			command = CommandUtils.createInvalidCommand(ERROR_MESSAGE_TOO_MANY_IDS);
			break;

		default :
			command = CommandUtils.createInvalidCommand(ERROR_MESSAGE_INVALID_UNMOVE_COMMAND);
			break;
		}
	}
}
```
###### test\dooyit\parser\DateTimeParserTest.java
``` java
package dooyit.parser;

import dooyit.parser.DateTimeParser;
import dooyit.common.datatype.DateTime;
import dooyit.common.exception.IncorrectInputException;

import static org.junit.Assert.*;

import org.junit.Before;
import org.junit.Test;

public class DateTimeParserTest {
	private static final int FORMAT_24H_6AM = 600;
	
	private static final String REFERENCE_TODAY_DAY_STRING = "Wednesday";
	private static final String REFERENCE_TODAY_DATE = "17 Feb 2016";
	private static final int REFERENCE_TODAY_DAY_INT = 3;

	private static final String REFERENCE_TOMORROW_DAY_STRING = "Thursday";
	private static final String REFERENCE_TOMORROW_DATE = "18 Feb 2016";
	private static final int REFERENCE_TOMORROW_DAY_INT = 4;
	
	private static final String REFERENCE_NEXT_WEEK_DAY_STRING = "Wednesday";
	private static final String REFERENCE_NEXT_WEEK_DATE = "24 Feb 2016";
	private static final int REFERENCE_NEXT_WEEK_DAY_INT = 3;
	
	private static final String REFERENCE_THREE_WEEKS_LATER_DAY_STRING = "Wednesday";
	private static final String REFERENCE_THREE_WEEKS_LATER_DATE = "9 Mar 2016";
	private static final int REFERENCE_THREE_WEEKS_LATER_DAY_INT = 3;

	private static final String REFERENCE_TWELVE_DAYS_LATER_DAY_STRING = "Monday";
	private static final String REFERENCE_TWELVE_DAYS_LATER_DATE = "29 Feb 2016";
	private static final int REFERENCE_TWELVE_DAYS_LATER_DAY_INT = 1;
	
	private static final String REFERENCE_THIS_SATURDAY_DAY_STRING = "Saturday";
	private static final String REFERENCE_THIS_SATURDAY_DATE = "20 Feb 2016";
	private static final int REFERENCE_THIS_SATURDAY_DAY_INT = 6;
	
	private static final String REFERENCE_NEXT_SATURDAY_DAY_STRING = "Saturday";
	private static final String REFERENCE_NEXT_SATURDAY_DATE = "27 Feb 2016";
	private static final int REFERENCE_NEXT_SATURDAY_DAY_INT = 6;
	
	private static final String REFERENCE_THIS_MONDAY_DAY_STRING = "Monday";
	private static final String REFERENCE_THIS_MONDAY_DATE = "22 Feb 2016";
	private static final int REFERENCE_THIS_MONDAY_DAY_INT = 1;
	
	private static final String REFERENCE_NEXT_MONDAY_DAY_STRING = "Monday";
	private static final String REFERENCE_NEXT_MONDAY_DATE = "29 Feb 2016";
	private static final int REFERENCE_NEXT_MONDAY_DAY_INT = 1;
	
	DateTimeParser dateTimeParser, referenceDateTimeParser;
	int[] referenceDate;
	int referenceDayInt, referenceTime, todayDayInt;
	DateTime referenceDateTimeObject, todayDateTimeObject;
	String referenceDayString, todayDate, todayDayString;
	
	@Before
	public void setup() {
		dateTimeParser = new DateTimeParser();
		
		referenceDate = new int[] {17, 2, 2016};
		referenceDayString = "Wednesday";
		referenceDayInt= 3;
		referenceTime = FORMAT_24H_6AM;
		referenceDateTimeObject = new DateTime(referenceDate, referenceTime);
		referenceDateTimeParser = new DateTimeParser(referenceDateTimeObject);
		
		todayDateTimeObject = new DateTime();
		todayDate = todayDateTimeObject.getDate();
		todayDayString = todayDateTimeObject.getDayStr();
		todayDayInt = todayDateTimeObject.getDayInt();
	}
	
	//********************************************
	//******** Tests for RelativeDateParser ******
	//********************************************
	@Test
	public void parseSaturday() {
		String userInput = "saturday";
		DateTime userDate = referenceDateTimeParser.parse(userInput);
		
		String parsedDate = userDate.getDate();
		String parsedDayString = userDate.getDayStr();
		int parsedDayInt = userDate.getDayInt();
		
		assertEquals(REFERENCE_THIS_SATURDAY_DATE, parsedDate);
		assertEquals(REFERENCE_THIS_SATURDAY_DAY_STRING, parsedDayString);
		assertEquals(REFERENCE_THIS_SATURDAY_DAY_INT, parsedDayInt);
	}
	
	@Test
	public void parseSaturdayCaseInsensitive() {
		String userInput = "satURDay";
		DateTime userDate = referenceDateTimeParser.parse(userInput);
		
		String parsedDate = userDate.getDate();
		String parsedDayString = userDate.getDayStr();
		int parsedDayInt = userDate.getDayInt();
		
		assertEquals(REFERENCE_THIS_SATURDAY_DATE, parsedDate);
		assertEquals(REFERENCE_THIS_SATURDAY_DAY_STRING, parsedDayString);
		assertEquals(REFERENCE_THIS_SATURDAY_DAY_INT, parsedDayInt);
	}
	
	@Test
	public void parseThisSaturday() {
		String userInput = "this saturday";
		DateTime userDate = referenceDateTimeParser.parse(userInput);
		
		String parsedDate = userDate.getDate();
		String parsedDayString = userDate.getDayStr();
		int parsedDayInt = userDate.getDayInt();
		
		assertEquals(REFERENCE_THIS_SATURDAY_DATE, parsedDate);
		assertEquals(REFERENCE_THIS_SATURDAY_DAY_STRING, parsedDayString);
		assertEquals(REFERENCE_THIS_SATURDAY_DAY_INT, parsedDayInt);
	}
	
	@Test
	public void parseThisSaturdayCaseInsensitive() {
		String userInput = "ThIs satURDay";
		DateTime userDate = referenceDateTimeParser.parse(userInput);
		
		String parsedDate = userDate.getDate();
		String parsedDayString = userDate.getDayStr();
		int parsedDayInt = userDate.getDayInt();
		
		assertEquals(REFERENCE_THIS_SATURDAY_DATE, parsedDate);
		assertEquals(REFERENCE_THIS_SATURDAY_DAY_STRING, parsedDayString);
		assertEquals(REFERENCE_THIS_SATURDAY_DAY_INT, parsedDayInt);
	}
	
	@Test
	public void parseNextSaturday() {
		String userInput = "next saturday";
		DateTime userDate = referenceDateTimeParser.parse(userInput);
		
		String parsedDate = userDate.getDate();
		String parsedDayString = userDate.getDayStr();
		int parsedDayInt = userDate.getDayInt();
		
		assertEquals(REFERENCE_NEXT_SATURDAY_DATE, parsedDate);
		assertEquals(REFERENCE_NEXT_SATURDAY_DAY_STRING, parsedDayString);
		assertEquals(REFERENCE_NEXT_SATURDAY_DAY_INT, parsedDayInt);
	}
	
	@Test
	public void parseNextSaturdayCaseInsensitive() {
		String userInput = "nExT satURday";
		DateTime userDate = referenceDateTimeParser.parse(userInput);
		
		String parsedDate = userDate.getDate();
		String parsedDayString = userDate.getDayStr();
		int parsedDayInt = userDate.getDayInt();
		
		assertEquals(REFERENCE_NEXT_SATURDAY_DATE, parsedDate);
		assertEquals(REFERENCE_NEXT_SATURDAY_DAY_STRING, parsedDayString);
		assertEquals(REFERENCE_NEXT_SATURDAY_DAY_INT, parsedDayInt);
	}
	
	@Test
	public void parseMonday() {
		String userInput = "monday";
		DateTime userDate = referenceDateTimeParser.parse(userInput);
		
		String parsedDate = userDate.getDate();
		String parsedDayString = userDate.getDayStr();
		int parsedDayInt = userDate.getDayInt();
		
		assertEquals(REFERENCE_THIS_MONDAY_DATE, parsedDate);
		assertEquals(REFERENCE_THIS_MONDAY_DAY_STRING, parsedDayString);
		assertEquals(REFERENCE_THIS_MONDAY_DAY_INT, parsedDayInt);
	}
	
	@Test
	public void parseMondayCaseInsensitive() {
		String userInput = "mONdaY";
		DateTime userDate = referenceDateTimeParser.parse(userInput);
		
		String parsedDate = userDate.getDate();
		String parsedDayString = userDate.getDayStr();
		int parsedDayInt = userDate.getDayInt();
		
		assertEquals(REFERENCE_THIS_MONDAY_DATE, parsedDate);
		assertEquals(REFERENCE_THIS_MONDAY_DAY_STRING, parsedDayString);
		assertEquals(REFERENCE_THIS_MONDAY_DAY_INT, parsedDayInt);
	}
	
	@Test
	public void parseThisMonday() {
		String userInput = "this monday";
		DateTime userDate = referenceDateTimeParser.parse(userInput);
		
		String parsedDate = userDate.getDate();
		String parsedDayString = userDate.getDayStr();
		int parsedDayInt = userDate.getDayInt();
		
		assertEquals(REFERENCE_THIS_MONDAY_DATE, parsedDate);
		assertEquals(REFERENCE_THIS_MONDAY_DAY_STRING, parsedDayString);
		assertEquals(REFERENCE_THIS_MONDAY_DAY_INT, parsedDayInt);
	}
	
	@Test
	public void parseThisMondayCaseInsensitive() {
		String userInput = "thIs mONday";
		DateTime userDate = referenceDateTimeParser.parse(userInput);
		
		String parsedDate = userDate.getDate();
		String parsedDayString = userDate.getDayStr();
		int parsedDayInt = userDate.getDayInt();
		
		assertEquals(REFERENCE_THIS_MONDAY_DATE, parsedDate);
		assertEquals(REFERENCE_THIS_MONDAY_DAY_STRING, parsedDayString);
		assertEquals(REFERENCE_THIS_MONDAY_DAY_INT, parsedDayInt);
	}
	
	@Test
	public void parseNextMonday() {
		String userInput = "next monday";
		DateTime userDate = referenceDateTimeParser.parse(userInput);
		
		String parsedDate = userDate.getDate();
		String parsedDayString = userDate.getDayStr();
		int parsedDayInt = userDate.getDayInt();
		
		assertEquals(REFERENCE_NEXT_MONDAY_DATE, parsedDate);
		assertEquals(REFERENCE_NEXT_MONDAY_DAY_STRING, parsedDayString);
		assertEquals(REFERENCE_NEXT_MONDAY_DAY_INT, parsedDayInt);
	}
	
	@Test
	public void parseNextMondayCaseInsensitive() {
		String userInput = "NExt mONday";
		DateTime userDate = referenceDateTimeParser.parse(userInput);
		
		String parsedDate = userDate.getDate();
		String parsedDayString = userDate.getDayStr();
		int parsedDayInt = userDate.getDayInt();
		
		assertEquals(REFERENCE_NEXT_MONDAY_DATE, parsedDate);
		assertEquals(REFERENCE_NEXT_MONDAY_DAY_STRING, parsedDayString);
		assertEquals(REFERENCE_NEXT_MONDAY_DAY_INT, parsedDayInt);
	}
	
	@Test
	public void parseThisMon() {
		String userInput = "this mon";
		DateTime userDate = referenceDateTimeParser.parse(userInput);
		
		String parsedDate = userDate.getDate();
		String parsedDayString = userDate.getDayStr();
		int parsedDayInt = userDate.getDayInt();
		
		assertEquals(REFERENCE_THIS_MONDAY_DATE, parsedDate);
		assertEquals(REFERENCE_THIS_MONDAY_DAY_STRING, parsedDayString);
		assertEquals(REFERENCE_THIS_MONDAY_DAY_INT, parsedDayInt);
	}
	
	@Test
	public void parseThisMonCaseInsensitive() {
		String userInput = "tHIs mON";
		DateTime userDate = referenceDateTimeParser.parse(userInput);
		
		String parsedDate = userDate.getDate();
		String parsedDayString = userDate.getDayStr();
		int parsedDayInt = userDate.getDayInt();
		
		assertEquals(REFERENCE_THIS_MONDAY_DATE, parsedDate);
		assertEquals(REFERENCE_THIS_MONDAY_DAY_STRING, parsedDayString);
		assertEquals(REFERENCE_THIS_MONDAY_DAY_INT, parsedDayInt);
	}
	
	@Test
	public void parseTwelveDaysLater() {
		String userInput = "12 days";
		DateTime userDate = referenceDateTimeParser.parse(userInput);
		
		String parsedDate = userDate.getDate();
		String parsedDayString = userDate.getDayStr();
		int parsedDayInt = userDate.getDayInt();
		
		assertEquals(REFERENCE_TWELVE_DAYS_LATER_DATE, parsedDate);
		assertEquals(REFERENCE_TWELVE_DAYS_LATER_DAY_STRING, parsedDayString);
		assertEquals(REFERENCE_TWELVE_DAYS_LATER_DAY_INT, parsedDayInt);
	}
	
	@Test
	public void parseTwelveDaysLaterCaseInsensitive() {
		String userInput = "12 DAys";
		DateTime userDate = referenceDateTimeParser.parse(userInput);
		
		String parsedDate = userDate.getDate();
		String parsedDayString = userDate.getDayStr();
		int parsedDayInt = userDate.getDayInt();
		
		assertEquals(REFERENCE_TWELVE_DAYS_LATER_DATE, parsedDate);
		assertEquals(REFERENCE_TWELVE_DAYS_LATER_DAY_STRING, parsedDayString);
		assertEquals(REFERENCE_TWELVE_DAYS_LATER_DAY_INT, parsedDayInt);
	}
	
	@Test
	public void parseTwelveDay() {
		String userInput = "12 day";
		DateTime userDate = referenceDateTimeParser.parse(userInput);
		
		String parsedDate = userDate.getDate();
		String parsedDayString = userDate.getDayStr();
		int parsedDayInt = userDate.getDayInt();
		
		assertEquals(REFERENCE_TWELVE_DAYS_LATER_DATE, parsedDate);
		assertEquals(REFERENCE_TWELVE_DAYS_LATER_DAY_STRING, parsedDayString);
		assertEquals(REFERENCE_TWELVE_DAYS_LATER_DAY_INT, parsedDayInt);
	}
	
	@Test
	public void parseTwelveDayLaterCaseInsensitive() {
		String userInput = "12 DAy";
		DateTime userDate = referenceDateTimeParser.parse(userInput);
		
		String parsedDate = userDate.getDate();
		String parsedDayString = userDate.getDayStr();
		int parsedDayInt = userDate.getDayInt();
		
		assertEquals(REFERENCE_TWELVE_DAYS_LATER_DATE, parsedDate);
		assertEquals(REFERENCE_TWELVE_DAYS_LATER_DAY_STRING, parsedDayString);
		assertEquals(REFERENCE_TWELVE_DAYS_LATER_DAY_INT, parsedDayInt);
	}
	
	@Test
	public void parseTwelveDD() {
		String userInput = "12 dd";
		DateTime userDate = referenceDateTimeParser.parse(userInput);
		
		String parsedDate = userDate.getDate();
		String parsedDayString = userDate.getDayStr();
		int parsedDayInt = userDate.getDayInt();
		
		assertEquals(REFERENCE_TWELVE_DAYS_LATER_DATE, parsedDate);
		assertEquals(REFERENCE_TWELVE_DAYS_LATER_DAY_STRING, parsedDayString);
		assertEquals(REFERENCE_TWELVE_DAYS_LATER_DAY_INT, parsedDayInt);
	}
	
	@Test
	public void parseTwelveDDCaseInsensitive() {
		String userInput = "12 Dd";
		DateTime userDate = referenceDateTimeParser.parse(userInput);
		
		String parsedDate = userDate.getDate();
		String parsedDayString = userDate.getDayStr();
		int parsedDayInt = userDate.getDayInt();
		
		assertEquals(REFERENCE_TWELVE_DAYS_LATER_DATE, parsedDate);
		assertEquals(REFERENCE_TWELVE_DAYS_LATER_DAY_STRING, parsedDayString);
		assertEquals(REFERENCE_TWELVE_DAYS_LATER_DAY_INT, parsedDayInt);
	}
	
	@Test
	public void parseNextWeek() {
		String userInput = "next week";
		DateTime userDate = referenceDateTimeParser.parse(userInput);
		
		String parsedDate = userDate.getDate();
		String parsedDayString = userDate.getDayStr();
		int parsedDayInt = userDate.getDayInt();
		
		assertEquals(REFERENCE_NEXT_WEEK_DATE, parsedDate);
		assertEquals(REFERENCE_NEXT_WEEK_DAY_STRING, parsedDayString);
		assertEquals(REFERENCE_NEXT_WEEK_DAY_INT, parsedDayInt);
	}
	
	@Test
	public void parseNextWeekCaseInsensitive() {
		String userInput = "next wEEk";
		DateTime userDate = referenceDateTimeParser.parse(userInput);
		
		String parsedDate = userDate.getDate();
		String parsedDayString = userDate.getDayStr();
		int parsedDayInt = userDate.getDayInt();
		
		assertEquals(REFERENCE_NEXT_WEEK_DATE, parsedDate);
		assertEquals(REFERENCE_NEXT_WEEK_DAY_STRING, parsedDayString);
		assertEquals(REFERENCE_NEXT_WEEK_DAY_INT, parsedDayInt);
	}
	
	@Test
	public void parseNextWeeks() {
		String userInput = "next weeks";
		DateTime userDate = referenceDateTimeParser.parse(userInput);
		
		String parsedDate = userDate.getDate();
		String parsedDayString = userDate.getDayStr();
		int parsedDayInt = userDate.getDayInt();
		
		assertEquals(REFERENCE_NEXT_WEEK_DATE, parsedDate);
		assertEquals(REFERENCE_NEXT_WEEK_DAY_STRING, parsedDayString);
		assertEquals(REFERENCE_NEXT_WEEK_DAY_INT, parsedDayInt);
	}
	
	@Test
	public void parseNextWeeksCaseInsensitive() {
		String userInput = "next wEEks";
		DateTime userDate = referenceDateTimeParser.parse(userInput);
		
		String parsedDate = userDate.getDate();
		String parsedDayString = userDate.getDayStr();
		int parsedDayInt = userDate.getDayInt();
		
		assertEquals(REFERENCE_NEXT_WEEK_DATE, parsedDate);
		assertEquals(REFERENCE_NEXT_WEEK_DAY_STRING, parsedDayString);
		assertEquals(REFERENCE_NEXT_WEEK_DAY_INT, parsedDayInt);
	}
	
	@Test
	public void parseNextWk() {
		String userInput = "next wk";
		DateTime userDate = referenceDateTimeParser.parse(userInput);
		
		String parsedDate = userDate.getDate();
		String parsedDayString = userDate.getDayStr();
		int parsedDayInt = userDate.getDayInt();
		
		assertEquals(REFERENCE_NEXT_WEEK_DATE, parsedDate);
		assertEquals(REFERENCE_NEXT_WEEK_DAY_STRING, parsedDayString);
		assertEquals(REFERENCE_NEXT_WEEK_DAY_INT, parsedDayInt);
	}
	
	@Test
	public void parseThreeWeeksLater() {
		String userInput = "3 weeks";
		DateTime userDate = referenceDateTimeParser.parse(userInput);
		
		String parsedDate = userDate.getDate();
		String parsedDayString = userDate.getDayStr();
		int parsedDayInt = userDate.getDayInt();
		
		assertEquals(REFERENCE_THREE_WEEKS_LATER_DATE, parsedDate);
		assertEquals(REFERENCE_THREE_WEEKS_LATER_DAY_STRING, parsedDayString);
		assertEquals(REFERENCE_THREE_WEEKS_LATER_DAY_INT, parsedDayInt);
	}
	
	@Test
	public void parseThreeWeeksLaterCaseInsensitive() {
		String userInput = "3 wEEks";
		DateTime userDate = referenceDateTimeParser.parse(userInput);
		
		String parsedDate = userDate.getDate();
		String parsedDayString = userDate.getDayStr();
		int parsedDayInt = userDate.getDayInt();
		
		assertEquals(REFERENCE_THREE_WEEKS_LATER_DATE, parsedDate);
		assertEquals(REFERENCE_THREE_WEEKS_LATER_DAY_STRING, parsedDayString);
		assertEquals(REFERENCE_THREE_WEEKS_LATER_DAY_INT, parsedDayInt);
	}
	
	@Test
	public void parseThreeWeekLater() {
		String userInput = "3 week";
		DateTime userDate = referenceDateTimeParser.parse(userInput);
		
		String parsedDate = userDate.getDate();
		String parsedDayString = userDate.getDayStr();
		int parsedDayInt = userDate.getDayInt();
		
		assertEquals(REFERENCE_THREE_WEEKS_LATER_DATE, parsedDate);
		assertEquals(REFERENCE_THREE_WEEKS_LATER_DAY_STRING, parsedDayString);
		assertEquals(REFERENCE_THREE_WEEKS_LATER_DAY_INT, parsedDayInt);
	}
	
	@Test
	public void parseThreeWeekLaterCaseInsensitive() {
		String userInput = "3 weEK";
		DateTime userDate = referenceDateTimeParser.parse(userInput);
		
		String parsedDate = userDate.getDate();
		String parsedDayString = userDate.getDayStr();
		int parsedDayInt = userDate.getDayInt();
		
		assertEquals(REFERENCE_THREE_WEEKS_LATER_DATE, parsedDate);
		assertEquals(REFERENCE_THREE_WEEKS_LATER_DAY_STRING, parsedDayString);
		assertEquals(REFERENCE_THREE_WEEKS_LATER_DAY_INT, parsedDayInt);
	}
	
	@Test
	public void parseThreeWkLater() {
		String userInput = "3 wk";
		DateTime userDate = referenceDateTimeParser.parse(userInput);
		
		String parsedDate = userDate.getDate();
		String parsedDayString = userDate.getDayStr();
		int parsedDayInt = userDate.getDayInt();
		
		assertEquals(REFERENCE_THREE_WEEKS_LATER_DATE, parsedDate);
		assertEquals(REFERENCE_THREE_WEEKS_LATER_DAY_STRING, parsedDayString);
		assertEquals(REFERENCE_THREE_WEEKS_LATER_DAY_INT, parsedDayInt);
	}
	
	@Test
	public void parseThreeWkLaterCaseInsensitive() {
		String userInput = "3 WK";
		DateTime userDate = referenceDateTimeParser.parse(userInput);
		
		String parsedDate = userDate.getDate();
		String parsedDayString = userDate.getDayStr();
		int parsedDayInt = userDate.getDayInt();
		
		assertEquals(REFERENCE_THREE_WEEKS_LATER_DATE, parsedDate);
		assertEquals(REFERENCE_THREE_WEEKS_LATER_DAY_STRING, parsedDayString);
		assertEquals(REFERENCE_THREE_WEEKS_LATER_DAY_INT, parsedDayInt);
	}
	
	
	@Test
	public void parseToday() {
		String todayString = "today";
		DateTime todayParsed = dateTimeParser.parse(todayString);
		String dateParsed = todayParsed.getDate();
		String dayStrParsed = todayParsed.getDayStr();
		int dayIntParsed = todayParsed.getDayInt();
		
		assertEquals(todayDate, dateParsed);
		assertEquals(todayDayString, dayStrParsed);
		assertEquals(todayDayInt, dayIntParsed);
	}
	
	@Test
	public void parseTdy() {
		String todayShortForm = "tdy";
		DateTime todayParsed = dateTimeParser.parse(todayShortForm);
		String dateParsed = todayParsed.getDate();
		String dayStrParsed = todayParsed.getDayStr();
		int dayIntParsed = todayParsed.getDayInt();
		
		assertEquals(todayDate, dateParsed);
		assertEquals(todayDayString, dayStrParsed);
		assertEquals(todayDayInt, dayIntParsed);
	}
	
	@Test
	public void parseTodayCaseInsensitive() {
		String todayCaseInsensitive = "ToDAy";
		DateTime todayParsed = dateTimeParser.parse(todayCaseInsensitive);
		String dateParsed = todayParsed.getDate();
		String dayStrParsed = todayParsed.getDayStr();
		int dayIntParsed = todayParsed.getDayInt();
		
		assertEquals(todayDate, dateParsed);
		assertEquals(todayDayString, dayStrParsed);
		assertEquals(todayDayInt, dayIntParsed);
	}
	
	@Test
	public void parseTdyCaseInsensitive() {
		String tdyCaseInsensitive = "TDy";
		DateTime todayParsed = dateTimeParser.parse(tdyCaseInsensitive);
		String dateParsed = todayParsed.getDate();
		String dayStrParsed = todayParsed.getDayStr();
		int dayIntParsed = todayParsed.getDayInt();
		
		assertEquals(todayDate, dateParsed);
		assertEquals(todayDayString, dayStrParsed);
		assertEquals(todayDayInt, dayIntParsed);
	}
	
	@Test
	public void parseTomorrow() {
		String tomorrowInput = "tomorrow";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(tomorrowInput);
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		
		assertEquals(REFERENCE_TOMORROW_DATE, dateParsed);
		assertEquals(REFERENCE_TOMORROW_DAY_STRING, dayStrParsed);
		assertEquals(REFERENCE_TOMORROW_DAY_INT, dayIntParsed);
	}
	
	@Test
	public void parseTomorrowCaseInsensitive() {
		String tomorrowInput = "tomORroW";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(tomorrowInput);
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		
		assertEquals(REFERENCE_TOMORROW_DATE, dateParsed);
		assertEquals(REFERENCE_TOMORROW_DAY_STRING, dayStrParsed);
		assertEquals(REFERENCE_TOMORROW_DAY_INT, dayIntParsed);
	}
	
	@Test
	public void parseTmr() {
		String tomorrowInput = "tmr";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(tomorrowInput);
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		
		assertEquals(REFERENCE_TOMORROW_DATE, dateParsed);
		assertEquals(REFERENCE_TOMORROW_DAY_STRING, dayStrParsed);
		assertEquals(REFERENCE_TOMORROW_DAY_INT, dayIntParsed);
	}
	
	@Test
	public void parseTmrCaseInsensitive() {
		String tomorrowInput = "tMR";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(tomorrowInput);
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		
		assertEquals(REFERENCE_TOMORROW_DATE, dateParsed);
		assertEquals(REFERENCE_TOMORROW_DAY_STRING, dayStrParsed);
		assertEquals(REFERENCE_TOMORROW_DAY_INT, dayIntParsed);
	}
	
	
	@Test(expected = IncorrectInputException.class) 
	public void parseNegativeNumberOfWeeks() {
		String relativeDate = "-10 weeks";
		dateTimeParser.parse(relativeDate);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parseNegativeNumberOfDays() {
		String relativeDate = "-10 days";
		dateTimeParser.parse(relativeDate);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parseTodayTomorrowInOneInput() {
		String relativeDate = "tmr today";
		dateTimeParser.parse(relativeDate);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parse2Weeks2DaysInOneInput() {
		String relativeDate = "2 weeks 2 days";
		dateTimeParser.parse(relativeDate);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parse2Tuesdays() {
		String relativeDate = "2 tue";
		dateTimeParser.parse(relativeDate);
	}
	//********************************************
	//******** Tests for FixedDateParser *********
	//********************************************
	@Test 
	public void parseNumberDate() {
		String numberDate = "1/10/2016";
		DateTime userDate = dateTimeParser.parse(numberDate);
		
		String parsedDate = userDate.getDate();
		String expectedDate = "1 Oct 2016";
		assertEquals(expectedDate, parsedDate);
	}
	
	@Test 
	public void parseNumberDateWithoutYearNotOver() {
		String numberDate = "1/10";
		DateTime userDate = dateTimeParser.parse(numberDate);
		
		String parsedDate = userDate.getDate();
		String expectedDate = "1 Oct 2016";
		assertEquals(expectedDate, parsedDate);
	}
	
	@Test 
	public void parseNumberDateWithoutYearOver() {
		String numberDate = "1/2";
		DateTime userDate = dateTimeParser.parse(numberDate);
		
		String parsedDate = userDate.getDate();
		String expectedDate = "1 Feb 2017";
		assertEquals(expectedDate, parsedDate);
	}
	
	@Test 
	public void parseWordDate() {
		String numberDate = "12 Dec 2016";
		DateTime userDate = dateTimeParser.parse(numberDate);
		
		String parsedDate = userDate.getDate();
		String expectedDate = "12 Dec 2016";
		assertEquals(expectedDate, parsedDate);
	}
	
	@Test 
	public void parseWordDateWithoutYearOver() {
		String numberDate = "12 Mar";
		DateTime userDate = dateTimeParser.parse(numberDate);
		
		String parsedDate = userDate.getDate();
		String expectedDate = "12 Mar 2017";
		assertEquals(expectedDate, parsedDate);
	}
	
	@Test 
	public void parseWordDateWithoutYearNotOver() {
		String numberDate = "12 Sep";
		DateTime userDate = dateTimeParser.parse(numberDate);
		
		String parsedDate = userDate.getDate();
		String expectedDate = "12 Sep 2016";
		assertEquals(expectedDate, parsedDate);
	}
	
	@Test 
	public void parseWordDateMonthOnlyNotOver() {
		String numberDate = "Sep";
		DateTime userDate = dateTimeParser.parse(numberDate);
		
		String parsedDate = userDate.getDate();
		String expectedDate = "15 Sep 2016";
		assertEquals(expectedDate, parsedDate);
	}
	
	@Test 
	public void parseWordDateMonthOnlyOver() {
		String numberDate = "Feb";
		DateTime userDate = dateTimeParser.parse(numberDate);
		
		String parsedDate = userDate.getDate();
		String expectedDate = "15 Feb 2017";
		assertEquals(expectedDate, parsedDate);
	}

	@Test(expected = IncorrectInputException.class) 
	public void parseInvalidWordDateWithNegativeDay() {
		String wordDate = "-1 Mar 2016";
		dateTimeParser.parse(wordDate);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parseInvalidWordDateWithNegativeYear() {
		String wordDate = "1 Mar -2016";
		dateTimeParser.parse(wordDate);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parseInvalidWordDate() {
		String numberDate = "1 Gibberish 2016";
		dateTimeParser.parse(numberDate);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parseNumberDateWithInvalidPositiveDay() {
		String numberDate = "40/10/2016";
		dateTimeParser.parse(numberDate);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parseIncompleteNumberDate() {
		String numberDate = "4/";
		dateTimeParser.parse(numberDate);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parseInvalidNumberDateTooManyFields() {
		String numberDate = "4/10/2016/20/15";
		dateTimeParser.parse(numberDate);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parseInvalidNumberDate() {
		String numberDate = "a/b/c";
		dateTimeParser.parse(numberDate);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parseNegativeNumberDate() {
		String numberDate = "-10 -12 -2016";
		dateTimeParser.parse(numberDate);
	}
	
	@Test//(expected = IncorrectInputException.class) 
	public void parseNumberDateWithInvalidPositiveYear() {
		String numberDate = "4/10/16";
		dateTimeParser.parse(numberDate);
	}
	
	/* This is a boundary case for the positive value partition */
	@Test(expected = IncorrectInputException.class) 
	public void parseInvalidMonthInNumberDate() {
		String numberDate = "29/20/2017";
		dateTimeParser.parse(numberDate);
	}
	
	/* This is a boundary case for the positive value partition */
	@Test(expected = IncorrectInputException.class) 
	public void parseInvalidNumberDateLeapDay() {
		String numberDate = "29/2/2017";
		dateTimeParser.parse(numberDate);
	}
	
	/* This is a boundary case for the negative value partition */
	@Test(expected = IncorrectInputException.class) 
	public void parseNumberDateWithInvalidNegativeDay() {
		String numberDate = "-1/10/2016";
		dateTimeParser.parse(numberDate);
	}
	
	/* This is a boundary case for the negative value partition */
	@Test(expected = IncorrectInputException.class) 
	public void parseNumberDateWithInvalidNegativeMonth() {
		String numberDate = "1/-10/2016";
		dateTimeParser.parse(numberDate);
	}
	
	/* This is a boundary case for the negative value partition */
	@Test(expected = IncorrectInputException.class) 
	public void parseNumberDateWithInvalidNegativeYear() {
		String numberDate = "1/10/-2016";
		dateTimeParser.parse(numberDate);
	}
	
	/* This is a boundary case for the negative value partition */
	@Test(expected = IncorrectInputException.class) 
	public void parseNumberDateWithInvalidNegativeDayMonthYear() {
		String numberDate = "-1/-10/-2016";
		dateTimeParser.parse(numberDate);
	}
	
	@Test//(expected = IncorrectInputException.class) 
	public void parseDateThatHasPassed() {
		String userInput = "17 Feb 2015";
		referenceDateTimeParser.parse(userInput);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parseTwoWordDatesInOneInput() {
		String userInput = "17 Feb 2017 20 March 2018";
		dateTimeParser.parse(userInput);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parseTwoShortNumberDatesInOneInput() {
		String userInput = "17/2 18/3";
		dateTimeParser.parse(userInput);
	}
	//********************************************
	//*********** Tests for TimeParser ***********
	//********************************************
	@Test
	public void parseTimeThatHasPassed() {
		String userInput = "5 am";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(userInput);
		
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		int time24hParsed = parsedDateTimeObject.getTimeInt();
		String time12hStringParsed = parsedDateTimeObject.getTime12hStr();
		String time24hStringParsed = parsedDateTimeObject.getTime24hStr();
		int expectedTime24H = 500;
		String expected12hString = "5.00 am";
		String expected24hString = "05:00";
		
		assertEquals(REFERENCE_TOMORROW_DATE, dateParsed);
		assertEquals(REFERENCE_TOMORROW_DAY_STRING, dayStrParsed);
		assertEquals(REFERENCE_TOMORROW_DAY_INT, dayIntParsed);
		assertEquals(expectedTime24H, time24hParsed);
		assertEquals(expected12hString, time12hStringParsed);
		assertEquals(expected24hString, time24hStringParsed);
	}
	
	@Test
	public void parseTime12HourTimeNoSpace1am() {
		String userInput = "1am";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(userInput);
		
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		int time24hParsed = parsedDateTimeObject.getTimeInt();
		String time12hStringParsed = parsedDateTimeObject.getTime12hStr();
		String time24hStringParsed = parsedDateTimeObject.getTime24hStr();
		int expectedTime24H = 100;
		String expected12hString = "1.00 am";
		String expected24hString = "01:00";
		
		assertEquals(REFERENCE_TOMORROW_DATE, dateParsed);
		assertEquals(REFERENCE_TOMORROW_DAY_STRING, dayStrParsed);
		assertEquals(REFERENCE_TOMORROW_DAY_INT, dayIntParsed);
		assertEquals(expectedTime24H, time24hParsed);
		assertEquals(expected12hString, time12hStringParsed);
		assertEquals(expected24hString, time24hStringParsed);
	}
	
	@Test
	public void parseTime12HourTimeNoSpace130am() {
		String userInput = "1.30am";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(userInput);
		
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		int time24hParsed = parsedDateTimeObject.getTimeInt();
		String time12hStringParsed = parsedDateTimeObject.getTime12hStr();
		String time24hStringParsed = parsedDateTimeObject.getTime24hStr();
		int expectedTime24H = 130;
		String expected12hString = "1.30 am";
		String expected24hString = "01:30";
		
		assertEquals(REFERENCE_TOMORROW_DATE, dateParsed);
		assertEquals(REFERENCE_TOMORROW_DAY_STRING, dayStrParsed);
		assertEquals(REFERENCE_TOMORROW_DAY_INT, dayIntParsed);
		assertEquals(expectedTime24H, time24hParsed);
		assertEquals(expected12hString, time12hStringParsed);
		assertEquals(expected24hString, time24hStringParsed);
	}
	
	@Test
	public void parseTime12HourTimeNoSpace1240am() {
		String userInput = "12.40am";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(userInput);
		
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		int time24hParsed = parsedDateTimeObject.getTimeInt();
		String time12hStringParsed = parsedDateTimeObject.getTime12hStr();
		String time24hStringParsed = parsedDateTimeObject.getTime24hStr();
		int expectedTime24H = 40;
		String expected12hString = "12.40 am";
		String expected24hString = "00:40";
		
		assertEquals(REFERENCE_TOMORROW_DATE, dateParsed);
		assertEquals(REFERENCE_TOMORROW_DAY_STRING, dayStrParsed);
		assertEquals(REFERENCE_TOMORROW_DAY_INT, dayIntParsed);
		assertEquals(expectedTime24H, time24hParsed);
		assertEquals(expected12hString, time12hStringParsed);
		assertEquals(expected24hString, time24hStringParsed);
	}
	
	@Test
	public void parseTime12HourTimeWithSpace1am() {
		String userInput = "1 am";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(userInput);
		
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		int time24hParsed = parsedDateTimeObject.getTimeInt();
		String time12hStringParsed = parsedDateTimeObject.getTime12hStr();
		String time24hStringParsed = parsedDateTimeObject.getTime24hStr();
		int expectedTime24H = 100;
		String expected12hString = "1.00 am";
		String expected24hString = "01:00";
		
		assertEquals(REFERENCE_TOMORROW_DATE, dateParsed);
		assertEquals(REFERENCE_TOMORROW_DAY_STRING, dayStrParsed);
		assertEquals(REFERENCE_TOMORROW_DAY_INT, dayIntParsed);
		assertEquals(expectedTime24H, time24hParsed);
		assertEquals(expected12hString, time12hStringParsed);
		assertEquals(expected24hString, time24hStringParsed);
	}
	
	@Test
	public void parseTime12HourTimeWithSpace130am() {
		String userInput = "1.30 am";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(userInput);
		
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		int time24hParsed = parsedDateTimeObject.getTimeInt();
		String time12hStringParsed = parsedDateTimeObject.getTime12hStr();
		String time24hStringParsed = parsedDateTimeObject.getTime24hStr();
		int expectedTime24H = 130;
		String expected12hString = "1.30 am";
		String expected24hString = "01:30";
		
		assertEquals(REFERENCE_TOMORROW_DATE, dateParsed);
		assertEquals(REFERENCE_TOMORROW_DAY_STRING, dayStrParsed);
		assertEquals(REFERENCE_TOMORROW_DAY_INT, dayIntParsed);
		assertEquals(expectedTime24H, time24hParsed);
		assertEquals(expected12hString, time12hStringParsed);
		assertEquals(expected24hString, time24hStringParsed);
	}
	
	@Test
	public void parseTime12HourTimeWithSpace1240am() {
		String userInput = "12.40 am";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(userInput);
		
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		int time24hParsed = parsedDateTimeObject.getTimeInt();
		String time12hStringParsed = parsedDateTimeObject.getTime12hStr();
		String time24hStringParsed = parsedDateTimeObject.getTime24hStr();
		int expectedTime24H = 40;
		String expected12hString = "12.40 am";
		String expected24hString = "00:40";
		
		assertEquals(REFERENCE_TOMORROW_DATE, dateParsed);
		assertEquals(REFERENCE_TOMORROW_DAY_STRING, dayStrParsed);
		assertEquals(REFERENCE_TOMORROW_DAY_INT, dayIntParsed);
		assertEquals(expectedTime24H, time24hParsed);
		assertEquals(expected12hString, time12hStringParsed);
		assertEquals(expected24hString, time24hStringParsed);
	}
	
	@Test
	public void parseTime12HourTimeNoSpace10am() {
		String userInput = "10am";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(userInput);
		
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		int time24hParsed = parsedDateTimeObject.getTimeInt();
		String time12hStringParsed = parsedDateTimeObject.getTime12hStr();
		String time24hStringParsed = parsedDateTimeObject.getTime24hStr();
		int expectedTime24H = 1000;
		String expected12hString = "10.00 am";
		String expected24hString = "10:00";
		
		assertEquals(REFERENCE_TODAY_DATE, dateParsed);
		assertEquals(REFERENCE_TODAY_DAY_STRING, dayStrParsed);
		assertEquals(REFERENCE_TODAY_DAY_INT, dayIntParsed);
		assertEquals(expectedTime24H, time24hParsed);
		assertEquals(expected12hString, time12hStringParsed);
		assertEquals(expected24hString, time24hStringParsed);
	}
	
	@Test
	public void parseTime12HourTimeWithSpace10am() {
		String userInput = "10 am";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(userInput);
		
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		int time24hParsed = parsedDateTimeObject.getTimeInt();
		String time12hStringParsed = parsedDateTimeObject.getTime12hStr();
		String time24hStringParsed = parsedDateTimeObject.getTime24hStr();
		int expectedTime24H = 1000;
		String expected12hString = "10.00 am";
		String expected24hString = "10:00";
		
		assertEquals(REFERENCE_TODAY_DATE, dateParsed);
		assertEquals(REFERENCE_TODAY_DAY_STRING, dayStrParsed);
		assertEquals(REFERENCE_TODAY_DAY_INT, dayIntParsed);
		assertEquals(expectedTime24H, time24hParsed);
		assertEquals(expected12hString, time12hStringParsed);
		assertEquals(expected24hString, time24hStringParsed);
	}
	
	@Test
	public void parseTime12HourTimeNoSpace12pm() {
		String userInput = "12pm";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(userInput);
		
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		int time24hParsed = parsedDateTimeObject.getTimeInt();
		String time12hStringParsed = parsedDateTimeObject.getTime12hStr();
		String time24hStringParsed = parsedDateTimeObject.getTime24hStr();
		int expectedTime24H = 1200;
		String expected12hString = "12.00 pm";
		String expected24hString = "12:00";
		
		assertEquals(REFERENCE_TODAY_DATE, dateParsed);
		assertEquals(REFERENCE_TODAY_DAY_STRING, dayStrParsed);
		assertEquals(REFERENCE_TODAY_DAY_INT, dayIntParsed);
		assertEquals(expectedTime24H, time24hParsed);
		assertEquals(expected12hString, time12hStringParsed);
		assertEquals(expected24hString, time24hStringParsed);
	}
	
	@Test
	public void parseTime12HourTimeWithSpace12pm() {
		String userInput = "12 pm";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(userInput);
		
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		int time24hParsed = parsedDateTimeObject.getTimeInt();
		String time12hStringParsed = parsedDateTimeObject.getTime12hStr();
		String time24hStringParsed = parsedDateTimeObject.getTime24hStr();
		int expectedTime24H = 1200;
		String expected12hString = "12.00 pm";
		String expected24hString = "12:00";
		
		assertEquals(REFERENCE_TODAY_DATE, dateParsed);
		assertEquals(REFERENCE_TODAY_DAY_STRING, dayStrParsed);
		assertEquals(REFERENCE_TODAY_DAY_INT, dayIntParsed);
		assertEquals(expectedTime24H, time24hParsed);
		assertEquals(expected12hString, time12hStringParsed);
		assertEquals(expected24hString, time24hStringParsed);
	}
	
	@Test
	public void parseTime12HourTimeNoSpace1230pm() {
		String userInput = "12.30pm";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(userInput);
		
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		int time24hParsed = parsedDateTimeObject.getTimeInt();
		String time12hStringParsed = parsedDateTimeObject.getTime12hStr();
		String time24hStringParsed = parsedDateTimeObject.getTime24hStr();
		int expectedTime24H = 1230;
		String expected12hString = "12.30 pm";
		String expected24hString = "12:30";
		
		assertEquals(REFERENCE_TODAY_DATE, dateParsed);
		assertEquals(REFERENCE_TODAY_DAY_STRING, dayStrParsed);
		assertEquals(REFERENCE_TODAY_DAY_INT, dayIntParsed);
		assertEquals(expectedTime24H, time24hParsed);
		assertEquals(expected12hString, time12hStringParsed);
		assertEquals(expected24hString, time24hStringParsed);
	}
	
	@Test
	public void parseTime12HourTimeWithSpace1230pm() {
		String userInput = "12.30 pm";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(userInput);
		
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		int time24hParsed = parsedDateTimeObject.getTimeInt();
		String time12hStringParsed = parsedDateTimeObject.getTime12hStr();
		String time24hStringParsed = parsedDateTimeObject.getTime24hStr();
		int expectedTime24H = 1230;
		String expected12hString = "12.30 pm";
		String expected24hString = "12:30";
		
		assertEquals(REFERENCE_TODAY_DATE, dateParsed);
		assertEquals(REFERENCE_TODAY_DAY_STRING, dayStrParsed);
		assertEquals(REFERENCE_TODAY_DAY_INT, dayIntParsed);
		assertEquals(expectedTime24H, time24hParsed);
		assertEquals(expected12hString, time12hStringParsed);
		assertEquals(expected24hString, time24hStringParsed);
	}
	
	@Test
	public void parseTime12HourTimeNoSpace11pm() {
		String userInput = "11pm";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(userInput);
		
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		int time24hParsed = parsedDateTimeObject.getTimeInt();
		String time12hStringParsed = parsedDateTimeObject.getTime12hStr();
		String time24hStringParsed = parsedDateTimeObject.getTime24hStr();
		int expectedTime24H = 2300;
		String expected12hString = "11.00 pm";
		String expected24hString = "23:00";
		
		assertEquals(REFERENCE_TODAY_DATE, dateParsed);
		assertEquals(REFERENCE_TODAY_DAY_STRING, dayStrParsed);
		assertEquals(REFERENCE_TODAY_DAY_INT, dayIntParsed);
		assertEquals(expectedTime24H, time24hParsed);
		assertEquals(expected12hString, time12hStringParsed);
		assertEquals(expected24hString, time24hStringParsed);
	}
	
	@Test
	public void parseTime12HourTimeWithSpace11pm() {
		String userInput = "11 pm";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(userInput);
		
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		int time24hParsed = parsedDateTimeObject.getTimeInt();
		String time12hStringParsed = parsedDateTimeObject.getTime12hStr();
		String time24hStringParsed = parsedDateTimeObject.getTime24hStr();
		int expectedTime24H = 2300;
		String expected12hString = "11.00 pm";
		String expected24hString = "23:00";
		
		assertEquals(REFERENCE_TODAY_DATE, dateParsed);
		assertEquals(REFERENCE_TODAY_DAY_STRING, dayStrParsed);
		assertEquals(REFERENCE_TODAY_DAY_INT, dayIntParsed);
		assertEquals(expectedTime24H, time24hParsed);
		assertEquals(expected12hString, time12hStringParsed);
		assertEquals(expected24hString, time24hStringParsed);
	}
	
	@Test
	public void parseTime12HourTimeNoSpace1130pm() {
		String userInput = "11.30pm";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(userInput);
		
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		int time24hParsed = parsedDateTimeObject.getTimeInt();
		String time12hStringParsed = parsedDateTimeObject.getTime12hStr();
		String time24hStringParsed = parsedDateTimeObject.getTime24hStr();
		int expectedTime24H = 2330;
		String expected12hString = "11.30 pm";
		String expected24hString = "23:30";
		
		assertEquals(REFERENCE_TODAY_DATE, dateParsed);
		assertEquals(REFERENCE_TODAY_DAY_STRING, dayStrParsed);
		assertEquals(REFERENCE_TODAY_DAY_INT, dayIntParsed);
		assertEquals(expectedTime24H, time24hParsed);
		assertEquals(expected12hString, time12hStringParsed);
		assertEquals(expected24hString, time24hStringParsed);
	}
	
	@Test
	public void parseTime12HourTimeWithSpace1130pm() {
		String userInput = "11.30 pm";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(userInput);
		
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		int time24hParsed = parsedDateTimeObject.getTimeInt();
		String time12hStringParsed = parsedDateTimeObject.getTime12hStr();
		String time24hStringParsed = parsedDateTimeObject.getTime24hStr();
		int expectedTime24H = 2330;
		String expected12hString = "11.30 pm";
		String expected24hString = "23:30";
		
		assertEquals(REFERENCE_TODAY_DATE, dateParsed);
		assertEquals(REFERENCE_TODAY_DAY_STRING, dayStrParsed);
		assertEquals(REFERENCE_TODAY_DAY_INT, dayIntParsed);
		assertEquals(expectedTime24H, time24hParsed);
		assertEquals(expected12hString, time12hStringParsed);
		assertEquals(expected24hString, time24hStringParsed);
	}
	
	@Test
	public void parseTime12HourTimeNoSpace5pm() {
		String userInput = "5pm";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(userInput);
		
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		int time24hParsed = parsedDateTimeObject.getTimeInt();
		String time12hStringParsed = parsedDateTimeObject.getTime12hStr();
		String time24hStringParsed = parsedDateTimeObject.getTime24hStr();
		int expectedTime24H = 1700;
		String expected12hString = "5.00 pm";
		String expected24hString = "17:00";
		
		assertEquals(REFERENCE_TODAY_DATE, dateParsed);
		assertEquals(REFERENCE_TODAY_DAY_STRING, dayStrParsed);
		assertEquals(REFERENCE_TODAY_DAY_INT, dayIntParsed);
		assertEquals(expectedTime24H, time24hParsed);
		assertEquals(expected12hString, time12hStringParsed);
		assertEquals(expected24hString, time24hStringParsed);
	}
	
	@Test
	public void parseTime12HourTimeWithSpace5pm() {
		String userInput = "5 pm";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(userInput);
		
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		int time24hParsed = parsedDateTimeObject.getTimeInt();
		String time12hStringParsed = parsedDateTimeObject.getTime12hStr();
		String time24hStringParsed = parsedDateTimeObject.getTime24hStr();
		int expectedTime24H = 1700;
		String expected12hString = "5.00 pm";
		String expected24hString = "17:00";
		
		assertEquals(REFERENCE_TODAY_DATE, dateParsed);
		assertEquals(REFERENCE_TODAY_DAY_STRING, dayStrParsed);
		assertEquals(REFERENCE_TODAY_DAY_INT, dayIntParsed);
		assertEquals(expectedTime24H, time24hParsed);
		assertEquals(expected12hString, time12hStringParsed);
		assertEquals(expected24hString, time24hStringParsed);
	}
	
	@Test
	public void parseTime12HourTimeNoSpace530pm() {
		String userInput = "5.30pm";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(userInput);
		
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		int time24hParsed = parsedDateTimeObject.getTimeInt();
		String time12hStringParsed = parsedDateTimeObject.getTime12hStr();
		String time24hStringParsed = parsedDateTimeObject.getTime24hStr();
		int expectedTime24H = 1730;
		String expected12hString = "5.30 pm";
		String expected24hString = "17:30";
		
		assertEquals(REFERENCE_TODAY_DATE, dateParsed);
		assertEquals(REFERENCE_TODAY_DAY_STRING, dayStrParsed);
		assertEquals(REFERENCE_TODAY_DAY_INT, dayIntParsed);
		assertEquals(expectedTime24H, time24hParsed);
		assertEquals(expected12hString, time12hStringParsed);
		assertEquals(expected24hString, time24hStringParsed);
	}
	
	@Test
	public void parseTime12HourTimeWithSpace530pm() {
		String userInput = "5.30 pm";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(userInput);
		
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		int time24hParsed = parsedDateTimeObject.getTimeInt();
		String time12hStringParsed = parsedDateTimeObject.getTime12hStr();
		String time24hStringParsed = parsedDateTimeObject.getTime24hStr();
		int expectedTime24H = 1730;
		String expected12hString = "5.30 pm";
		String expected24hString = "17:30";
		
		assertEquals(REFERENCE_TODAY_DATE, dateParsed);
		assertEquals(REFERENCE_TODAY_DAY_STRING, dayStrParsed);
		assertEquals(REFERENCE_TODAY_DAY_INT, dayIntParsed);
		assertEquals(expectedTime24H, time24hParsed);
		assertEquals(expected12hString, time12hStringParsed);
		assertEquals(expected24hString, time24hStringParsed);
	}
	
	@Test
	public void parseTenThirtyAmWithSpaceAndDotTimeSeparator() {
		String timeInput = "10.30 am";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(timeInput);
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		
		assertEquals(referenceDateTimeObject.getDate(), dateParsed);
		assertEquals(referenceDayString, dayStrParsed);
		assertEquals(referenceDayInt, dayIntParsed);
		
		int timeInt = parsedDateTimeObject.getTimeInt();
		int expectedTimeInt = 1030;
		String time24HString = parsedDateTimeObject.getTime24hStr();
		String time12HString = parsedDateTimeObject.getTime12hStr();
		String expected24HTimeString = "10:30";
		String expected12HTimeString = "10.30 am";
		
		assertEquals(expectedTimeInt, timeInt);
		assertEquals(expected24HTimeString, time24HString);
		assertEquals(expected12HTimeString, time12HString);
	}
	
	@Test
	public void parseTenThirtyAmWithSpaceAndDotTimeSeparatorCaseInsensitive() {
		String timeInput = "10.30 Am";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(timeInput);
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		
		assertEquals(referenceDateTimeObject.getDate(), dateParsed);
		assertEquals(referenceDayString, dayStrParsed);
		assertEquals(referenceDayInt, dayIntParsed);
		
		int timeInt = parsedDateTimeObject.getTimeInt();
		int expectedTimeInt = 1030;
		String time24HString = parsedDateTimeObject.getTime24hStr();
		String time12HString = parsedDateTimeObject.getTime12hStr();
		String expected24HTimeString = "10:30";
		String expected12HTimeString = "10.30 am";
		
		assertEquals(expectedTimeInt, timeInt);
		assertEquals(expected24HTimeString, time24HString);
		assertEquals(expected12HTimeString, time12HString);
	}
	
	
	@Test
	public void parseTenThirtyAmWithoutSpaceAndDotTimeSeparator() {
		String timeInput = "10.30am";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(timeInput);
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		
		assertEquals(referenceDateTimeObject.getDate(), dateParsed);
		assertEquals(referenceDayString, dayStrParsed);
		assertEquals(referenceDayInt, dayIntParsed);
		
		int timeInt = parsedDateTimeObject.getTimeInt();
		int expectedTimeInt = 1030;
		String time24HString = parsedDateTimeObject.getTime24hStr();
		String time12HString = parsedDateTimeObject.getTime12hStr();
		String expected24HTimeString = "10:30";
		String expected12HTimeString = "10.30 am";
		
		assertEquals(expectedTimeInt, timeInt);
		assertEquals(expected24HTimeString, time24HString);
		assertEquals(expected12HTimeString, time12HString);
	}
	
	@Test
	public void parseTenThirtyAmWithoutSpaceAndDotTimeSeparatorCaseInsensitive() {
		String timeInput = "10.30AM";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(timeInput);
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		
		assertEquals(referenceDateTimeObject.getDate(), dateParsed);
		assertEquals(referenceDayString, dayStrParsed);
		assertEquals(referenceDayInt, dayIntParsed);
		
		int timeInt = parsedDateTimeObject.getTimeInt();
		int expectedTimeInt = 1030;
		String time24HString = parsedDateTimeObject.getTime24hStr();
		String time12HString = parsedDateTimeObject.getTime12hStr();
		String expected24HTimeString = "10:30";
		String expected12HTimeString = "10.30 am";
		
		assertEquals(expectedTimeInt, timeInt);
		assertEquals(expected24HTimeString, time24HString);
		assertEquals(expected12HTimeString, time12HString);
	}
	
	@Test
	public void parseTenThirtyPmWithSpaceAndDotTimeSeparator() {
		String timeInput = "10.30 pm";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(timeInput);
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		
		assertEquals(referenceDateTimeObject.getDate(), dateParsed);
		assertEquals(referenceDayString, dayStrParsed);
		assertEquals(referenceDayInt, dayIntParsed);
		
		int timeInt = parsedDateTimeObject.getTimeInt();
		int expectedTimeInt = 2230;
		String time24HString = parsedDateTimeObject.getTime24hStr();
		String time12HString = parsedDateTimeObject.getTime12hStr();
		String expected24HTimeString = "22:30";
		String expected12HTimeString = "10.30 pm";
		
		assertEquals(expectedTimeInt, timeInt);
		assertEquals(expected24HTimeString, time24HString);
		assertEquals(expected12HTimeString, time12HString);
	}
	
	@Test
	public void parseTenThirtyPmWithSpaceAndDotTimeSeparatorCaseInsensitive() {
		String timeInput = "10.30 pM";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(timeInput);
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		
		assertEquals(referenceDateTimeObject.getDate(), dateParsed);
		assertEquals(referenceDayString, dayStrParsed);
		assertEquals(referenceDayInt, dayIntParsed);
		
		int timeInt = parsedDateTimeObject.getTimeInt();
		int expectedTimeInt = 2230;
		String time24HString = parsedDateTimeObject.getTime24hStr();
		String time12HString = parsedDateTimeObject.getTime12hStr();
		String expected24HTimeString = "22:30";
		String expected12HTimeString = "10.30 pm";
		
		assertEquals(expectedTimeInt, timeInt);
		assertEquals(expected24HTimeString, time24HString);
		assertEquals(expected12HTimeString, time12HString);
	}
	
	@Test
	public void parseTenThirtyPmWithoutSpaceAndDotTimeSeparator() {
		String timeInput = "10.30pm";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(timeInput);
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		
		assertEquals(referenceDateTimeObject.getDate(), dateParsed);
		assertEquals(referenceDayString, dayStrParsed);
		assertEquals(referenceDayInt, dayIntParsed);
		
		int timeInt = parsedDateTimeObject.getTimeInt();
		int expectedTimeInt = 2230;
		String time24HString = parsedDateTimeObject.getTime24hStr();
		String time12HString = parsedDateTimeObject.getTime12hStr();
		String expected24HTimeString = "22:30";
		String expected12HTimeString = "10.30 pm";
		
		assertEquals(expectedTimeInt, timeInt);
		assertEquals(expected24HTimeString, time24HString);
		assertEquals(expected12HTimeString, time12HString);
	}
	
	@Test
	public void parseTenThirtyPmWithoutSpaceAndDotTimeSeparatorCaseInsensitive() {
		String timeInput = "10.30PM";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(timeInput);
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		
		assertEquals(referenceDateTimeObject.getDate(), dateParsed);
		assertEquals(referenceDayString, dayStrParsed);
		assertEquals(referenceDayInt, dayIntParsed);
		
		int timeInt = parsedDateTimeObject.getTimeInt();
		int expectedTimeInt = 2230;
		String time24HString = parsedDateTimeObject.getTime24hStr();
		String time12HString = parsedDateTimeObject.getTime12hStr();
		String expected24HTimeString = "22:30";
		String expected12HTimeString = "10.30 pm";
		
		assertEquals(expectedTimeInt, timeInt);
		assertEquals(expected24HTimeString, time24HString);
		assertEquals(expected12HTimeString, time12HString);
	}
	
	@Test
	public void parseTenThirtyAmWithSpaceAndColonTimeSeparator() {
		String timeInput = "10:30 am";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(timeInput);
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		
		assertEquals(referenceDateTimeObject.getDate(), dateParsed);
		assertEquals(referenceDayString, dayStrParsed);
		assertEquals(referenceDayInt, dayIntParsed);
		
		int timeInt = parsedDateTimeObject.getTimeInt();
		int expectedTimeInt = 1030;
		String time24HString = parsedDateTimeObject.getTime24hStr();
		String time12HString = parsedDateTimeObject.getTime12hStr();
		String expected24HTimeString = "10:30";
		String expected12HTimeString = "10.30 am";
		
		assertEquals(expectedTimeInt, timeInt);
		assertEquals(expected24HTimeString, time24HString);
		assertEquals(expected12HTimeString, time12HString);
	}
	
	@Test
	public void parseTenThirtyAmWithSpaceAndColonTimeSeparatorCaseInsensitive() {
		String timeInput = "10:30 AM";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(timeInput);
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		
		assertEquals(referenceDateTimeObject.getDate(), dateParsed);
		assertEquals(referenceDayString, dayStrParsed);
		assertEquals(referenceDayInt, dayIntParsed);
		
		int timeInt = parsedDateTimeObject.getTimeInt();
		int expectedTimeInt = 1030;
		String time24HString = parsedDateTimeObject.getTime24hStr();
		String time12HString = parsedDateTimeObject.getTime12hStr();
		String expected24HTimeString = "10:30";
		String expected12HTimeString = "10.30 am";
		
		assertEquals(expectedTimeInt, timeInt);
		assertEquals(expected24HTimeString, time24HString);
		assertEquals(expected12HTimeString, time12HString);
	}
	
	@Test
	public void parseTenThirtyAmWithoutSpaceAndColonTimeSeparator() {
		String timeInput = "10:30am";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(timeInput);
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		
		assertEquals(referenceDateTimeObject.getDate(), dateParsed);
		assertEquals(referenceDayString, dayStrParsed);
		assertEquals(referenceDayInt, dayIntParsed);
		
		int timeInt = parsedDateTimeObject.getTimeInt();
		int expectedTimeInt = 1030;
		String time24HString = parsedDateTimeObject.getTime24hStr();
		String time12HString = parsedDateTimeObject.getTime12hStr();
		String expected24HTimeString = "10:30";
		String expected12HTimeString = "10.30 am";
		
		assertEquals(expectedTimeInt, timeInt);
		assertEquals(expected24HTimeString, time24HString);
		assertEquals(expected12HTimeString, time12HString);
	}
	
	@Test
	public void parseTenThirtyAmWithoutSpaceAndColonTimeSeparatorCaseInsensitive() {
		String timeInput = "10:30Am";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(timeInput);
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		
		assertEquals(referenceDateTimeObject.getDate(), dateParsed);
		assertEquals(referenceDayString, dayStrParsed);
		assertEquals(referenceDayInt, dayIntParsed);
		
		int timeInt = parsedDateTimeObject.getTimeInt();
		int expectedTimeInt = 1030;
		String time24HString = parsedDateTimeObject.getTime24hStr();
		String time12HString = parsedDateTimeObject.getTime12hStr();
		String expected24HTimeString = "10:30";
		String expected12HTimeString = "10.30 am";
		
		assertEquals(expectedTimeInt, timeInt);
		assertEquals(expected24HTimeString, time24HString);
		assertEquals(expected12HTimeString, time12HString);
	}
	
	@Test
	public void parseTenThirtyPmWithSpaceAndColonTimeSeparator() {
		String timeInput = "10:30 pm";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(timeInput);
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		
		assertEquals(referenceDateTimeObject.getDate(), dateParsed);
		assertEquals(referenceDayString, dayStrParsed);
		assertEquals(referenceDayInt, dayIntParsed);
		
		int timeInt = parsedDateTimeObject.getTimeInt();
		int expectedTimeInt = 2230;
		String time24HString = parsedDateTimeObject.getTime24hStr();
		String time12HString = parsedDateTimeObject.getTime12hStr();
		String expected24HTimeString = "22:30";
		String expected12HTimeString = "10.30 pm";
		
		assertEquals(expectedTimeInt, timeInt);
		assertEquals(expected24HTimeString, time24HString);
		assertEquals(expected12HTimeString, time12HString);
	}
	
	@Test
	public void parseTenThirtyPmWithoutSpaceAndColonTimeSeparator() {
		String timeInput = "10:30pm";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(timeInput);
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		
		assertEquals(referenceDateTimeObject.getDate(), dateParsed);
		assertEquals(referenceDayString, dayStrParsed);
		assertEquals(referenceDayInt, dayIntParsed);
		
		int timeInt = parsedDateTimeObject.getTimeInt();
		int expectedTimeInt = 2230;
		String time24HString = parsedDateTimeObject.getTime24hStr();
		String time12HString = parsedDateTimeObject.getTime12hStr();
		String expected24HTimeString = "22:30";
		String expected12HTimeString = "10.30 pm";
		
		assertEquals(expectedTimeInt, timeInt);
		assertEquals(expected24HTimeString, time24HString);
		assertEquals(expected12HTimeString, time12HString);
	}
	
	@Test
	public void parseTenThirtyPm24HFormat() {
		String timeInput = "22:30";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(timeInput);
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		
		assertEquals(referenceDateTimeObject.getDate(), dateParsed);
		assertEquals(referenceDayString, dayStrParsed);
		assertEquals(referenceDayInt, dayIntParsed);
		
		int timeInt = parsedDateTimeObject.getTimeInt();
		int expectedTimeInt = 2230;
		String time24HString = parsedDateTimeObject.getTime24hStr();
		String time12HString = parsedDateTimeObject.getTime12hStr();
		String expected24HTimeString = "22:30";
		String expected12HTimeString = "10.30 pm";
		
		assertEquals(expectedTimeInt, timeInt);
		assertEquals(expected24HTimeString, time24HString);
		assertEquals(expected12HTimeString, time12HString);
	}
	
	@Test
	public void parseTenThirtyAm24HFormat() {
		String timeInput = "10:30";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(timeInput);
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		
		assertEquals(referenceDateTimeObject.getDate(), dateParsed);
		assertEquals(referenceDayString, dayStrParsed);
		assertEquals(referenceDayInt, dayIntParsed);
		
		int timeInt = parsedDateTimeObject.getTimeInt();
		int expectedTimeInt = 1030;
		String time24HString = parsedDateTimeObject.getTime24hStr();
		String time12HString = parsedDateTimeObject.getTime12hStr();
		String expected24HTimeString = "10:30";
		String expected12HTimeString = "10.30 am";
		
		assertEquals(expectedTimeInt, timeInt);
		assertEquals(expected24HTimeString, time24HString);
		assertEquals(expected12HTimeString, time12HString);
	}
	
	@Test(expected = IncorrectInputException.class)
	public void parseTwo24HTimeInASingleInput() {
		String timeInput = "20:30 10:30";
		dateTimeParser.parse(timeInput);
	}
	
	@Test(expected = IncorrectInputException.class)
	public void parseTwo12HTimeWithSpacingInASingleInput() {
		String timeInput = "12 pm 2 am";
		dateTimeParser.parse(timeInput);
	}
	
	@Test(expected = IncorrectInputException.class)
	public void parseTwo12HTimeWithoutSpacingInASingleInput() {
		String timeInput = "12pm 2am";
		dateTimeParser.parse(timeInput);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parse12HTimeWithTooManyNumbers() {
		String time = "10.20.30.40pm";
		dateTimeParser.parse(time);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parse24HTimeWithTooManyNumbers() {
		String time = "10:20:30:40";
		dateTimeParser.parse(time);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parseNegativeElevenAm() {
		String time = "-11am";
		dateTimeParser.parse(time);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parseZeroAm() {
		String time = "0am";
		dateTimeParser.parse(time);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parseTwentyFivePm() {
		String time = "25 Pm";
		dateTimeParser.parse(time);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parseThirteenPm() {
		String time = "13 Pm";
		dateTimeParser.parse(time);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parseThirteenSixtyPm() {
		String time = "3:60 Pm";
		dateTimeParser.parse(time);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parseThirteenSixtyAm() {
		String time = "3:60 Am";
		dateTimeParser.parse(time);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parseForteenNegativeElevenAm() {
		String time = "11.-11am";
		dateTimeParser.parse(time);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parseForteenNegativeElevenPm() {
		String time = "11.-11pm";
		dateTimeParser.parse(time);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parseForteenNegativeElevenAmWithSpacing() {
		String time = "11.-11 am";
		dateTimeParser.parse(time);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parseForteenNegativeElevenPmWithSpacing() {
		String time = "11.-11 pm";
		dateTimeParser.parse(time);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parseNegative24Hour() {
		String time = "-11:30";
		dateTimeParser.parse(time);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parseInvalid24HTimeExceedHour() {
		String time = "24:30";
		dateTimeParser.parse(time);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parseInvalid24HTimeExceedMinute() {
		String time = "2:60";
		dateTimeParser.parse(time);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parseInvalid24HTimeExceedHourAndMinute() {
		String time = "24:60";
		dateTimeParser.parse(time);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parseInvalid24HTimeNegativeMinute() {
		String time = "1:-60";
		dateTimeParser.parse(time);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parseInvalid24HTimeNegativeHour() {
		String time = "-1:50";
		dateTimeParser.parse(time);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parseInvalid24HTimeNegativeHourAndMinute() {
		String time = "-1:-50";
		dateTimeParser.parse(time);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parseNestedTimeIndicatorNestedPmTwoWords() {
		String time = "1.40 pmer";
		dateTimeParser.parse(time);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parseNestedTimeIndicatorAmTwoWords() {
		String time = "1.40 amer";
		dateTimeParser.parse(time);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parseNestedTimeIndicatorPmOneWords() {
		String time = "1.40pmer";
		dateTimeParser.parse(time);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parseNestedTimeIndicatorAmOneWords() {
		String time = "1.40amer";
		dateTimeParser.parse(time);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parseTimeAmAndPm() {
		String time = "1.40ampm";
		dateTimeParser.parse(time);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parseTimePmAndAm() {
		String time = "1.40pmam";
		dateTimeParser.parse(time);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parseTimePmAndAmTwoWords() {
		String time = "1.40 pmam";
		dateTimeParser.parse(time);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parseTimeAmAndPmTwoWords() {
		String time = "1.40 ampm";
		dateTimeParser.parse(time);
	}
	
	//********************************************
	//******** Tests for DateTimeParser **********
	//*** Permutation of date and time inputs ****
	//********************************************

	@Test
	public void parseTimeThatHasPassedWithToday() {
		String userInput = "today 5 am";
		DateTime parsedDateTimeObject = referenceDateTimeParser.parse(userInput);
		
		String dateParsed = parsedDateTimeObject.getDate();
		String dayStrParsed = parsedDateTimeObject.getDayStr();
		int dayIntParsed = parsedDateTimeObject.getDayInt();
		int time24hParsed = parsedDateTimeObject.getTimeInt();
		int expectedTime24H = 500;
		
		assertEquals(REFERENCE_TODAY_DATE, dateParsed);
		assertEquals(REFERENCE_TODAY_DAY_STRING, dayStrParsed);
		assertEquals(REFERENCE_TODAY_DAY_INT, dayIntParsed);
		assertEquals(expectedTime24H, time24hParsed);
	} 
	
	@Test
	public void parseWordDateAnd12HourAfternoonTimeWithSpacing() {
		String userInput = "15 June 2016 6 pm";
		DateTime dateTime = dateTimeParser.parse(userInput);
		
		String date = dateTime.getDate();
		String timeStr24H = dateTime.getTime24hStr();
		String timeStr12H = dateTime.getTime12hStr();
		String dayStr = dateTime.getDayStr();
		int dayInt = dateTime.getDayInt();
		int timeInt = dateTime.getTimeInt();
		
		assertEquals("15 Jun 2016", date);
		assertEquals("18:00", timeStr24H);
		assertEquals("6.00 pm", timeStr12H);
		assertEquals("Wednesday", dayStr);
		assertEquals(3, dayInt);
		assertEquals(1800, timeInt);
	}
	
	@Test
	public void parse12HourAfternoonTimeWithSpacingAndWordDate12HourAfternoonTimeWithSpacing() {
		String userInput = "6 pm 15 June 2016";
		DateTime dateTime = dateTimeParser.parse(userInput);
		
		String date = dateTime.getDate();
		String timeStr24H = dateTime.getTime24hStr();
		String timeStr12H = dateTime.getTime12hStr();
		String dayStr = dateTime.getDayStr();
		int dayInt = dateTime.getDayInt();
		int timeInt = dateTime.getTimeInt();
		
		assertEquals("15 Jun 2016", date);
		assertEquals("18:00", timeStr24H);
		assertEquals("6.00 pm", timeStr12H);
		assertEquals("Wednesday", dayStr);
		assertEquals(3, dayInt);
		assertEquals(1800, timeInt);
	}
	
	@Test
	public void parseDDMMYYDateAnd12HourAfternoonTimeWithoutSpacing() {
		String userInput = "19/02/2020 6.30pm";
		DateTime dateTime = dateTimeParser.parse(userInput);
		
		String date = dateTime.getDate();
		String timeStr24H = dateTime.getTime24hStr();
		String timeStr12H = dateTime.getTime12hStr();
		String dayStr = dateTime.getDayStr();
		int dayInt = dateTime.getDayInt();
		int timeInt = dateTime.getTimeInt();
		
		assertEquals("19 Feb 2020", date);
		assertEquals("18:30", timeStr24H);
		assertEquals("6.30 pm", timeStr12H);
		assertEquals("Wednesday", dayStr);
		assertEquals(3, dayInt);
		assertEquals(1830, timeInt);
	}
	
	@Test
	public void parse12HourAfternoonTimeWithoutSpacingAndDDMMYYDate() {
		String userInput = "6.30pm 19/02/2020";
		DateTime dateTime = dateTimeParser.parse(userInput);
		
		String date = dateTime.getDate();
		String timeStr24H = dateTime.getTime24hStr();
		String timeStr12H = dateTime.getTime12hStr();
		String dayStr = dateTime.getDayStr();
		int dayInt = dateTime.getDayInt();
		int timeInt = dateTime.getTimeInt();
		
		assertEquals("19 Feb 2020", date);
		assertEquals("18:30", timeStr24H);
		assertEquals("6.30 pm", timeStr12H);
		assertEquals("Wednesday", dayStr);
		assertEquals(3, dayInt);
		assertEquals(1830, timeInt);
	}
	
	@Test
	public void parseIncompleteWordNotOverDateAnd12HourMorningTimeWithSpacing() {
		String userInput = "15 Sept 6:45 am";
		DateTime dateTime = dateTimeParser.parse(userInput);
		
		String date = dateTime.getDate();
		String timeStr24H = dateTime.getTime24hStr();
		String timeStr12H = dateTime.getTime12hStr();
		String dayStr = dateTime.getDayStr();
		int dayInt = dateTime.getDayInt();
		int timeInt = dateTime.getTimeInt();
		
		assertEquals("15 Sep 2016", date);
		assertEquals("06:45", timeStr24H);
		assertEquals("6.45 am", timeStr12H);
		assertEquals("Thursday", dayStr);
		assertEquals(4, dayInt);
		assertEquals(645, timeInt);
	}
	
	@Test
	public void parse12HourMorningTimeWithSpacingAndIncompleteWordNotOverDate() {
		String userInput = "6:45 am 15 Sept";
		DateTime dateTime = dateTimeParser.parse(userInput);
		
		String date = dateTime.getDate();
		String timeStr24H = dateTime.getTime24hStr();
		String timeStr12H = dateTime.getTime12hStr();
		String dayStr = dateTime.getDayStr();
		int dayInt = dateTime.getDayInt();
		int timeInt = dateTime.getTimeInt();
		
		assertEquals("15 Sep 2016", date);
		assertEquals("06:45", timeStr24H);
		assertEquals("6.45 am", timeStr12H);
		assertEquals("Thursday", dayStr);
		assertEquals(4, dayInt);
		assertEquals(645, timeInt);
	}
	
	@Test
	public void parseIncompleteWordOverDateAnd12HourMorningTimeWithSpacing() {
		String userInput = "1 Jan 13:45";
		DateTime dateTime = dateTimeParser.parse(userInput);
		
		String date = dateTime.getDate();
		String timeStr24H = dateTime.getTime24hStr();
		String timeStr12H = dateTime.getTime12hStr();
		String dayStr = dateTime.getDayStr();
		int dayInt = dateTime.getDayInt();
		int timeInt = dateTime.getTimeInt();
		
		assertEquals("1 Jan 2017", date);
		assertEquals("13:45", timeStr24H);
		assertEquals("1.45 pm", timeStr12H);
		assertEquals("Sunday", dayStr);
		assertEquals(7, dayInt);
		assertEquals(1345, timeInt);
	}
	
	@Test
	public void parse12HourMorningTimeWithSpacingAndIncompleteWordOverDate() {
		String userInput = "13:45 1 Jan";
		DateTime dateTime = dateTimeParser.parse(userInput);
		
		String date = dateTime.getDate();
		String timeStr24H = dateTime.getTime24hStr();
		String timeStr12H = dateTime.getTime12hStr();
		String dayStr = dateTime.getDayStr();
		int dayInt = dateTime.getDayInt();
		int timeInt = dateTime.getTimeInt();
		
		assertEquals("1 Jan 2017", date);
		assertEquals("13:45", timeStr24H);
		assertEquals("1.45 pm", timeStr12H);
		assertEquals("Sunday", dayStr);
		assertEquals(7, dayInt);
		assertEquals(1345, timeInt);
	}
	
	@Test
	public void parse_DD_MM_OverDateAnd12HourMorningTimeWithoutSpacing() {
		String userInput = "10/2 6:45am";
		DateTime dateTime = dateTimeParser.parse(userInput);
		
		String date = dateTime.getDate();
		String timeStr24H = dateTime.getTime24hStr();
		String timeStr12H = dateTime.getTime12hStr();
		String dayStr = dateTime.getDayStr();
		int dayInt = dateTime.getDayInt();
		int timeInt = dateTime.getTimeInt();
		
		assertEquals("10 Feb 2017", date);
		assertEquals("06:45", timeStr24H);
		assertEquals("6.45 am", timeStr12H);
		assertEquals("Friday", dayStr);
		assertEquals(5, dayInt);
		assertEquals(645, timeInt);
	}
	
	@Test
	public void parse12HourMorningTimeWithoutSpacingAndDDMMOverDate() {
		String userInput = "6:45am 10/2";
		DateTime dateTime = dateTimeParser.parse(userInput);
		
		String date = dateTime.getDate();
		String timeStr24H = dateTime.getTime24hStr();
		String timeStr12H = dateTime.getTime12hStr();
		String dayStr = dateTime.getDayStr();
		int dayInt = dateTime.getDayInt();
		int timeInt = dateTime.getTimeInt();
		
		assertEquals("10 Feb 2017", date);
		assertEquals("06:45", timeStr24H);
		assertEquals("6.45 am", timeStr12H);
		assertEquals("Friday", dayStr);
		assertEquals(5, dayInt);
		assertEquals(645, timeInt);
	}
	
	@Test
	public void parseDDMMNotOverDateAnd24HourMorningTime() {
		String userInput = "10/10 8:45";
		DateTime dateTime = dateTimeParser.parse(userInput);
		
		String date = dateTime.getDate();
		String timeStr24H = dateTime.getTime24hStr();
		String timeStr12H = dateTime.getTime12hStr();
		String dayStr = dateTime.getDayStr();
		int dayInt = dateTime.getDayInt();
		int timeInt = dateTime.getTimeInt();
		
		assertEquals("10 Oct 2016", date);
		assertEquals("08:45", timeStr24H);
		assertEquals("8.45 am", timeStr12H);
		assertEquals("Monday", dayStr);
		assertEquals(1, dayInt);
		assertEquals(845, timeInt);
	}
	
	@Test
	public void parse24HourMorningTimeAndDDMMNotOverDate() {
		String userInput = "8:45 10/10";
		DateTime dateTime = dateTimeParser.parse(userInput);
		
		String date = dateTime.getDate();
		String timeStr24H = dateTime.getTime24hStr();
		String timeStr12H = dateTime.getTime12hStr();
		String dayStr = dateTime.getDayStr();
		int dayInt = dateTime.getDayInt();
		int timeInt = dateTime.getTimeInt();
		
		assertEquals("10 Oct 2016", date);
		assertEquals("08:45", timeStr24H);
		assertEquals("8.45 am", timeStr12H);
		assertEquals("Monday", dayStr);
		assertEquals(1, dayInt);
		assertEquals(845, timeInt);
	}
	
	@Test
	public void parseMMNotOverDateAnd24HourAfternoon() {
		String userInput = "Oct 19:15";
		DateTime dateTime = dateTimeParser.parse(userInput);
		
		String date = dateTime.getDate();
		String timeStr24H = dateTime.getTime24hStr();
		String timeStr12H = dateTime.getTime12hStr();
		String dayStr = dateTime.getDayStr();
		int dayInt = dateTime.getDayInt();
		int timeInt = dateTime.getTimeInt();
		
		assertEquals("15 Oct 2016", date);
		assertEquals("19:15", timeStr24H);
		assertEquals("7.15 pm", timeStr12H);
		assertEquals("Saturday", dayStr);
		assertEquals(6, dayInt);
		assertEquals(1915, timeInt);
	}
	
	@Test
	public void parse24HourAfternoonAndMMNotOverDate() {
		String userInput = "19:15 Oct";
		DateTime dateTime = dateTimeParser.parse(userInput);
		
		String date = dateTime.getDate();
		String timeStr24H = dateTime.getTime24hStr();
		String timeStr12H = dateTime.getTime12hStr();
		String dayStr = dateTime.getDayStr();
		int dayInt = dateTime.getDayInt();
		int timeInt = dateTime.getTimeInt();
		
		assertEquals("15 Oct 2016", date);
		assertEquals("19:15", timeStr24H);
		assertEquals("7.15 pm", timeStr12H);
		assertEquals("Saturday", dayStr);
		assertEquals(6, dayInt);
		assertEquals(1915, timeInt);
	}
	
	@Test
	public void parseMMNOverDateAnd24HourAfternoon() {
		String userInput = "Jan 19:15";
		DateTime dateTime = dateTimeParser.parse(userInput);
		
		String date = dateTime.getDate();
		String timeStr24H = dateTime.getTime24hStr();
		String timeStr12H = dateTime.getTime12hStr();
		String dayStr = dateTime.getDayStr();
		int dayInt = dateTime.getDayInt();
		int timeInt = dateTime.getTimeInt();
		
		assertEquals("15 Jan 2017", date);
		assertEquals("19:15", timeStr24H);
		assertEquals("7.15 pm", timeStr12H);
		assertEquals("Sunday", dayStr);
		assertEquals(7, dayInt);
		assertEquals(1915, timeInt);
	}
	
	@Test
	public void parse24HourAfternoonAndMMNOverDate() {
		String userInput = "19:15 Jan";
		DateTime dateTime = dateTimeParser.parse(userInput);
		
		String date = dateTime.getDate();
		String timeStr24H = dateTime.getTime24hStr();
		String timeStr12H = dateTime.getTime12hStr();
		String dayStr = dateTime.getDayStr();
		int dayInt = dateTime.getDayInt();
		int timeInt = dateTime.getTimeInt();
		
		assertEquals("15 Jan 2017", date);
		assertEquals("19:15", timeStr24H);
		assertEquals("7.15 pm", timeStr12H);
		assertEquals("Sunday", dayStr);
		assertEquals(7, dayInt);
		assertEquals(1915, timeInt);
	}

	@Test(expected = IncorrectInputException.class) 
	public void parseNegativeGibberish() {
		String relativeDate = "-10 Gibberish";
		dateTimeParser.parse(relativeDate);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parseGibberish() {
		String time = "-10 -1000 -2018 pm";
		dateTimeParser.parse(time);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parseEmptyString() {
		String numberDate = "";
		dateTimeParser.parse(numberDate);
	}
	
	@Test(expected = IncorrectInputException.class)
	public void parse24HTimeAndFullDateInOneWord() {
		String input = "10:15/5/2019";
		dateTimeParser.parse(input);
	}
	
	@Test(expected = IncorrectInputException.class)
	public void parse12HTimeAndFullDateInOneWord() {
		String input = "10.15/4/2017";
		dateTimeParser.parse(input);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void parseShortDateAnd24HTimeInOneWord() {
		String input = "3/6:30";
		dateTimeParser.parse(input);
	}
	
	@Test(expected = IncorrectInputException.class)
	public void parseShortDateAnd12HTimeInOneWord() {
		String input = "3/8.30";
		dateTimeParser.parse(input);
	}
	
	@Test(expected = IncorrectInputException.class)
	public void parse12HTimeAnd24HTimeInOneWord() {
		String input = "16:12.40";
		dateTimeParser.parse(input);
	}
}
```
###### test\dooyit\parser\ParserTest.java
``` java
package dooyit.parser;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import java.util.ArrayList;
import java.util.Arrays;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.powermock.reflect.Whitebox;

import dooyit.common.datatype.DateTime;
import dooyit.logic.commands.Command;
import dooyit.logic.commands.ShowCommand.ShowCommandType;

public class ParserTest {
	private static final String SHOW_COMMAND_TYPE = "showCommandType";
	private static final String ERROR_MESSAGE_INVALID_ADDCAT_COMMAND = "Invalid addcat command!";
	private static final String ERROR_MESSAGE_INVALID_ADD_COMMAND = "Invalid add command!";
	private static final String ERROR_MESSAGE_INVALID_DELETE_CATEGORY_COMMAND = "Invalid Delete Category Command!";
	private static final String ERROR_MESSAGE_TOO_FEW_ARGUMENTS = "Too few arguments for Edit Category Command";
	private static final String ERROR_MESSAGE_INVALID_EDIT_COMMAND = "Invalid edit Command!";
	private static final String ERROR_MESSAGE_NO_CATEGORY_SPECIFIED = "No category specified!";
	private static final String ERROR_MESSAGE_INVALID_COMMAND = "Invalid Command: ";
	private static final String ERROR_MESSAGE_INVALID_TASK_ID = "Invalid Task ID: ";
	
	ParserController parser;
	
	@Before
	public void setup() {
		parser = new ParserController();
	}
	
	//****************************************
	//***** Tests for UnmoveParser ***********
	//****************************************
	@Test
	public void unmoveSingleTaskId() {
		String input = "unmove 2";
		Command command = parser.getCommand(input);
		int taskIdsInCommand = Whitebox.getInternalState(command, "taskId");
		int expectedTaskIds = 2;
		assertEquals(expectedTaskIds, taskIdsInCommand);
	}
	
	@Test
	public void unmoveInvalidBlankTaskId() {
		String input = "unmove  ";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + "";
		assertEquals(expectedErrorMessage, commandErrorMessage);
	}
	
	//****************************************
	//***** Tests for DeleteParser ***********
	//****************************************
	@Test
	public void deleteSingleTaskId() {
		String input = "delete 2";
		Command command = parser.getCommand(input);
		ArrayList<Integer> taskIdsInCommand = Whitebox.getInternalState(command, "deleteIds");
		ArrayList<Integer> expectedTaskIds = new ArrayList<Integer>(Arrays.asList(2));
		assertEquals(expectedTaskIds, taskIdsInCommand);
	}
	
	@Test
	public void deleteInvalidSingleTaskIdAlphabet() {
		String input = "delete a";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + "a";
		assertEquals(expectedErrorMessage, commandErrorMessage);

	}
	
	@Test
	public void deleteInvalidSingleTaskIdColon() { 
		String input = "delete :";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + ":";
		assertEquals(expectedErrorMessage, commandErrorMessage);

	}
	
	@Test
	public void deleteInvalidSingleTaskIdQuestionMark() {
		String input = "delete ?";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + "?";
		assertEquals(expectedErrorMessage, commandErrorMessage);

	}
	
	@Test
	public void deleteInvalidSingleTaskIdEmptyString() {
		String input = "delete ";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID;
		assertEquals(expectedErrorMessage, commandErrorMessage);

	}
	
	@Test
	public void deleteMultipleTaskIds() {
		String input = "delete 2 3 5 7 20 12";
		Command command = parser.getCommand(input);
		ArrayList<Integer> taskIdsInCommand = Whitebox.getInternalState(command, "deleteIds");
		ArrayList<Integer> expectedTaskIds = new ArrayList<Integer>(Arrays.asList(2, 3, 5, 7, 20, 12));
		assertEquals(taskIdsInCommand, expectedTaskIds);
	}
	
	@Test
	public void deleteInvalidMultipleTaskIdsAlphabet() {
		String input = "delete 2 a 5 7 20 12";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + "a";
		assertEquals(expectedErrorMessage, commandErrorMessage);

	}
	
	@Test
	public void deleteInvalidMultipleTaskIdsColon() {
		String input = "delete 2 : 5 7 20 12";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + ":";
		assertEquals(expectedErrorMessage, commandErrorMessage);

	}
	
	@Test
	public void deleteInvalidMultipleTaskIdsBackslash() {
		String input = "delete 2" + " \\ 5 7 20 12";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + "\\";
		assertEquals(expectedErrorMessage, commandErrorMessage);

	}
	
	@Test
	public void deleteInvalidMultipleTaskIdsQuestionMark() {
		String input = "delete 2 ? 5 7 20 12";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + "?";
		assertEquals(expectedErrorMessage, commandErrorMessage);

	}
	
	@Test
	public void deleteIntervalOfTaskIds() {
		String input = "delete 2-7";
		Command command = parser.getCommand(input);
		ArrayList<Integer> taskIdsInCommand = Whitebox.getInternalState(command, "deleteIds");
		ArrayList<Integer> expectedTaskIds = new ArrayList<Integer>(Arrays.asList(2, 3, 4, 5, 6, 7));
		assertEquals(taskIdsInCommand, expectedTaskIds);
	}
	
	@Test
	public void deleteInvalidIntervalOfTaskIdsStartAlphabet() {
		String input = "delete a-7";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + "a-7";
		assertEquals(expectedErrorMessage, commandErrorMessage);

	}
	
	@Test
	public void deleteInvalidIntervalOfTaskIdsEndAlphabet() {
		String input = "delete 2-c";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + "2-c";
		assertEquals(expectedErrorMessage, commandErrorMessage);

	}
	
	@Test
	public void deleteInvalidIntervalOfTaskIdsStartAndEndAlphabet() {
		String input = "delete a-z";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + "a-z";
		assertEquals(expectedErrorMessage, commandErrorMessage);

	}
	
	@Test
	public void deleteInvalidIntervalOfTaskIdsStartColon() {
		String input = "delete :-3";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + ":-3";
		assertEquals(expectedErrorMessage, commandErrorMessage);

	}
	
	@Test
	public void deleteInvalidIntervalOfTaskIdsEndColon() {
		String input = "delete 1-:";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + "1-:";
		assertEquals(expectedErrorMessage, commandErrorMessage);

	}
	
	@Test
	public void deleteInvalidIntervalOfTaskIdsStartBackslash() {
		String input = "delete \\-3";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + "\\-3";
		assertEquals(expectedErrorMessage, commandErrorMessage);

	}
	
	@Test
	public void deleteInvalidIntervalOfTaskIdsEndBackslash() {
		String input = "delete 1-\\";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + "1-\\";
		assertEquals(expectedErrorMessage, commandErrorMessage);

	}
	
	@Test
	public void deleteInvalidIntervalFormat() {
		String input = "delete 1 - 10";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + "-";
		assertEquals(expectedErrorMessage, commandErrorMessage);
	}
	
	@Test
	public void deleteEmptyInput() {
		String input = "delete";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID;
		assertEquals(expectedErrorMessage, commandErrorMessage);
	}
	//****************************************
	//***** Tests for MarkParser ***********
	//****************************************
	@Test
	public void markSingleTaskId() {
		String input = "mark 2";
		Command command = parser.getCommand(input);
		ArrayList<Integer> taskIdsInCommand = Whitebox.getInternalState(command, "markIds");
		ArrayList<Integer> expectedTaskIds = new ArrayList<Integer>(Arrays.asList(2));
		assertEquals(taskIdsInCommand, expectedTaskIds);
	}
	
	@Test
	public void markInvalidSingleTaskIdAlphabet() {
		String input = "mark a";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + "a";
		assertEquals(expectedErrorMessage, commandErrorMessage);

	}
	
	@Test
	public void markInvalidSingleTaskIdColon() {
		String input = "mark :";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + ":";
		assertEquals(expectedErrorMessage, commandErrorMessage);

	}
	
	@Test
	public void markInvalidSingleTaskIdQuestionMark() {
		String input = "mark ?";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + "?";
		assertEquals(expectedErrorMessage, commandErrorMessage);

	}
	
	@Test
	public void markInvalidSingleTaskIdEmptyString() {
		String input = "mark ";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID;
		assertEquals(expectedErrorMessage, commandErrorMessage);

	}
	
	@Test
	public void markeMultipleTaskIds() {
		String input = "mark 2 3 5 7 20 12";
		Command command = parser.getCommand(input);
		ArrayList<Integer> taskIdsInCommand = Whitebox.getInternalState(command, "markIds");
		ArrayList<Integer> expectedTaskIds = new ArrayList<Integer>(Arrays.asList(2, 3, 5, 7, 20, 12));
		assertEquals(taskIdsInCommand, expectedTaskIds);
	}
	
	@Test
	public void markInvalidMultipleTaskIdsAlphabet() {
		String input = "mark 2 a 5 7 20 12";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + "a";
		assertEquals(expectedErrorMessage, commandErrorMessage);
	}
	
	@Test
	public void markInvalidIntervalFormat() {
		String input = "mark 1 - 10";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + "-";
		assertEquals(expectedErrorMessage, commandErrorMessage);
	}
	
	@Test
	public void markInvalidMultipleTaskIdsColon() {
		String input = "mark 2 : 5 7 20 12";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + ":";
		assertEquals(expectedErrorMessage, commandErrorMessage);

	}
	
	@Test
	public void markInvalidMultipleTaskIdsBackslash() {
		String input = "mark 2" + " \\ 5 7 20 12";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + "\\";
		assertEquals(expectedErrorMessage, commandErrorMessage);

	}
	
	@Test
	public void markInvalidMultipleTaskIdsQuestionMark() {
		String input = "mark 2 ? 5 7 20 12";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + "?";
		assertEquals(expectedErrorMessage, commandErrorMessage);

	}
	
	@Test
	public void markIntervalOfTaskIds() {
		String input = "mark 2-7";
		Command command = parser.getCommand(input);
		ArrayList<Integer> taskIdsInCommand = Whitebox.getInternalState(command, "markIds");
		ArrayList<Integer> expectedTaskIds = new ArrayList<Integer>(Arrays.asList(2, 3, 4, 5, 6, 7));
		assertEquals(taskIdsInCommand, expectedTaskIds);
	}
	
	@Test
	public void markInvalidIntervalOfTaskIdsStartAlphabet() {
		String input = "mark a-7";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + "a-7";
		assertEquals(expectedErrorMessage, commandErrorMessage);

	}
	
	@Test
	public void markInvalidIntervalOfTaskIdsEndAlphabet() {
		String input = "mark 2-c";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + "2-c";
		assertEquals(expectedErrorMessage, commandErrorMessage);

	}
	
	@Test
	public void markInvalidIntervalOfTaskIdsStartAndEndAlphabet() {
		String input = "mark a-z";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + "a-z";
		assertEquals(expectedErrorMessage, commandErrorMessage);

	}
	
	@Test
	public void markInvalidIntervalOfTaskIdsStartColon() {
		String input = "mark :-3";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + ":-3";
		assertEquals(expectedErrorMessage, commandErrorMessage);

	}
	
	@Test
	public void markInvalidIntervalOfTaskIdsEndColon() {
		String input = "mark 1-:";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + "1-:";
		assertEquals(expectedErrorMessage, commandErrorMessage);

	}
	
	@Test
	public void markInvalidIntervalOfTaskIdsStartBackslash() {
		String input = "mark \\-3";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + "\\-3";
		assertEquals(expectedErrorMessage, commandErrorMessage);

	}
	
	@Test
	public void markInvalidIntervalOfTaskIdsEndBackslash() {
		String input = "mark 1-\\";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + "1-\\";
		assertEquals(expectedErrorMessage, commandErrorMessage);
	}

	@Test
	public void markEmptyInput() {
		String input = "mark ";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID;
		assertEquals(expectedErrorMessage, commandErrorMessage);
	}
	//********************************************
	//********* Tests for UnmarkParser ***********
	//********************************************
	@Test
	public void unmarkSingleTaskId() {
		String input = "unmark 2";
		Command command = parser.getCommand(input);
		ArrayList<Integer> taskIdsInCommand = Whitebox.getInternalState(command, "unmarkIds");
		ArrayList<Integer> expectedTaskIds = new ArrayList<Integer>(Arrays.asList(2));
		assertEquals(expectedTaskIds, taskIdsInCommand);
	}
	
	@Test
	public void unmarkInvalidSingleTaskIdAlphabet() {
		String input = "unmark a";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + "a";
		assertEquals(expectedErrorMessage, commandErrorMessage);

	}
	
	@Test
	public void unmarkInvalidSingleTaskIdColon() {
		String input = "unmark :";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + ":";
		assertEquals(expectedErrorMessage, commandErrorMessage);

	}
	
	@Test
	public void unmarkInvalidSingleTaskIdQuestionMark() {
		String input = "unmark ?";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + "?";
		assertEquals(expectedErrorMessage, commandErrorMessage);

	}
	
	@Test
	public void unmarkInvalidSingleTaskIdEmptyString() {
		String input = "unmark ";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID;
		assertEquals(expectedErrorMessage, commandErrorMessage);

	}
	
	@Test
	public void unmarkeMultipleTaskIds() {
		String input = "unmark 2 3 5 7 20 12";
		Command command = parser.getCommand(input);
		ArrayList<Integer> taskIdsInCommand = Whitebox.getInternalState(command, "unmarkIds");
		ArrayList<Integer> expectedTaskIds = new ArrayList<Integer>(Arrays.asList(2, 3, 5, 7, 20, 12));
		assertEquals(taskIdsInCommand, expectedTaskIds);
	}
	
	@Test
	public void unmarkInvalidMultipleTaskIdsAlphabet() {
		String input = "unmark 2 a 5 7 20 12";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + "a";
		assertEquals(expectedErrorMessage, commandErrorMessage);

	}
	
	@Test
	public void unmarkInvalidMultipleTaskIdsColon() {
		String input = "unmark 2 : 5 7 20 12";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + ":";
		assertEquals(expectedErrorMessage, commandErrorMessage);

	}
	
	@Test
	public void unmarkInvalidMultipleTaskIdsBackslash() {
		String input = "unmark 2" + " \\ 5 7 20 12";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + "\\";
		assertEquals(expectedErrorMessage, commandErrorMessage);

	}
	
	@Test
	public void unmarkInvalidMultipleTaskIdsQuestionMark() {
		String input = "unmark 2 ? 5 7 20 12";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + "?";
		assertEquals(expectedErrorMessage, commandErrorMessage);

	}
	
	@Test
	public void unmarkIntervalOfTaskIds() {
		String input = "unmark 2-7";
		Command command = parser.getCommand(input);
		ArrayList<Integer> taskIdsInCommand = Whitebox.getInternalState(command, "unmarkIds");
		ArrayList<Integer> expectedTaskIds = new ArrayList<Integer>(Arrays.asList(2, 3, 4, 5, 6, 7));
		assertEquals(taskIdsInCommand, expectedTaskIds);
	}
	
	@Test
	public void unmarkInvalidIntervalOfTaskIdsStartAlphabet() {
		String input = "unmark a-7";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + "a-7";
		assertEquals(expectedErrorMessage, commandErrorMessage);

	}
	
	@Test
	public void unmarkInvalidIntervalOfTaskIdsEndAlphabet() {
		String input = "unmark 2-c";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + "2-c";
		assertEquals(expectedErrorMessage, commandErrorMessage);

	}
	
	
	@Test
	public void unmarkInvalidIntervalFormat() {
		String input = "unmark 1 - 10";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + "-";
		assertEquals(expectedErrorMessage, commandErrorMessage);
	}
	
	@Test
	public void unmarkInvalidIntervalOfTaskIdsStartAndEndAlphabet() {
		String input = "unmark a-z";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + "a-z";
		assertEquals(expectedErrorMessage, commandErrorMessage);
	}
	
	@Test
	public void unmarkInvalidIntervalOfTaskIdsStartColon() {
		String input = "unmark :-3";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + ":-3";
		assertEquals(expectedErrorMessage, commandErrorMessage);
	}
	
	@Test
	public void unmarkInvalidIntervalOfTaskIdsEndColon() {
		String input = "unmark 1-:";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + "1-:";
		assertEquals(expectedErrorMessage, commandErrorMessage);
	}
	
	@Test
	public void unmarkInvalidIntervalOfTaskIdsStartBackslash() {
		String input = "unmark \\-3";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + "\\-3";
		assertEquals(expectedErrorMessage, commandErrorMessage);
	}
	
	@Test
	public void unmarkInvalidIntervalOfTaskIdsEndBackslash() {
		String input = "unmark 1-\\";
		Command command = parser.getCommand(input);
				String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + "1-\\";
		assertEquals(expectedErrorMessage, commandErrorMessage);
	}
	
	@Test
	public void unmarkEmptyInput() {
		String input = "unmark ";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID;
		assertEquals(expectedErrorMessage, commandErrorMessage);
	}
	
	//******************************************
	//********* Tests for MoveParser ***********
	//******************************************
	@Test
	public void moveSingleTaskId() {
		String input = "move 2 movies";
		Command command = parser.getCommand(input);
		ArrayList<Integer> taskIdsInCommand = Whitebox.getInternalState(command, "taskIds");
		String categoryNameInCommand = Whitebox.getInternalState(command, "categoryName");
		ArrayList<Integer> expectedTaskIds = new ArrayList<Integer>(Arrays.asList(2));
		String expectedCategoryName = "movies";
		assertEquals(expectedTaskIds, taskIdsInCommand);
		assertEquals(expectedCategoryName, categoryNameInCommand);
	}
	
	@Test
	public void moveMultipleTaskIds() {
		String input = "move 2 3 12 17 6 movies";
		Command command = parser.getCommand(input);
		ArrayList<Integer> taskIdsInCommand = Whitebox.getInternalState(command, "taskIds");
		String categoryNameInCommand = Whitebox.getInternalState(command, "categoryName");
		ArrayList<Integer> expectedTaskIds = new ArrayList<Integer>(Arrays.asList(2, 3, 12, 17, 6));
		String expectedCategoryName = "movies";
		assertEquals(expectedTaskIds, taskIdsInCommand);
		assertEquals(expectedCategoryName, categoryNameInCommand);
	}
	
	@Test
	public void moveIntervalTaskIds() {
		String input = "move 2-6 movies";
		Command command = parser.getCommand(input);
		ArrayList<Integer> taskIdsInCommand = Whitebox.getInternalState(command, "taskIds");
		String categoryNameInCommand = Whitebox.getInternalState(command, "categoryName");
		ArrayList<Integer> expectedTaskIds = new ArrayList<Integer>(Arrays.asList(2, 3, 4, 5, 6));
		String expectedCategoryName = "movies";
		assertEquals(expectedTaskIds, taskIdsInCommand);
		assertEquals(expectedCategoryName, categoryNameInCommand);
	}
	
	@Test
	public void moveMultipleTaskIdsWithoutCategoryName() {
		String input = "move 2 3 12 17 6 ";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_NO_CATEGORY_SPECIFIED;
		assertEquals(expectedErrorMessage, commandErrorMessage);
	}
	
	
	@Test
	public void moveSingleTaskIdWithoutCategoryName() {
		String input = "move 2 ";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_NO_CATEGORY_SPECIFIED;
		assertEquals(expectedErrorMessage, commandErrorMessage);
	}
	
	@Test
	public void moveIntervalTaskIdsWithoutCategoryName() {
		String input = "move 2-6  ";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_NO_CATEGORY_SPECIFIED;
		assertEquals(expectedErrorMessage, commandErrorMessage);
	}
	
	@Test
	public void moveEmptyInput() {
		String input = "move ";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID;
		assertEquals(expectedErrorMessage, commandErrorMessage);
	}
	
	//******************************************
	//********* Tests for Remove alias *********
	//******************************************
	@Test
	public void removeAsDeleteSingleTaskId() {
		String input = "remove 2";
		Command command = parser.getCommand(input);
		ArrayList<Integer> taskIdsInCommand = Whitebox.getInternalState(command, "deleteIds");
		ArrayList<Integer> expectedTaskIds = new ArrayList<Integer>(Arrays.asList(2));
		assertEquals(expectedTaskIds, taskIdsInCommand);
	}
	
	@Test
	public void removeAsDeleteMultipleTaskIds() {
		String input = "remove 2 3 12 17 6";
		Command command = parser.getCommand(input);
		ArrayList<Integer> taskIdsInCommand = Whitebox.getInternalState(command, "deleteIds");
		ArrayList<Integer> expectedTaskIds = new ArrayList<Integer>(Arrays.asList(2, 3, 12, 17, 6));
		assertEquals(expectedTaskIds, taskIdsInCommand);
	}
	
	@Test
	public void removeAsDeleteIntervalTaskIds() {
		String input = "remove 2-4 5-8";
		Command command = parser.getCommand(input);
		ArrayList<Integer> taskIdsInCommand = Whitebox.getInternalState(command, "deleteIds");
		ArrayList<Integer> expectedTaskIds = new ArrayList<Integer>(Arrays.asList(2, 3, 4, 5, 6, 7, 8));
		assertEquals(expectedTaskIds, taskIdsInCommand);
	}
	
	//*******************************************
	//**** Tests for AddCategoryParser **********
	//*******************************************
	@Test
	public void addcategoryName() {
		String input = "addcat CS2103T";
		Command command = parser.getCommand(input);
		String categoryNameInCommand = Whitebox.getInternalState(command, "categoryName");
		String expectedCategoryName = "CS2103T";
		assertEquals(expectedCategoryName, categoryNameInCommand);
	}
	
	@Test
	public void addcategoryNameWithColour() {
		String input = "addcat CS2103T blue";
		Command command = parser.getCommand(input);
		String categoryNameInCommand = Whitebox.getInternalState(command, "categoryName");
		String categoryColourInCommand = Whitebox.getInternalState(command, "colourString");
		String expectedCategoryName = "CS2103T";
		String expectedCategoryColour = "blue";
		assertEquals(expectedCategoryName, categoryNameInCommand);
		assertEquals(expectedCategoryColour, categoryColourInCommand);
	}
	
	@Test
	public void addCategoryEmptyInput() {
		String input = "addcat ";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_ADDCAT_COMMAND;
		assertEquals(expectedErrorMessage, commandErrorMessage);
	}
	
	//********************************************
	//**** Tests for DeleteCategoryParser ********
	//********************************************
	@Test
	public void deleteCategory() {
		String input = "deletecat CS2103T";
		Command command = parser.getCommand(input);
		String categoryNameInCommand = Whitebox.getInternalState(command, "categoryName");
		String expectedCategoryName = "CS2103T";
		assertEquals(expectedCategoryName, categoryNameInCommand);
	}
	
	@Test
	public void deleteCategoryEmptyInput() {
		String input = "deletecat ";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_DELETE_CATEGORY_COMMAND;
		assertEquals(expectedErrorMessage, commandErrorMessage);
	}
	//********************************************
	//****** Tests for EditCategoryParser ********
	//********************************************
	@Test
	public void editCategoryName() {
		String input = "editcat CS2103T softwareEngineeringMod";
		Command command = parser.getCommand(input);
		String categoryNameInCommand = Whitebox.getInternalState(command, "categoryName");
		String newCategoryNameInCommand = Whitebox.getInternalState(command, "newCategoryName");
		String expectedCategoryName = "CS2103T";
		String expectedNewCategoryName = "softwareEngineeringMod";
		assertEquals(expectedCategoryName, categoryNameInCommand);
		assertEquals(expectedNewCategoryName, newCategoryNameInCommand);
	}
	
	@Test
	public void editCategoryNameAndColour() {
		String input = "editcat CS2103T softwareEngineeringMod to blue";
		Command command = parser.getCommand(input);
		String categoryNameInCommand = Whitebox.getInternalState(command, "categoryName");
		String newCategoryNameInCommand = Whitebox.getInternalState(command, "newCategoryName");
		String newColourInCommand = Whitebox.getInternalState(command, "newColourName");
		String expectedCategoryName = "CS2103T";
		String expectedNewCategoryName = "softwareEngineeringMod";
		String expectedColour = "blue";
		assertEquals(expectedCategoryName, categoryNameInCommand);
		assertEquals(expectedNewCategoryName, newCategoryNameInCommand);
		assertEquals(expectedColour, newColourInCommand);
	}
	
	@Test
	public void editCategoryColour() {
		String input = "editcat CS2103T to blue";
		Command command = parser.getCommand(input);
		String categoryNameInCommand = Whitebox.getInternalState(command, "categoryName");
		String newCategoryNameInCommand = Whitebox.getInternalState(command, "newCategoryName");
		String newColourInCommand = Whitebox.getInternalState(command, "newColourName");
		String expectedCategoryName = "CS2103T";
		String expectedNewCategoryName = "CS2103T";
		String expectedColour = "blue";
		assertEquals(expectedCategoryName, categoryNameInCommand);
		assertEquals(expectedNewCategoryName, newCategoryNameInCommand);
		assertEquals(expectedColour, newColourInCommand);
	}
	
	@Test
	public void editCategoryEmptyStringForColour() {
		String input = "editcat CS2103T to ";
		Command command = parser.getCommand(input);
		String categoryNameInCommand = Whitebox.getInternalState(command, "categoryName");
		String newCategoryNameInCommand = Whitebox.getInternalState(command, "newCategoryName");
		String expectedCategoryName = "CS2103T";
		String expectedNewCategoryName = "to";
		assertEquals(expectedCategoryName, categoryNameInCommand);
		assertEquals(expectedNewCategoryName, newCategoryNameInCommand);
	}
	
	@Test
	public void editCategoryEmptyString() {
		String input = "editcat ";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_TOO_FEW_ARGUMENTS;
		assertEquals(expectedErrorMessage, commandErrorMessage);
	}
	
	@Test
	public void editCategoryInsufficientArguments() {
		String input = "editcat CS2103T";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_TOO_FEW_ARGUMENTS;
		assertEquals(expectedErrorMessage, commandErrorMessage);
	}
	
	//********************************************
	//****** Tests for Change Skin Command *******
	//********************************************
	@Test
	public void changeSkinToDark() {
		String input = "skin dark";
		Command command = parser.getCommand(input);
		
		String theme = Whitebox.getInternalState(command, "themeString");
		String expectedTheme = "dark";
		assertEquals(expectedTheme, theme);
	}
	
	@Test
	public void changeSkinToAqua() {
		String input = "skin aqua";
		Command command = parser.getCommand(input);
		
		String theme = Whitebox.getInternalState(command, "themeString");
		String expectedTheme = "aqua";
		assertEquals(expectedTheme, theme);
	}
	
	@Test
	public void changeSkinToDefault() {
		String input = "skin light";
		Command command = parser.getCommand(input);
		
		String theme = Whitebox.getInternalState(command, "themeString");
		String expectedTheme = "light";
		assertEquals(expectedTheme, theme);
	}
	//********************************************
	//****** Tests for Set Storage Command *******
	//********************************************
	@Test
	public void setStoragePath() {
		String input = "storage documents/Dooyit/Data";
		Command command = parser.getCommand(input);
		
		String filePath = Whitebox.getInternalState(command, "path");
		String expectedFilePath = "documents/Dooyit/Data";
		assertEquals(expectedFilePath, filePath);
	}
	
	//********************************************
	//******** Tests for Search Command **********
	//********************************************
	@Test
	public void search() {
		String input = "search hello";
		Command command = parser.getCommand(input);
		
		String keyword = Whitebox.getInternalState(command, "searchString");
		String expectedKeyword = "hello";
		assertEquals(expectedKeyword, keyword);
	}
	
	//********************************************
	//********* Tests for ShowParser *************
	//********************************************
	@Test
	public void showToday() {
		String input = "show today";
		Command command = parser.getCommand(input);
		
		ShowCommandType view = Whitebox.getInternalState(command, SHOW_COMMAND_TYPE);
		ShowCommandType expectedView = ShowCommandType.TODAY;
		assertEquals(expectedView, view);
	}
	
	@Test
	public void showNextSeven() {
		String input = "show next7";
		Command command = parser.getCommand(input);
		
		ShowCommandType view = Whitebox.getInternalState(command, SHOW_COMMAND_TYPE);
		ShowCommandType expectedView = ShowCommandType.NEXT7DAY;
		assertEquals(expectedView, view);
	}
	
	@Test
	public void showAll() {
		String input = "show all";
		Command command = parser.getCommand(input);
		
		ShowCommandType view = Whitebox.getInternalState(command, SHOW_COMMAND_TYPE);
		ShowCommandType expectedView = ShowCommandType.ALL;
		assertEquals(expectedView, view);
	}
	
	@Test
	public void showFloat() {
		String input = "show float";
		Command command = parser.getCommand(input);
		
		ShowCommandType view = Whitebox.getInternalState(command, SHOW_COMMAND_TYPE);
		ShowCommandType expectedView = ShowCommandType.FLOAT;
		assertEquals(expectedView, view);
	}
	
	@Test
	public void showCompleted() {
		String input = "show completed";
		Command command = parser.getCommand(input);
		
		ShowCommandType view = Whitebox.getInternalState(command, SHOW_COMMAND_TYPE);
		ShowCommandType expectedView = ShowCommandType.COMPLETED;
		assertEquals(expectedView, view);
	}
	
	@Test
	public void showCategory() {
		String input = "showcat helloWorld";
		Command command = parser.getCommand(input);
		
		ShowCommandType view = Whitebox.getInternalState(command, SHOW_COMMAND_TYPE);
		ShowCommandType expectedView = ShowCommandType.CATEGORY;
		String categoryName = Whitebox.getInternalState(command, "categoryName");
		String expectedCategoryName = "helloWorld";
		assertEquals(expectedView, view);
		assertEquals(expectedCategoryName, categoryName);
	}
	
	//********************************************
	//************ Tests for AddParser ***********
	//********************************************
	@Test
	public void addFloatingTask() {
		String input = "add read book";
		Command command = parser.getCommand(input);
		
		String taskName = Whitebox.getInternalState(command, "taskName");
		String expectedTaskName = "read book";
		assertEquals(expectedTaskName, taskName);
	}
	
	@Test
	public void addFloatingTaskWithDeadlineMarker() {
		String input = "add gardens by the bay";
		Command command = parser.getCommand(input);
		
		String taskName = Whitebox.getInternalState(command, "taskName");
		String expectedTaskName = "gardens by the bay";
		assertEquals(expectedTaskName, taskName);
	}
	
	@Test
	public void addFloatingTaskWithEventMarkers() {
		String input = "add read book Harry Potter from chapter 1 to chapter 2";
		Command command = parser.getCommand(input);
		
		String taskName = Whitebox.getInternalState(command, "taskName");
		String expectedTaskName = "read book Harry Potter from chapter 1 to chapter 2";
		assertEquals(expectedTaskName, taskName);
	}
	
	@Test
	public void addEvent() {
		String input = "add read book Harry Potter from 12/2/2016 5pm to 14 feb 2016 7pm";
		Command command = parser.getCommand(input);
		
		String taskName = Whitebox.getInternalState(command, "taskName");
		String expectedTaskName = "read book Harry Potter";
		
		DateTimeParser dateTimeParser = new DateTimeParser();
		DateTime expectedStart = dateTimeParser.parse("12/2/2016 5pm");
		DateTime dateTimeStartInCommand = Whitebox.getInternalState(command, "dateTimeStart");
		DateTime expectedEnd = dateTimeParser.parse("14 feb 2016 7pm");
		DateTime dateTimeEndInCommand = Whitebox.getInternalState(command, "dateTimeEnd");
		
		assertEquals(expectedTaskName, taskName);
		assertTrue(expectedStart.equals(dateTimeStartInCommand));
		assertTrue(expectedEnd.equals(dateTimeEndInCommand));
	}
	
	@Test
	public void addEventSwitchPositionsEventMarkers() {
		String input = "add read book Harry Potter to 14 feb 2016 7pm from 12/2/2016 5pm";
		Command command = parser.getCommand(input);
		
		String taskName = Whitebox.getInternalState(command, "taskName");
		String expectedTaskName = "read book Harry Potter";
		
		DateTimeParser dateTimeParser = new DateTimeParser();
		DateTime expectedStart = dateTimeParser.parse("12/2/2016 5pm");
		DateTime dateTimeStartInCommand = Whitebox.getInternalState(command, "dateTimeStart");
		DateTime expectedEnd = dateTimeParser.parse("14 feb 2016 7pm");
		DateTime dateTimeEndInCommand = Whitebox.getInternalState(command, "dateTimeEnd");
		
		assertEquals(expectedTaskName, taskName);
		assertTrue(expectedStart.equals(dateTimeStartInCommand));
		assertTrue(expectedEnd.equals(dateTimeEndInCommand));
	}
	
	@Test
	public void addDeadlineTask() {
		String input = "add read book Harry Potter by 19/4/2017 3.30pm";
		Command command = parser.getCommand(input);
		String taskName = Whitebox.getInternalState(command, "taskName");
		String expectedTaskName = "read book Harry Potter";
		
		DateTimeParser dateTimeParser = new DateTimeParser();
		DateTime expectedDeadline = dateTimeParser.parse("19/4/2017 3.30pm");
		DateTime dateTimeInCommand = Whitebox.getInternalState(command, "dateTimeDeadline");
		
		assertEquals(expectedTaskName, taskName);
		assertTrue(expectedDeadline.equals(dateTimeInCommand));
	}
	
	@Test
	public void addEmptyInput() {
		String input = "add ";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_ADD_COMMAND;
		assertEquals(expectedErrorMessage, commandErrorMessage);
	}
	
	@Test
	public void Deadline_ValidOnADate_ExpectedTrue() {
		String homeworkTmr = "add assignment by 30/3 5pm";
		Command command = parser.getCommand(homeworkTmr);
		String name = Whitebox.getInternalState(command, "taskName");
		assertEquals("assignment", name);
		
		DateTime deadline = Whitebox.getInternalState(command, "dateTimeDeadline");
		DateTimeParser dtParser = new DateTimeParser();
		DateTime expectedDeadline = dtParser.parse("30/3 5pm");
		Assert.assertTrue(expectedDeadline.equals(deadline));
	}
	
	@Test
	public void DeadlineTmr_Invalid_InvalidCommand() {
		String proposalTmrInvalid = "add proposal by tmr 21312312";
		Command command = parser.getCommand(proposalTmrInvalid);
		
		String taskName = Whitebox.getInternalState(command, "taskName");
		String expectedTaskName = "proposal by tmr 21312312";
		assertEquals(expectedTaskName, taskName);
	}
	
	@Test
	public void Event_ValidDateTimeLong_ExpectedTrue() {
		String brunch = "add brunch from 10/12/2016 10am to 10/12/2016 1pm";
		Command command = parser.getCommand(brunch);
		
		//Setting expected results
		String expectedName = "brunch";
		DateTimeParser dtParser = new DateTimeParser();
		DateTime expectedStart = dtParser.parse("10/12/2016 10am");
		DateTime expectedEnd = dtParser.parse("10/12/2016 1pm");
		
		//Getting private attributes from AddParser
		String name = Whitebox.getInternalState(command, "taskName");
		DateTime start = Whitebox.getInternalState(command,"dateTimeStart");
		DateTime end = Whitebox.getInternalState(command, "dateTimeEnd");
		
		//Comparison with expected results
		Assert.assertEquals(expectedName, name);
		Assert.assertTrue(expectedStart.equals(start));
		Assert.assertTrue(expectedEnd.equals(end));
	}
	
	@Test
	public void Event_InvalidToDateTime_FloatingTask() {
		String brunchInvalidTo = "add brunch from 10/12/2016 10am to 1212332";
		Command command = parser.getCommand(brunchInvalidTo);
		String name = Whitebox.getInternalState(command, "taskName");
		String expectedName = "brunch from 10/12/2016 10am to 1212332";
		Assert.assertEquals(expectedName, name);
	}
	
	@Test
	public void Event_InvalidFromDateTime_FloatingTask() {
		String brunchInvalidFrom = "add brunch from 123123123 to 10/12/2016 12pm";
		Command command = parser.getCommand(brunchInvalidFrom);
		String name = Whitebox.getInternalState(command, "taskName");
		String expectedName = "brunch from 123123123 to 10/12/2016 12pm";
		Assert.assertEquals(expectedName, name);
	}
	
	@Test
	public void Event_EmptyFromDateTime_FloatingTask() {
		String brunch = "add brunch from to 10/12/2016 12pm";
		Command command = parser.getCommand(brunch);
		String name = Whitebox.getInternalState(command, "taskName");
		String expectedName = "brunch from to 10/12/2016 12pm";
		Assert.assertEquals(expectedName, name);
	}
	
	@Test
	public void Event_EmptyToDateTime_FloatingTask() {
		String brunch = "add brunch from 10/12/2016 12pm to ";
		Command command = parser.getCommand(brunch);
		String name = Whitebox.getInternalState(command, "taskName");
		String expectedName = "brunch from 10/12/2016 12pm to";
		Assert.assertEquals(expectedName, name);
	}
	
	
	@Test
	public void Event_EmptyFromToDateTime_AddFloat() {
		String brunch = "add brunch from to";
		Command command = parser.getCommand(brunch);
		
		String name = Whitebox.getInternalState(command, "taskName");
		String expectedName = "brunch from to";
		Assert.assertEquals(expectedName, name);
	}
	
	/*@Test
	public void EventWithCat_Valid_ExpectedTrue(){
		String marathon = "marathon from 10/4/2016 6am to 10/4/2016 9am @ Run";
		Command command = parser.getCommand(marathon);
		String categoryName = Whitebox.getInternalState(command, CATEGORY_NAME);
		Assert.assertEquals("Run", categoryName);
	}*/
	
	//********************************************
	//************ Tests for EditParser **********
	//********************************************
	@Test
	public void editName() {
		String input = "edit 1 buy healthy snacks";
		Command command = parser.getCommand(input);
		
		String newName = Whitebox.getInternalState(command, "taskName");
		String expectedName = "buy healthy snacks";
		assertEquals(expectedName, newName);
		
		int taskId = Whitebox.getInternalState(command, "taskId");
		int expectedTaskId = 1;
		assertEquals(expectedTaskId, taskId);
	}
	
	@Test
	public void editNameAndDeadline() {
		String input = "edit 12 buy healthy snacks by 30/3 5pm";
		Command command = parser.getCommand(input);
		
		String newName = Whitebox.getInternalState(command, "taskName");
		String expectedName = "buy healthy snacks";
		assertEquals(expectedName, newName);
		
		int taskId = Whitebox.getInternalState(command, "taskId");
		int expectedTaskId = 12;
		assertEquals(expectedTaskId, taskId);
		
		DateTime deadline = Whitebox.getInternalState(command, "dateTimeDeadline");
		DateTimeParser dtParser = new DateTimeParser();
		DateTime expectedDeadline = dtParser.parse("30/3 5pm");
		assertTrue(expectedDeadline.equals(deadline));
	}
	
	@Test
	public void editNameStartAndEndDateTime() {
		String input = "edit 15 buy healthy snacks from 30/3 4pm to 30/3 5pm";
		Command command = parser.getCommand(input);
		
		String newName = Whitebox.getInternalState(command, "taskName");
		String expectedName = "buy healthy snacks";
		assertEquals(expectedName, newName);
		
		int taskId = Whitebox.getInternalState(command, "taskId");
		int expectedTaskId = 15;
		assertEquals(expectedTaskId, taskId);
		
		DateTime startDateTime = Whitebox.getInternalState(command, "dateTimeStart");
		DateTimeParser dtParser = new DateTimeParser();
		DateTime expectedStartDateTime = dtParser.parse("30/3 4pm");
		assertTrue(expectedStartDateTime.equals(startDateTime));
		
		DateTime endDateTime = Whitebox.getInternalState(command, "dateTimeEnd");
		DateTime expectedEndDateTime = dtParser.parse("30/3 5pm");
		assertTrue(expectedEndDateTime.equals(endDateTime));
	}
	
	@Test
	public void editNameStartAndEndDateTimeFlipEventMarkers() {
		String input = "edit 15 buy healthy snacks from 30/3 4pm to 30/3 5pm";
		Command command = parser.getCommand(input);
		
		String newName = Whitebox.getInternalState(command, "taskName");
		String expectedName = "buy healthy snacks";
		assertEquals(expectedName, newName);
		
		int taskId = Whitebox.getInternalState(command, "taskId");
		int expectedTaskId = 15;
		assertEquals(expectedTaskId, taskId);
		
		DateTime startDateTime = Whitebox.getInternalState(command, "dateTimeStart");
		DateTimeParser dtParser = new DateTimeParser();
		DateTime expectedStartDateTime = dtParser.parse("30/3 4pm");
		assertTrue(expectedStartDateTime.equals(startDateTime));
		
		DateTime endDateTime = Whitebox.getInternalState(command, "dateTimeEnd");
		DateTime expectedEndDateTime = dtParser.parse("30/3 5pm");
		assertTrue(expectedEndDateTime.equals(endDateTime));
	}
	
	@Test
	public void editDeadline() {
		String input = "edit 12 by 30/3 5pm";
		Command command = parser.getCommand(input);
		
		int taskId = Whitebox.getInternalState(command, "taskId");
		int expectedTaskId = 12;
		assertEquals(expectedTaskId, taskId);
		
		DateTime deadline = Whitebox.getInternalState(command, "dateTimeDeadline");
		DateTimeParser dtParser = new DateTimeParser();
		DateTime expectedDeadline = dtParser.parse("30/3 5pm");
		assertTrue(expectedDeadline.equals(deadline));
	}
	
	@Test
	public void editStartAndEndDateTime() {
		String input = "edit 15 from 30/3 4pm to 30/3 5pm";
		Command command = parser.getCommand(input);
		
		int taskId = Whitebox.getInternalState(command, "taskId");
		int expectedTaskId = 15;
		assertEquals(expectedTaskId, taskId);
		
		DateTime startDateTime = Whitebox.getInternalState(command, "dateTimeStart");
		DateTimeParser dtParser = new DateTimeParser();
		DateTime expectedStartDateTime = dtParser.parse("30/3 4pm");
		assertTrue(expectedStartDateTime.equals(startDateTime));
		
		DateTime endDateTime = Whitebox.getInternalState(command, "dateTimeEnd");
		DateTime expectedEndDateTime = dtParser.parse("30/3 5pm");
		assertTrue(expectedEndDateTime.equals(endDateTime));
	}
	
	@Test
	public void editStartAndEndDateTimeFlipEventMarkers() {
		String input = "edit 15 to 30/3 5pm from 30/3 4pm";
		Command command = parser.getCommand(input);
		
		int taskId = Whitebox.getInternalState(command, "taskId");
		int expectedTaskId = 15;
		assertEquals(expectedTaskId, taskId);
		
		DateTime startDateTime = Whitebox.getInternalState(command, "dateTimeStart");
		DateTimeParser dtParser = new DateTimeParser();
		DateTime expectedStartDateTime = dtParser.parse("30/3 4pm");
		assertTrue(expectedStartDateTime.equals(startDateTime));
		
		DateTime endDateTime = Whitebox.getInternalState(command, "dateTimeEnd");
		DateTime expectedEndDateTime = dtParser.parse("30/3 5pm");
		assertTrue(expectedEndDateTime.equals(endDateTime));
	}
	
	@Test
	public void editEmptyInput() {
		String input = "edit ";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_EDIT_COMMAND;
		assertEquals(expectedErrorMessage, commandErrorMessage);
	}
	
	@Test
	public void editNoName() {
		String input = "edit 14 ";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_EDIT_COMMAND;
		assertEquals(expectedErrorMessage, commandErrorMessage);
	}
	
	@Test
	public void editNameToDeadlineMarker() {
		String input = "edit 14 by ";
		Command command = parser.getCommand(input);
		String newName = Whitebox.getInternalState(command, "taskName");
		String expectedName = "by";
		assertEquals(expectedName, newName);
		
		int taskId = Whitebox.getInternalState(command, "taskId");
		int expectedTaskId = 14;
		assertEquals(expectedTaskId, taskId);
	}
	
	@Test
	public void editNameToEventMarker() {
		String input = "edit 14 from to ";
		Command command = parser.getCommand(input);
		String newName = Whitebox.getInternalState(command, "taskName");
		String expectedName = "from to";
		assertEquals(expectedName, newName);
		
		int taskId = Whitebox.getInternalState(command, "taskId");
		int expectedTaskId = 14;
		assertEquals(expectedTaskId, taskId);
	}
	
	@Test
	public void editGibberishTaskId() {
		String input = "edit fjdsklghs hfsdlagujdfalg ";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_EDIT_COMMAND;
		assertEquals(expectedErrorMessage, commandErrorMessage);
	}
	
	//********************************************
	//********* Tests for FloatParser ************
	//********************************************
	@Test
	public void editToFloat() {
		String input = "float 14";
		Command command = parser.getCommand(input);
		int expectedTaskId = 14;
		int commandTaskId = Whitebox.getInternalState(command, "taskId");
		assertEquals(expectedTaskId, commandTaskId);
	}
	
	@Test
	public void editToFloatInvalidTaskId() {
		String input = "float  ";
		Command command = parser.getCommand(input);
		String commandErrorMessage = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_TASK_ID + "";
		assertEquals(expectedErrorMessage, commandErrorMessage);
	}
	
	//********************************************
	//********* Tests for Invalid Command ********
	//********************************************
	
	@Test
	public void EmptyString_InvalidCommand() {
		String empty = "";
		Command command = parser.getCommand(empty);
		
		String message = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_COMMAND + empty;
		Assert.assertEquals(expectedErrorMessage, message);
	}
	
	@Test
	public void parseGibberishInvalidCommand() {
		String gibberish = "dhasjkfhsbdk";
		Command command = parser.getCommand(gibberish);
		
		String message = Whitebox.getInternalState(command, "errorMessage");
		String expectedErrorMessage = ERROR_MESSAGE_INVALID_COMMAND + gibberish;
		Assert.assertEquals(expectedErrorMessage, message);
	}
}
```
###### test\dooyit\parser\ParserTestSuite.java
``` java
package dooyit.parser;

import org.junit.runner.RunWith;
import org.junit.runners.Suite;

@RunWith(Suite.class)
@Suite.SuiteClasses({ParserTest.class, DateTimeParserTest.class, TagParserTest.class})
public class ParserTestSuite {

}
```
###### test\dooyit\parser\TagParserTest.java
``` java
package dooyit.parser;

import static org.junit.Assert.*;

import java.util.ArrayList;
import java.util.Arrays;
import org.junit.Test;
import dooyit.common.exception.IncorrectInputException;

public class TagParserTest {
	TagParser tagParser = new TagParser();
	
	@Test
	public void tagSingleID() {
		String input = "1";
		tagParser.setAttributesForTagging(input);
		tagParser.parseTaskIds();
		ArrayList<Integer> expectedArrayList = new ArrayList<Integer>(Arrays.asList(1));
		assertEquals(expectedArrayList, tagParser.taskIdsForTagging);
	}
	
	@Test
	public void tagMultipleID() {
		String input = "1 3 4 12 25";
		tagParser.setAttributesForTagging(input);
		tagParser.parseTaskIds();
		ArrayList<Integer> expectedArrayList = new ArrayList<Integer>(Arrays.asList(1, 3, 4, 12, 25));
		assertEquals(expectedArrayList, tagParser.taskIdsForTagging);
	}
	
	@Test
	public void tagIntervalID() {
		String input = "1-8";
		tagParser.setAttributesForTagging(input);
		tagParser.parseTaskIds();
		ArrayList<Integer> expectedArrayList = new ArrayList<Integer>(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8));
		assertEquals(expectedArrayList, tagParser.taskIdsForTagging);
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void tagInvalidIntervalID() {
		String input = "a-10";
		tagParser.setAttributesForTagging(input);
		tagParser.parseTaskIds();
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void tagInvalidMultipleID() {
		String input = "a hu 9 10";
		tagParser.setAttributesForTagging(input);
		tagParser.parseTaskIds();
	}
	
	@Test(expected = IncorrectInputException.class) 
	public void tagInvalidSingleID() {
		String input = "a";
		tagParser.setAttributesForTagging(input);
		tagParser.parseTaskIds();
	}
	
}
```
